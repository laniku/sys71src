;__________________________________________________________________________________________________
;
;	File:		HardwarePrivateEqu.a
;
;	Contains:	Macintosh assembly equates THAT ARE NOT TO BE RELEASED TO THE WORLD.
;
;	Copyright:	© 1990-1993 by Apple Computer, Inc.  All rights reserved.
;
;	Change History (most recent first):
;
;	  <SM30>	12/13/93	PN		Roll in KAOs and Horror changes to support Malcom and AJ
;									machines
;	  <SM29>	11/16/93	SAM		Added an eieio macro for use on systems that have non serialized
;									i/o space.  Basically, the macro will expand to a 68k NOP if
;									"forNonSerializedIO" is set to true.
;	  <SM28>	 11/9/93	KW		added eieioSTP macro.  When forSTP601 is defined as True, a 68k
;									nop instruction will be added.  Emulator turns 68k nop into
;									eieio.  Only effects the CygnusX1 ROM
;	  <SM27>	  8/4/93	JDR		private sound defines are in SoundPrivate.a
;	  <SM26>	 7/20/93	SAM		Fixed the ROMHeader record.  Added the fields the SuperMario
;									guys forgot to add to the end of the structure.
;	  <SM25>	 7/14/93	RC		Added BART nubus controller register defs for PDM and Cold
;									Fusion
;	  <SM24>	  5/6/93	SAM		More generic AMIC stuff.
;	  <SM23>	 4/22/93	SAM		Added some general AMIC equates (for PDM).
;	  <SM22>	 3/31/93	chp		Synchronize SuperMario with changes from <LW2>.
;	   <LW2>	 2/24/93	chp		Added equates for the PSC wait/request multiplexer control bits
;									in VIA1.
;	  <SM21>	01-12-93	jmp		Added in the CSC equates.
;	  <SM20>	 12/4/92	SWC		Added ascPlayRecA to the ASC equates.
;	  <SM19>	 12/1/92	EH		Added Pratt Memory controller equates and Via1 equates for
;									Blackbird.
;	  <SM18>	 11/6/92	rab		Roll in Horror changes. Comments follow:
;	   <H28> 	10/12/92	BG		Added symbolic constants for refering to the CPU ID bits that
;									describe CPU_SPEED and CPU_ID values for Wombat/WLCD/Vail040.
;	   <H27>	  9/6/92	jab		Added SCSI configuration info for BIOS.
;	   <H26>	 8/25/92	BG		Added definitions for BIOS configuration registers.
;	  <SM17>	10/27/92	fau		Added a YMCABase to the YMCA equ's.
;	  <SM16>	 9/30/92	fau		Added a couple of constants for YMCA register sizes to aid in
;									the SizeMem programming;  renamed a couple of YMCA registers to
;									something better.
;	  <SM15>	 9/16/92	WS		Fix bug change / to _
;	  <SM14>	 9/16/92	WS
;	  <SM14>	 9/15/92	gjs		Added the YMCA equates for EVT-4.
;	  <SM13>	 8/17/92	CCH		Bumped HeapStart to $2800.
;	  <SM12>	  8/7/92	JDB		Changed Singer control register to have 0 for the output
;									attenuation and  5 for the input gain.
;	  <SM11>	07-14-92	jmp		(ag,H24) Change the name of a bit from PontiSndExtMic to
;									PontiSndIntMic
;									(jmp,H23) Added some additional DAFB equates for the WombatDAFB
;									code.
;									(BG,H22) Added one more djMEMC-related symbolic definition
;									(dj_MaxBanks).
;	  <SM10>	 6/21/92	ejb		Adding bit field definitions for dspOverrun register in PSC.
;	   <SM9>	 6/21/92	RB		Adding runtime support for EVT1 and EVT2 Cyclones. Defined
;									temporary equates for  the EVT1 Cyclone units.
;	   <SM8>	 6/18/92	KW		(BG,H21) Added djMEMC memory controller equates for Wombat and
;									WLCD.
;									(jmp,H20) Wombat has a different dot-clock chip than
;									Spike/Eclipse/Zydeco, so I added an equate to reflect this.
;	   <SM7>	 6/18/92	RB		Added equates for the new EVT2 (final offsets) of the VIA2 on
;									Cyclone. The old values are still supported under the
;									conditional forEVT1. These should be deleted once everyone moves
;									to EVT2 boards. Did the same with MUNIBase as well.
;	   <SM6>	  6/4/92	KW		(fau,P18) Added and equate for Civic_VidInDble to support Civic
;									II.
;	   <SM5>	 5/25/92	RB		Removed a forCyclone conditional. This should be the last one
;									left. Renamed MSCBank1Enable to MSCBank8M.
;	   <SM4>	 5/21/92	RB		Making changes for Cyclone. Some comments may be duplicated due
;									to the Pandora/Terror history. <P17> 5/13/92 KW (ag,H18) Added
;									Ponti Definitions. (BG,H17) Added symbol v2MicCtl to the VIA2
;									bit definitions. This is a microphone control bit that is
;									defined for Wombat. Also updated some comments from Eclipse and
;									Zydeco to the appropriate Quadra names. <P16> 4/16/92 KW (SWC,
;									H16) Set bufWorldSize to 8K so Macsbug won't load into the
;									middle of DBLite's sound buffer and get trashed when a sound is
;									played. <P15> 03/24/92 jmp Renamed one of the MMC registers to
;									something more appropriate (i.e., MMC_Interlace to
;									MMC_ClockSelect). <P14> 03/22/92 jmp Put back <P12>. <P13>
;									3/19/92 FU Rolled back changes in <P12>. <P12> 3/18/92 FU
;									(SWC,H15) Added SCSI DiskMode bit definitions for Niagra to the
;									VIA 1 list. <P11> 03/04/92 jmp Updated the comments and changed
;									the names of some of the Civic-related equates. <P10> 02/28/92
;									jmp (ejb) Turned off the DSP frame-interrupt enable bit so that
;									DSP driver doesn’t suffer frame overrun when it trys to boot the
;									DSP. <P9> 02/20/92 jmp (JC,H14) Define PatchFlags in unused by
;									of ROM header ($0014). Define PatchBits based on available
;									features in BBSStartup. Include support for Horror based and
;									Pandora (Cyclone) based ROMs. <P8> 2/19/92 chp (jmp,H13) Put a
;									“hasSonora1” conditional around the Sonora video control
;									register base address to reflect impending hardware changes to
;									Sonora. <P7> 02/07/92 jmp (HJR,H12) Added new Niagra Equates.
;									(SWC,H11) One more go-round on MSC configuration: RAM bank 1
;									needs to be disabled since there's only 2MB on DBLite LC.
;									(SWC,H10) Fixed the MSC configuration value: it needs to be
;									setup for a minimum amount of RAM so that the sound FIFO will
;									always exist in real RAM for BootBeep. (SWC,H9) Added an equate
;									for the default MSC configuration register value. Also, added
;									Civic and Civic-related equates for Cyclone. <P6> 2/5/92 RMP
;									Added MUNI equates. <P5> 1/21/92 mal Added PSC VIA2 equates <P4>
;									1/18/92 RMP Added PSC sound equates. <P3> 1/15/92 RP Fixed
;									header (sorry). <P2> 1/15/92 RP Added new VIA definition bits
;									and MMC equates.
;	   <SM3>	 5/17/92	kc		Roll in Horror Changes. Comments follow:
;	   <H16>	  4/8/92	SWC		Set bufWorldSize to 8K so Macsbug won't load into the middle of
;									DBLite's sound buffer and get trashed when a sound is played.
;	   <H15>	  3/3/92	SWC		Added SCSI DiskMode bit definitions for Niagra to the VIA 1
;									list.
;	   <H14>	 2/19/92	JC		Define PatchFlags in unused by of ROM header ($0014). Define
;									PatchBits based on available features in BBSStartup.  Include
;									support for Horror based and Pandora (Cyclone) based ROMs.
;	   <H11>	 1/23/92	SWC		One more go-round on MSC configuration: RAM bank 1 needs to be
;									disabled since there's only 2MB on DBLite LC.
;	   <H10>	 1/22/92	SWC		Fixed the MSC configuration value: it needs to be setup for a
;									minimum amount of RAM so that the sound FIFO will always exist
;									in real RAM for BootBeep.
;		<H9>	 1/22/92	SWC		Added an equate for the default MSC configuration register
;									value.
;		<H8>	12/20/91	JC		Create common Via2/RBV offset equates and temporary redefinition
;									on Sonora Specific builds to only use RBV offsets
;		<H6>	12/03/91	jmp		Added various (but not yet complete) SonoraAddr and
;									Sonora-VDACAddr equates.  Sorry to have cancelled your check-out
;									swc, but we had pressing needs.
;		<H5>	11/26/91	jmp		Added equates for the GSC.
;		<H4>	11/25/91	SAM		Added Sonora specific equate for RAMSize reg.
;		<H2>	  8/5/91	SWC		Added MSCPowerCycle, the offset to the power cycle register from
;									the base of the MSC.

;	   <T21>	  7/8/91	HJR		Rename JAWSAuxWaitS to JAWSEconoMode register to reflect its new
;									pupose in life.
;	   <T20>	 5/24/91	jmp		Added another VIA2, port A, bit-7 equate for Spike & Eclipse:
;									v2SyncOnGreen.  This bit allows us to enable & disable the
;									sync-on-green signal in ACDC.
;	   <T19>	 5/10/91	djw		Add sound input select bits for Eclipse in VIA2
;	   <T18>	  5/1/91	HJR		Added in register definitions for the MSC memory controller
;									(DB-Lite).
;	   <T17>	  4/1/91	BG		Modified the v2Keyswitch bit definition to agree with what it
;									will be on DVT Eclipse.
;	   <T14>	  3/3/91	BG		Added bit definition for Eclipse Keyswitch bit in VIA2.
;	   <T12>	 2/16/91	BG		Added Orwell constants to deal with 33MHz.
;		<T8>	 1/18/91	CCH		Added equates for Spike's VIA2.
;		<T6>	 11/7/90	BG		Made changes for new rev. of Orwell (2) permanent.
;	   <SM2>	 4/22/92	RB		Moved the start of the System heap in order to get some space
;									for vector tables. This movement of the heap from $2000 to $2100
;									is for experimentation and will need to be changed at a later
;									date.
;		<35>	12/31/91	RB		Renamed JAWSAuxWaitS to JAWSEconoMode to reflect its real
;									purpose.
;		<34>	12/29/91	RB		Updated some of the Terror constants.
;		<33>	10/28/91	SAM/KSM	Rolled in Regatta file.
;
;	Regatta Change History:
;
;		 <2>	  8/8/91	SAM		(pdw, ag) Added some equates from HardwarePrivateEqu in
;									TERROR.
;		 <1>	  8/8/91	SAM		Split off from 7.0 GM sources.
;
;	7.0 Change History:
;
;		<32>	 10/1/91	JSM		Don’t use eclipseDebug.
;		<31>	 8/30/91	DTY		Complicate matters so onMac32 stuff doesn’t get defined for
;									onMac, onMacPP, or onMacHc. (Since these aren’t defined in
;									BBSStartup anymore, this is necessary.)
;		<30>	 8/22/91	JSM		Clean up header.
;		<29>	 7/24/91	MH		Added conditional wrapper(s) to prevent duplication of public
;									interface declarations: TimeSCSIDB
;		<28>	 1/30/91	gbm		sab, #38: Change the ‘already including this file’ variable to
;									all uppercase (for security reasons)
;		<27>	11/26/90	gbm		(and bbm) On 7.0 (and other places eventually) HiIntMask will be
;									$0700 instead of $0300 all the time, not just when on a
;									non-Plus.
;		<26>	10/22/90	JJ		Rex V8: Added equates for V8 registers
;		<25>	 9/24/90	BG		Added symbolic names for the Data and Instruction Cache enable
;									bits for the CACRs of various machines.
;		<24>	 9/13/90	MSH		A couple of VIA2 assignments have changed for TIM.
;		<23>	  9/1/90	BG		Updated and added various constants to agree with the EVT1
;									version of the Eclipse board.
;		<22>	 7/11/90	gbm		Take out some things that are in SysEqu.a
;		<21>	  7/6/90	CCH		Changed default ROM wait states and RAM refresh rate for
;									Eclipse.
;		<20>	 6/27/90	CCH		Took out the conditionals around TestInRam!
;		<19>	 6/27/90	CCH		TestInRAM macro gets compiled when eclipseDebug is set.
;		<18>	 5/24/90	HJR		Update Machine equate to 7 instead of 6 for newer machines.
;		<16>	  4/4/90	HJR		Clean up some build problems.
;		<15>	  4/4/90	MSH		forrom removal.
;		<14>	  4/4/90	MSH		Merged HardwareEqu.a back into HardwarePrivateEqu.a and
;									restructured/rewrote the resultant file. This action obsoletes
;									HardwareEqu.a. All future equate additions should be done to
;									HardwarePrivateEqu.a only.
;		<13>	 3/29/90	MSH		Add VIA2 labels for Waimea.
;		<12>	 3/22/90	JJ		Force definition of onElsie=0 if onElsie is undefined.
;		<11>	 2/14/90	DAF		Added VISA register names.  Since Elsie isn't fully integrated,
;									it doesn't have  real feature conditional yet.
;		<10>	  2/9/90	BG		Modified ORWELL_INIT value to reflect the parts being used on
;									the Eclipse prototype.
;		 <9>	  2/9/90	JJ		Added RvExp, offset of RBV Expansion Register in Elsie.
;		 <8>	  2/9/90	BG		Moved EQUs for the Eclipse VIA2 out of the -ELSEIF onEclipse-,
;									as those definitions will be used even if the -onEclipse-
;									conditional stuff is not used.
;		 <7>	  2/2/90	BG		Missed one re-definition in previous change.
;		 <6>	  2/2/90	BG		Modified some bits in the Eclipse VIA2 buffer A description to
;									have relevant mnemonic names.
;		 <5>	 1/31/90	BG		Added Orwell-specific register bit definitions, address offsets
;									and configuration register initial values.
;		 <4>	 1/30/90	BG		Added Eclipse-specific hardware constant definitions.
;		 <3>	 1/18/90	SWC		Updating FMCInit and FMCRPUInit with the final values.
;		 <2>	 1/12/90	CCH		Added missing ENDIF.
;		 <1>	 1/11/90	CCH		Moved in private equates from “HardwareEqu.a”.
;
;	NOTE:
;
;		For change history versions not mentioned in the above -Change History-, refer
;		to <Sources>:Interfaces:AIncludes:HardwareEqu.a.
;

	IF &TYPE('__INCLUDINGHARDWAREPRIVATEEQU__') = 'UNDEFINED' THEN
__INCLUDINGHARDWAREPRIVATEEQU__	SET	1



;__________________________________________________________________________________________
;
; Welcome to the New Hardware Equates File.  By following some simple procedures this file
; can keep its youthful appearance for years to come.  This file is a recombination of
; HardwareEqu.a and HardwarePrivateEqu.a.  Everyone should be using this file only.  Please
; change any of your files that use either of the hardware equate files to use only this one.
; HardwareEqu.a will be left as an historical artifact for future generations.
;
; To help you navigate through this file use the "Mark" menu item, and please help to keep
; it current.  When you add a new section, add a handy mark to find it again.  Equates are
; grouped in a semi-logical way in the follwing order:
;
;		Chip Offsets - Register offsets for the 'standard' Mac peripheral chips.
;		Chip Offsets 2 - Register offsets for the 'non-standard' Mac peripheral chips.
;		VIA1 - Register offsets and pin descriptions.
;		VIA2 - Register offsets and pin descriptions.
;		RBV - Register offsets and pin descriptions.
;		VISA - Register offsets and pin descriptions.
;		Memory Controllers - Register definitions and miscellaneous equates.
;		Interrupts - Auto vector names and mask definitions.
;		Miscellaneous - The "Smorgasboard" of equates.
;		Old 16 Bit Equates - Machine dependent equates for Mac, MacPP, HcMac, and Mac16.
;
;
;__________________________________________________________________________________________





;__________________________________________________________________________________________
;
;
; Chip Offsets - Register offsets for "standard" Mac chips.  This includes the following:
;				 IWM, SWIM, SCC, SCSI (with and without DMA), ASC.
;
;
;__________________________________________________________________________________________


;---------------------------------------------------
; IWM Offsets
;---------------------------------------------------

ph0L  			EQU 		0 						; disk address offsets from base
ph0H  			EQU 		$200
ph1L  			EQU 		$400
ph1H  			EQU 		$600
ph2L  			EQU 		$800
ph2H  			EQU 		$A00
ph3L  			EQU 		$C00
ph3H  			EQU 		$E00
mtrOff			EQU 		$1000
mtrOn 			EQU 		$1200
intDrive  		EQU 		$1400 					; enable internal drive address
extDrive  		EQU 		$1600 					; enable external drive address
q6L   			EQU 		$1800
q6H   			EQU 		$1A00
q7L   			EQU 		$1C00
q7H   			EQU 		$1E00

IWMInitMode		equ			$17						; initial IWM mode setting				<3.5>

;---------------------------------------------------
;  SWIM offsets
;---------------------------------------------------

wData 			EQU 		$0000 					;Write a data byte
wMark 			EQU 		$0200 					;Write a mark byte
wCRC  			EQU 		$0400 					;Write a 2-byte CRC (1 access does both)
wIWMConfig		EQU 		wCRC  					;Set IWM configuration
wParams   		EQU 		$0600 					;Set the 16 parameter registers
wPhase			EQU 		$0800 					;Set phase lines states and directions
wSetup			EQU 		$0A00 					;Set the current configuration
wZeroes   		EQU 		$0C00 					;Mode reg: 1's clr bits, 0's=don't care
wOnes 			EQU 		$0E00 					;Mode reg: 1's set bits, 0's=don't care
rData 			EQU 		$1000 					;Read a data byte
rCorrection   	EQU 		rData 					;Read the correction factor
rMark 			EQU 		$1200 					;Read a mark byte
rError			EQU 		$1400 					;Error register
rParams   		EQU 		$1600 					;Parameters (16 bytes deep at this addr)
rPhase			EQU 		$1800 					;Phase lines states and directions
rSetup			EQU 		$1A00 					;Read the current configuration
rStatus   		EQU 		$1C00 					;Status (returns current mode reg value)
rHandshake		EQU 		$1E00 					;Handshake register


;---------------------------------------------------
; 8530 SCC Offsets
;---------------------------------------------------

aData 			EQU 		6 						; offset for A channel data
aCtl  			EQU 		2 						; offset for A channel control
bData 			EQU 		4 						; offset for B channel data
bCtl  			EQU 		0 						; offset for B channel control
sccData   		EQU 		4 						; general offset for data from control
rxBF  			EQU 		0 						; SCC receive buffer full
txBE  			EQU 		2 						; SCC transmit buffer empty
RxCA			EQU			0						; Receive Character Available


;---------------------------------------------------
; 53C80 SCSI Register Defs, Offsets
;---------------------------------------------------

sCDR  			EQU 		$00   					; Current SCSI Read Data
sODR  			EQU 		$00   					; Output data register
sICR  			EQU 		$10   					; Initiator Command Register - READ/WRITE
iRST  			EQU 		$80   					; *RST asserted
iAIP  			EQU 		$40   					; arbitration in progress (read)
bAIP  			EQU 		6 						; bit test for arbitration in progress
aTMD  			EQU 		$40   					; assert Test Mode (write)
iLA   			EQU 		$20   					; Lost arbitration (read)
bLA   			EQU 		5 						; bit test for Lost Arbitration
aDIFF 			EQU 		$20   					; assert Differential enable (write)
iACK  			EQU 		$10   					; *ACK is asserted
iBSY  			EQU 		$08   					; *BSY is asserted
iSEL  			EQU 		$04   					; *SEL is asserted
iATN  			EQU 		$02   					; *ATN is asserted
iDB   			EQU 		$01   					; Data bus is asserted
sMR   			EQU 		$20   					; Mode Register - READ/WRITE
iBDMA 			EQU 		$80   					; Block Mode DMA
iTGT  			EQU 		$40   					; Target Mode
iPTY  			EQU 		$20   					; Enable Parity Checking
iIPTY 			EQU 		$10   					; Enable Parity interrupt
iIEOP 			EQU 		$08   					; Enable EOP interrupt
iMBSY 			EQU 		$04   					; Monitor BSY
iDMA  			EQU 		$02   					; DMA Mode
iARB  			EQU 		$01   					; Arbitration
sTCR  			EQU 		$30   					; Target Command Register - READ/WRITE
iREQ  			EQU 		$08   					; Assert *REQ
iMSG  			EQU 		$04   					; Assert *MSG
iCD   			EQU 		$02   					; Assert C/*D
iIO   			EQU 		$01   					; Assert I/*O
sCSR  			EQU 		$40   					; Current SCSI Bus Status (READ)
aRST  			EQU 		$80   					; *RST
aBSY  			EQU 		$40   					; *BSY
bBSY  			EQU 		6 						; bit test for *BSY
aREQ  			EQU 		$20   					; *REQ
bREQ  			EQU 		5 						; bit test for *REQ
aMSG  			EQU 		$10   					; *MSG
bMSG  			EQU 		4 						; bit test for *MSG
aCD   			EQU 		$08   					; C/*D
bCD   			EQU 		3 						; bit test for C/*D
aIO   			EQU 		$04   					; I/*O
bIO   			EQU 		2 						; bit test for I/*O
aSEL  			EQU 		$02   					; *SEL
bSEL  			EQU 		1 						; bit test for *SEL
aDBP  			EQU 		$01   					; *DBP
sSER  			EQU 		$40   					; Select Enable Register (WRITE)
sBSR  			EQU 		$50   					; Bus & Status Register (READ)
iEDMA 			EQU 		$80   					; End of DMA
bEDMA 			EQU 		7 						; bit test for end of DMA
iDMAR 			EQU 		$40   					; DMA Request
bDMAR 			EQU 		6 						; bit test for DMA Req
iPERR 			EQU 		$20   					; Parity Error
iIREQ 			EQU 		$10   					; Interrupt Request
bIREQ 			EQU 		4 						; bit test for interrupt
iPM   			EQU 		$08   					; Phase Match
bPM   			EQU 		3 						; bit test for Phase Match
iBERR 			EQU 		$04   					; Bus Error
ATN   			EQU 		$02   					; *ATN
ACK   			EQU 		$01   					; *ACK
bACK  			EQU 		0 						; bit test for ACK
sDMAtx			EQU 		$50   					; DMA Transmit Start (WRITE)
sIDR  			EQU 		$60   					; Data input register (READ)
sTDMArx   		EQU 		$60   					; Start Target DMA receive (WRITE)
sRESET			EQU 		$70   					; Reset Parity/Interrupt (READ)
sIDMArx   		EQU 		$70   					; Start Initiator DMA receive (WRITE)


;---------------------------------------------------
;  SCSI DMA chip register offsets
;---------------------------------------------------

;  Note that the 53C80 registers are provided on the SCSI DMA chip.  The registers
;  described here are in addition to the 53C80 registers.

sDCTRL			EQU			$80
bDMAEN			EQU			0						; bit to enable SCSI DMA
iDMAEN			EQU			$0001					; mask to enable SCSI DMA
bINTREN			EQU			1						; bit to enable SCSI DMA interrupts
iINTREN			EQU			$0002					; mask to enable SCSI DMA interrupts
bTIMEEN			EQU			2						; bit to enable watchdog timer intr's
iTIMEEN			EQU			$0004					; mask to enable watchdog timer intr's
bHSKEN			EQU			3						; bit to enable hardware-handshaking (write)
iHSKEN			EQU			$0008					; mask to enable hardware-handshaking (write)
bRESET			EQU			4						; bit to reset SCSI DMA chip (write)
iRESET			EQU			$0010					; mask to reset SCSI DMA chip (write)
bFIFO			EQU			4						; bit indicating bytes left in FIFO (read)
iFIFO			EQU			$0010					; mask indicating bytes left in FIFO (read)
bTEST			EQU			5						; bit to enable SCSI Test Mode (write)
iTEST			EQU			$0020					; mask to enable SCSI Test Mode (write)
bSCSIP			EQU			6						; bit indicating SCSI intr pending (read)
iSCSIP			EQU			$0040					; mask indicating SCSI intr pending (read)
bTIMEP			EQU			7						; bit indicating timer intr pending (read)
iTIMEP			EQU			$0080					; mask indicating timer intr pending (read)
bDMABERR		EQU			8						; bit indicating DMA bus error (read)
iDMABERR		EQU			$0100					; mask indicating DMA bus error (read)
iARBID			EQU			$0E00					; mask to get target ID for arbitration
bARBIDEN		EQU			12						; bit to enable hardware arbitration
iARBIDEN		EQU			$1000					; mask to enable hardware arbitration
bWONARB			EQU			13						; bit indicating successful arbitration
iWONARB			EQU			$2000					; mask indicating successful arbitration
iINFIFO			EQU			$C000					; mask to get bytes left in FIFO (read)

sDCNT			EQU			$C0

sDADDR			EQU			$100

sDTIME			EQU			$140

sTEST			equ			$180

;__________________________________________________________________________________________
;
;
; Chip Offsets - Register offsets for "non standard" Mac chips.  This includes the following:
;				 OSS and IOP.
;
;
;__________________________________________________________________________________________


;---------------------------------------------------
;  OSS (Operating System Support) Chip Address & Offsets
;---------------------------------------------------

OSSMskFirst		equ			$000					;offset to first interrupt mask register
OSSMskSlot9		equ			OSSMskFirst				;offset to slot 9 interrupt mask register
OSSMskSlotA		equ			$001					;offset to slot A interrupt mask register
OSSMskSlotB		equ			$002					;offset to slot B interrupt mask register
OSSMskSlotC		equ			$003					;offset to slot C interrupt mask register
OSSMskSlotD		equ			$004					;offset to slot D interrupt mask register
OSSMskSlotE		equ			$005					;offset to slot E interrupt mask register
OSSMskPSwm		equ			$006					;offset to SWIM PIC interrupt mask register
OSSMskPScc		equ			$007					;offset to SCC PIC interrupt mask register
OSSMskSnd		equ			$008					;offset to Sound interrupt mask register
OSSMskScsi		equ			$009					;offset to SCSI interrupt mask register
OSSMsk60Hz		equ			$00A					;offset to 60 Hz interrupt mask register
OSSMskVia1		equ			$00B					;offset to VIA1 interrupt mask register
OSSMskRTC		equ			$00C					;offset to RTC interrupt mask register
OSSMskADB		equ			$00D					;offset to ADB interrupt mask register (not used)		<5.1>
OSSMskRPU		equ			$00E					;offset to RPU interrupt mask register					<4.8>
OSSMskLast		equ			OSSMskRPU				;offset to last interrupt mask register

rpuReset		EQU			$010					; RPU write offset to reset serial ptr					<4.9>

OSSIntStat		equ			$202					;offset to interrupt status register. Bits are:			<3.7>
													;  15:  interrupt 15 (spare) pending
													;  14:  interrupt 14 (RPU) pending						<4.8>
													;  13:  interrupt 13 (spare) pending					<5.1>
													;  12:  interrupt 12 (RTC) pending
													;  11:  interrupt 11 (VIA1) pending
													;  10:  interrupt 10 (60 Hz) pending
													;   9:  interrupt 9 (SCSI) pending
													;   8:  interrupt 8 (sound) pending
													;   7:  interrupt 7 (SCC PIC) pending
													;   6:  interrupt 6 (SWIM PIC) pending
													;   5:  interrupt 5 (slot E) pending
													;   4:  interrupt 4 (slot D) pending
													;   3:  interrupt 3 (slot C) pending
													;   2:  interrupt 2 (slot B) pending
													;   1:  interrupt 1 (slot A) pending
													;   0:  interrupt 0 (slot 9) pending

;••••• NOTE: In the new OSS, the interrupt status register is a long word starting at $200.			<3.7>
;•••••		 Since only the low-order word is currently used, making a single change here			<3.7>
;•••••		 has less impact on the ROM sources.  When we permanently switch over to the			<3.7>
;•••••		 new OSS hardware, then it may make sense to fix this equate and change all its			<3.7>
;•••••		 uses from MOVE.Ws to MOVE.Ls.															<3.7>

OSSRomCntl		equ			$204					;offset to ROM control register.  Bits are:
													;  <to be specified - see Steve Ray's spec>				<2.0>

OSSPwrOff		equ			OSSRomCntl				;power off is now a bit in the ROM control register		<5.1>
OSSPwrOffBit	equ			7						;    7:  write a 1 here to power off the machine		<2.1><3.7>

OSSCntrCntl		equ			$205					;offset to counter control register.  Bits are
													;  7-2:  unused
													;    1:  test control.  A 1 causes each 4 bit
													;        counter segment to count in parallel
													;    0:  counter hold.  A 1 holds current value
													;        so all 64 bits can be read.  Hold doesn't
													;        affect counting, though!

OSSInpStat		equ			$206					;offset to input status register.  Bits are
													;  7-2:  not used, read as zero
													;    1:  SCC write request. Not used if PIC present
													;    0:  mini-phono device plugged in flag.  A 1
													;        means a device IS plugged in.

OSS60HzAck		equ			$207					;offset to 'Clear 60 Hz interrupt flag' register.  Both	<3.7>
													; writes and reads clear it, so might as well write it.

OSSCounter		equ			$208					;offset to 64 bit counter register.  Low order 8
													;.bits are always read as zero (maybe not in future...)

;  Bit numbers in OSS interrupt status register

OSSIntIOPSWIM	equ			6						;bit # of SWIM IOP in interrupt status register
OSSIntIOPSCC	equ			7						;bit # of SCC IOP in interrupt status register
OSSIntSound		equ			8						;bit # of ASC in interrupt status register
OSSIntSCSI		equ			9						;bit # of SCSI in interrupt status register
OSSIntVBL60Hz	equ			10						;bit # of 60Hz VBL in interrupt status register
OSSIntVia1		equ			11						;bit # of VIA 1 in interrupt status register
OSSIntRTC		equ			12						;bit # of RTC in interrupt status register
OSSIntADB		equ			13						;bit # of ADB in interrupt status register
OSSIntRPU		equ			14						;bit # of RPU in interrupt status register		<4.8>
OSSIntLast		equ			14						;bit # of last interrupt source

OSSRomInit		EQU			$D						; initial value for ROM control register<3.5>


;---------------------------------------------------
;  IOP (Input Output Processor) Chip Offsets and bit definitions
;---------------------------------------------------

iopRamAddrH		equ			$0000-$20				; high byte of shared RAM address register
iopRamAddrL		equ			$0002-$20				; low byte of shared RAM address register
iopRamAddr		equ			iopRamAddrL-1			; WORD access to shared RAM address register

iopRamData		equ			$0008-$20				; shared RAM data register (byte, word, or long)
iopStatCtl		equ			$0004-$20				; IOP Status and Control register

;	bit numbers within the iopStatCtl register
iopInBypassMode	equ			0						; IOP is in BYPASS mode
iopIncEnable	equ			1						; enable addr pointer increment
iopRun			equ			2						; 0 -> reset IOP, 1 -> run IOP
iopGenInterrupt	equ			3						; interrupt the IOP
iopInt0Active	equ			4						; interrupt 0 active
iopInt1Active	equ			5						; interrupt 1 active
iopBypassIntReq	equ			6						; peripheral chip interrupt request in bypass mode
iopSCCWrReq		equ			7						; 0 -> SCC REQ active, 1 -> inactive

;	commands bytes to write to the iopStatCtl register
setIopIncEnable	equ			(1<<iopIncEnable)|\		; set increment enable
							(1<<iopRun)				; leave iop running

clrIopIncEnable	equ			(0<<iopIncEnable)|\		; reset increment enable
							(1<<iopRun)				; leave iop running

clrIopInt0		equ			(1<<iopInt0Active)|\	; clear interrupt 0 active
							(1<<iopRun)|\			; leave iop running
							(1<<iopIncEnable)		; leave increment enabled

clrIopInt1		equ			(1<<iopInt1Active)|\	; clear interrupt 1 active
							(1<<iopRun)|\			; leave iop running
							(1<<iopIncEnable)		; leave increment enabled

setIopGenInt	equ			(1<<iopGenInterrupt)|\	; interrupt the IOP
							(1<<iopRun)|\			; leave iop running
							(1<<iopIncEnable)		; leave increment enabled

resetIopRun		equ			(0<<iopRun)|\			; stop iop from running
							(1<<iopInt0Active)|\	; clear interrupt 0 active
							(1<<iopInt1Active)|\	; clear interrupt 1 active
							(1<<iopIncEnable)		; set increment enable

setIopRun		equ			(1<<iopRun)|\			; start iop running
							(1<<iopInt0Active)|\	; clear interrupt 0 active
							(1<<iopInt1Active)|\	; clear interrupt 1 active
							(1<<iopIncEnable)		; set increment enable



;__________________________________________________________________________________________
;
;
; The STP card has problems when accessing VIA's if the 601 instruction 'eieio' is not
; not used to force in order execution. Macro expands to nop only when conditional build
; flag forSTP601 is defined as TRUE.  The 68k nop instruction is turned into an eieio
; instruction by the emulator.
;__________________________________________________________________________________________

	MACRO
	eieioSTP	; do nop if forSTP601 is set, emulator does eieio for 68k nop
		if forSTPnop then
			nop								; force write to complete
		endif
	ENDM


;__________________________________________________________________________________________ <SAM>
; Enforce In-order Execution of I/O.
;
; This macro is for use on systems that have non-serialized memory-mapped I/O.
; It will order loads and stores ensuring that all previous storage accesses
; previously initiated by the processor are complete with respect to main storage.
;
; The macro will expand only if the build conditional "hasSerializedIO" is true.  It will
; expand to a 68K "NOP" which the V0 emulator translates to a PowerPC "eieio" instrucion.
;__________________________________________________________________________________________
	MACRO
	eieio									; do nop if nonSerializedIO is set
		if nonSerializedIO then
			nop								; force writes to complete
		endif
	ENDM




;__________________________________________________________________________________________
;
;
; VIA1 or Equivalent Pin Definitions and Register Offsets - Multiple names for the same pin
; are grouped together.  New definitions for VIA1 pins are added such that the grouping is
; maintained.
;
;
;__________________________________________________________________________________________

;---------------------------------------------------
; 6522 VIA1 (and VIA2) register offsets
;---------------------------------------------------

vBufB 			EQU 		0 						; BUFFER B
vBufAH			EQU 		$200  					; buffer a (with handshake) [ Dont use! ]
vDIRB 			EQU 		$400  					; DIRECTION B
vDIRA 			EQU 		$600  					; DIRECTION A
vT1C  			EQU 		$800  					; TIMER 1 COUNTER (L.O.)
vT1CH 			EQU 		$A00  					; timer 1 counter (high order)
vT1L  			EQU 		$C00  					; TIMER 1 LATCH (L.O.)
vT1LH 			EQU 		$E00  					; timer 1 latch (high order)
vT2C  			EQU 		$1000 					; TIMER 2 LATCH (L.O.)
vT2CH 			EQU 		$1200 					; timer 2 counter (high order)
vSR   			EQU 		$1400 					; SHIFT REGISTER
vACR  			EQU 		$1600 					; AUX. CONTROL REG.
vPCR  			EQU 		$1800 					; PERIPH. CONTROL REG.
vIFR  			EQU 		$1A00 					; INT. FLAG REG.
vIER  			EQU 		$1C00 					; INT. ENABLE REG.
vBufA 			EQU 		$1E00 					; BUFFER A
vBufD 			EQU 		vBufA 					; disk head select is buffer A			<3.5>

;---------------------------------------------------
; VIA IFR/IER bits
;---------------------------------------------------

ifCA2 			EQU 		0 						; CA2 interrupt
ifCA1 			EQU 		1 						; CA1 interrupt
ifSR  			EQU 		2 						; SR shift register done
ifCB2 			EQU 		3 						; CB2 interrupt
ifCB1 			EQU 		4 						; CB1 interrupt
ifT2  			EQU 		5 						; T2 timer2 interrupt
ifT1  			EQU 		6 						; T1 timer1 interrupt
ifIRQ 			EQU 		7 						; any interrupt


;---------------------------------------------------
; VIA1 Port A definitions
;---------------------------------------------------

vSound			EQU 		$7    					; sound volume bits (0..2)	(output)

vTestJ			EQU 		0 						; Burn In Test jumper		(input)

vCpuId0			EQU			1						; CPU Identification bit 0	(input)
vCpuId1			EQU			2						; CPU Identification bit 1	(input)
vSync 			EQU 		3 						; Synchronous modem
vOverlay  		EQU 		4 						; overlay bit (overlay when 1)
vCpuId2			EQU			4						; CPU Identification bit 2
vReqAEnable		EQU			4						; enable ReqA into vSCCWrReq (PSC only)		<LW2>
vHeadSel  		EQU 		5 						; head select line for Sony
vCpuId3			EQU			6						; CPU Identification bit 3
vRev8Bd   		EQU 		6 						; =0 for rev 8 board>
vReqBEnable		EQU			6						; enable ReqB into vSCCWrReq (PSC only)		<LW2>
vSCCWrReq 		EQU 		7 						; SCC write/request line

;---------------------------------------------------
; VIA1 Port B definitions
;---------------------------------------------------

vEclipseLED		EQU			0						; flashable Eclipse LED (how quaint!)		<23>
vRTCData  		EQU 		0 						; real time clock data
vRMP0			EQU			0						; Reserved for RMP (PSC only)
vENetIDClk		EQU			0						; Ethernet ID ROM clock	for Whitney			<SM19>
vRTCClk   		EQU 		1 						; real time clock clock pulses
vRMP1			EQU			1						; Reserved for RMP (PSC only)
vENetIDData   	EQU 		1 						; Ethernet ID ROM clock	for Whitney			<SM19>
vRTCEnb   		EQU 		2 						; clock enable (0 for enable)
vRMP2			EQU			2						; Reserved for RMP (PSC only)
vFDBInt   		EQU 		3 						; Front Desk bus interrupt
vXcvrsesbit		EQU			3						; Egret transceiver session bit			<6>
vSDMCable		EQU			3						; SCSI DiskMode cable sense for Dartanian	<H15>
vCudaTREQ		EQU			3						; Cuda transaction request input		<P2><SM4> rb
vSDMDiskID		EQU			4						; DiskMode HD ID (bits 4-6) for Dartanian	<H15>
vFDesk1   		EQU 		4 						; Front Desk bus state bit 0
vViafullbit		EQU			4						; Egret via full bit					<6>
vCudaBYTEACK	EQU			4						; Cuda byte acknowledge output			<P2><SM4> rb
vFDesk2   		EQU 		5 						; Front Desk bus state bit 1
vSyssesbit		EQU			5						; Egret system session bit				<6><SM4> rb
vCudaTIP		EQU			5						; Cuda interface transaction in progress output <P2>
vAUXIntEnb 		EQU 		6 						; switch to A/UX interrupt scheme (output)	<23>
vPGCEnb			EQU			6						; Parity Generator/Checker enable (0 for enable)
vJMPDude6		EQU			6						; Reserved for JMP (PSC only)
vPGCErr			EQU			7						; Parity Generator/Checker error	(input)
vSndEnb   		EQU 		7 						; /sound enable (reset when 1)		(output)
vSWInt	  		EQU 		7 						; cause a software interrupt	(output)	<23>
vJMPDude7		EQU			7						; Reserved for JMP (PSC only)



;__________________________________________________________________________________________
;
;
; VIA2 or Equivalent Pin Definitions and Register Offsets - Multiple names for the same pin
; are grouped together.  New definitions for VIA2 pins are added such that the grouping is
; maintained.
;
;
;__________________________________________________________________________________________

;---------------------------------------------------
; VIA2 Port A definitions
;---------------------------------------------------

v2IRQ1			EQU 		0 						; slot 1 interrupt
v2EnetIRQ		EQU			0						; on-board ethernet								<8><23>
v2IRQ2			EQU 		1 						; slot 2 interrupt
v2IRQ3			EQU 		2 						; slot 3 interrupt
v2IRQ4			EQU 		3 						; slot 4 interrupt
v2IRQ5			EQU 		4 						; slot 5 interrupt
v2IRQ6			EQU 		5 						; slot 6 interrupt
v2RAM0			EQU 		6 						; RAM size bit 0
v2LCDIRQ		EQU			6						; on-board LCD video
v2VideoIRQ		EQU			6						; on-board video								<8><23>
v2RAM1			EQU 		7 						; RAM size bit 1
v2CardIn		EQU			7						; on-board video
v2SyncOnGreen	EQU			7						; for enabling/disabling Sync-on-Green (DAFB)	<T20>

;---------------------------------------------------
; VIA2 Port B definitions
;---------------------------------------------------

v2ConfigLE		EQU			0						; DFAC config latch enable						<T8>
v2CDis			EQU 		0 						; cache disable (when 1)	<3.3>
v2Keyswitch		EQU			0						; 900/950 ONLY - keyswitch shadow bit (1=SECURE)<T14><T17><SM4> rb
v2BusLk   		EQU 		1 						; Bus lockout
v2PMack			EQU 		1 						; Power manager handshake acknowledge
v2PowerOff		EQU 		2 						; soft power off signal (when 0)
													; (also 900/950 keyswitch OFF bit)				<T17><SM4> rb
v2PMreq			EQU 		2 						; Power manager handshake request
v2ConfigData 	EQU 		3 						; DFAC config data								<T8>
v2FC3  			EQU 		3 						; PMMU FC3 indicator
vFC3  			EQU 		3 						; PMMU FC3 indicator
v2SndInSel0		EQU			3						; Eclipse only - sound input select bit 0		<t19><H17>
v2ConfigClk		EQU 		4 						; DFAC config clock								<T8>
v2TM1A			EQU 		4 						; bit for NUBus
v2TM0A			EQU 		5 						; and another
v2Speed			EQU 		5 						; 25/33 Mhz 68040 input (0=25MHz, 1=33 MHz)
v2MicCtl		EQU			5						; microphone control on Wombats					<H17><SM4> rb
v2HMMU			EQU			5 						; HMMU 24/32									<15> HJR
v2CDis2			EQU			6						; On Tim the CDIS is on pb6						<15> HJR
v2SndExt  		EQU 		6 						; 1 = internal speaker, 0 = ext. audio
v2SndInSel1		EQU			6						; Q900/950 only - sound input select bit 1		<t19><SM4> rb
v2VBL 			EQU 		7 						; pseudo VBL signal
v2ModemRST		EQU			7						; Modem.Reset									<15> HJR



													; temporary Cyclone equates <SM4> rb, start, <SM5> rb


; <SM7> rb, • TEMP EQUATES

CycloneEVT1Reg	EQU			$A55A2800				; id which identifies an EVT1 cyclone in CPURegID <SM9> rb
PSCVIA2SIntEVT1	EQU			$000					; Slot interrupt reg. offset					<SM9> rb
PSCVIA2IFREVT1	EQU			$004					; VIA2 interrupt flag reg. offset				<SM9> rb
PSCVIA2IEREVT1	EQU			$008					; VIA2 interrupt enable reg. offset				<SM9> rb

PSCVIA2SInt		EQU			$1E00					; Slot interrupt reg. offset					<SM7> rb
PSCVIA2IFR		EQU			$1A00					; VIA2 interrupt flag reg. offset				<SM7> rb
PSCVIA2IER		EQU			$1C00					; VIA2 interrupt enable reg. offset				<SM7> rb


; PSC VIA2 Slot Interrupt Register equates
PSCSlotC		EQU			3						; slot C int.
PSCSlotD		EQU			4						; slot D int.
PSCSlotE		EQU			5						; slot E int.
PSCOVBVBL		EQU			6						; on-board video vbl int.

; PSC VIA2 Interrupt Flag and Interrupt Enable Registers equates
PSCSCSI0		EQU			0						; SCSI int., same as bit 3
PSCSlot			EQU			1						; any slot int.
PSCMUNI			EQU			2						; MUNI int.
PSCSCSI3		EQU			3						; SCSI int.
PSCFDC			EQU			5						; floppy int.
PSCSNDFRM		EQU			6						; sound frame int.
PSCANY			EQU			7						; any of the above

													; <SM4> rb, end, <SM5> rb


;----------
;RBV (Ram Based Video) register definitions
;----------

RvDataB			EQU			$000					; VIA2 data reg. B equivalent	<v1.4><2.5>
RvExp			EQU			$001					; RBV Expansion Register		<3>
RvSInt			EQU			$002					; Slot interrupts reg.			<v1.4><2.5>
RvIFR			EQU			$003					; interrupt flag reg.			<v1.4><2.5>
RvMonP			EQU			$010					; monitor parameters reg.		<v1.4><2.5>
RvChpT			EQU			$011					; chip test reg.				<v1.4><2.5>
RvSEnb			EQU			$012					; Slot interrupt enable reg.	<v1.4><2.5>
RvIER			EQU			$013					; interrupt flag enable reg.	<v1.4><2.5>

;----------
;Common Via 2 and RBV (Ram Based Video) register offsets
;----------


Rv2DataB		EQU			vBufB++RvDataB			; RBV/VIA2 data reg. B equivalent	<H8>
Rv2Exp			EQU			RvExp					; RBV Expansion Register			<H8>
Rv2SInt			EQU			RvSInt					; Slot interrupts reg.				<H8>
Rv2IFR			EQU			vIFR++RvIFR				; RBV/VIA2 interrupt flag reg.		<H8>
Rv2MonP			EQU			RvMonP					; monitor parameters reg.			<H8>
Rv2ChpT			EQU			RvChpT					; chip test reg.					<H8>
Rv2SEnb			EQU			RvSEnb					; Slot interrupt enable reg.		<H8>
Rv2IER			EQU			vIER++RvIER				; iRBV/VIA2 interrupt enable reg.	<H8>


;  ======  VIA2 BufferB Equivalent   Address: $50026000	 =====									<v1.4>
RvCDis			EQU 		0 						; cache disable (when 1)					<v1.4><3.3>
RvBusLk   		EQU 		1 						; Bus lockout								<v1.4>
RvPowerOff		EQU 		2 						; soft power off signal (when 0)			<v1.4>
RvCFlush		EQU 		3 						; Flush external cache (when 0)				<v1.4>
RvTM1A			EQU 		4 						; bit for NUBus								<v1.4>
RvTM0A			EQU 		5 						; and another								<v1.4>
RvSndExt  		EQU 		6 						; 1 = internal speaker, 0 = ext. audio		<v1.4>
													; jack in use								<v1.4>
RvPGCTest		EQU			7						; 1 = generate good parity, 0 = generate errors

;  ======  Future Expansion   Address: $50026001	 =====										<v1.4>

;  ======  Slot Interrupts   Address: $50026002	 =====											<v1.4>
RvIRQ1			EQU 		0 						; slot 1 interrupt							<v1.4>
RvIRQ2			EQU 		1 						; slot 2 interrupt							<v1.4>
RvIRQ3			EQU 		2 						; slot 3 interrupt							<v1.4>
RvIRQ4			EQU 		3 						; slot 4 interrupt							<v1.4>
RvIRQ5			EQU 		4 						; slot 5 interrupt							<v1.4>
RvIRQ6			EQU 		5 						; slot 6 interrupt							<v1.4>
RvIRQ0			EQU 		6 						; slot 0 interrupt or internal video 		<v1.4>
													; blanking interrupt						<v1.4>
;RvResr			EQU 		7 						; reserved 									<v1.4>

;  ======  Interrupt Flags   Address: $50026003	 =====											<v1.4>
RvSCSIDRQ		EQU			0						; 1 = SCSI DRQ interrupt					<v1.4>
RvAnySlot		EQU			1						; 1 = any slot(0-6).IRQ int					<v1.4>
RvExpIRQ		EQU			2						; 1 = expansion int. (reserved)				<v1.4>
RvSCSIRQ		EQU			3						; 1 = SCSI IRQ interrupt					<v1.4>
RvSndIRQ		EQU			4						; 1 = Apple Sound Chip interrup				<v1.4>
;RvResr			EQU 		5 						; reserved 									<v1.4>
;RvResr			EQU 		6 						; reserved									<v1.4>
;RvSetClr		EQU			7						; on READ, 1 = any enable interrupt			<v1.4>
													; on WRITE, 1 = 1-bits in bits 0-6 write 1's<v1.4>
													;  			0 = 1-bits in bits 0-6 write 0's<v1.4>

;  ======  Monitor Parameters   Address: $50026010	 =====										<v1.4>
RvColor1		EQU			0						; (lsb) R/W 000 = 1bit, 001 = 2 bit			<v1.4>
RvColor2		EQU			1						; 		R/W 010 = 4bit, 011 = 8 bit			<v1.4>
RvColor3		EQU			2						; (msb) Read 1xx = Reserved					<v1.4>
RvMonID1		EQU			3						; READ 000,011,100=reserved; x01=15" monitor<v1.4>
RvMonID2		EQU			4						; 010=Mod'IIGSmonitor;110=MacII monitors	<v1.4>
RvMonID3		EQU 		5 						; 111= 9" build in monitor					<v1.4>
RvVIDOff		EQU 		6 						; 1 = Video off								<v1.4>
RvVID3St		EQU			7						; 1 = all video outputs tri-stated			<v1.4>

;  ======  Chip Test   Address: $50026011	 =====												<v1.4>
RvC60			EQU			0						; 1 = C60 clock run 128 x normal			<v1.4>
RvSpd1			EQU			1						; (lsb) 00 = normal, 01=medium				<v1.4>
RvSpd2			EQU			2						; (msb) 10 = fast, 11 = very fast			<v1.4>
RvHndShk3		EQU			3						; 1=VID.REQ & VID.RES tri-stated			<v1.4>
RvIOClk3		EQU			4						; 1=C16M, C8M, C3.7M tri-stated				<v1.4>
RvC30M			EQU 		5 						; 1=30.24 mHz clock for all monitors		<v1.4>
RvSDTClk		EQU 		6 						; 1 = Dot clock halted						<v1.4>
RvTstRes		EQU			7						; 1 = reset video counters					<v1.4>

;  ======  Slot Interrupts Enable   Address: $50026012	 =====									<v1.4>
RvIRQ1En		EQU 		0 						; slot 1 interrupt enabled					<v1.4>
RvIRQ2En		EQU 		1 						; slot 2 interrupt enabled					<v1.4>
RvIRQ3En		EQU 		2 						; slot 3 interrupt enabled					<v1.4>
RvIRQ4En		EQU 		3 						; slot 4 interrupt enabled					<v1.4>
RvIRQ5En		EQU 		4 						; slot 5 interrupt enabled					<v1.4>
RvIRQ6En		EQU 		5 						; slot 6 interrupt enabled					<v1.4>
RvIRQ0En		EQU 		6 						; slot 0 interrupt or internal video enabled<v1.4>
;RvSetClr		EQU			7						; on READs, always reads 0					<v1.4>
													; on WRITEs, 1 = 1-bits in bits 0-6 write 1's<v1.4>
													;  			0 = 1-bits in bits 0-6 write 0's<v1.4>

;  ======  Interrupt Flags Enable   Address: $50026013	 =====
RvSCSIDRQEn		EQU			0						; 1 = SCSI DRQ interrupt enabled			<v1.4>
RvAnySlotEn		EQU			1						; 1 = any slot(0-6).IRQ int. enabled		<v1.4>
RvExpIRQEn		EQU			2						; 1 = expansion int. (reserved) enabled		<v1.4>
RvSCSIRQEn		EQU			3						; 1 = SCSI IRQ interrupt enabled			<v1.4>
RvSndIRQEn		EQU			4						; 1 = Apple Sound Chip interrupt enabled	<v1.4>
;RvResr			EQU 		5 						; reserved 									<v1.4>
;RvResr			EQU 		6 						; reserved									<v1.4>
;RvSetClr		EQU			7						; on READs, always reads 1					<v1.4>
													; on WRITEs, 1 = 1-bits in bits 0-6 write 1's<v1.4>
													;  			0 = 1-bits in bits 0-6 write 0's<v1.4>

;----------
; VDAC register definitions
;----------

vDACwAddReg		EQU			$0000					;   offset from vDACBase for write address reg
vDACrAddReg		EQU			$000C					;   offset from vDACBase for read address register <v4.2>
vDACwDataReg	EQU			$0004					;   offset from vDACBase for write data reg

vDACPixRdMask	EQU			$0008					;   offset from vDACBase for pixel mask


;__________________________________________________________________________________________
;
;
; VISA Pin Definitions and Register Offsets - Multiple names for the same pin are grouped
; together.  New definitions for VISA pins are added such that the grouping is maintained.
;
;
;__________________________________________________________________________________________


;----------
; VISA register definitions - generally, these equates are a precise subset
;		of the RBV equates.
;----------

; these registers are accessed off of VIA1 lomem
VsData1A		EQU		  	$1E00					; VIA1 data reg A
VsData1B		EQU			$0000					; VIA1 data reg B

; these registers are accessed off of VISA lomem
VsData2B		EQU			$000					; VIA2 data reg B equivalent
VsExp			EQU			$001					; VISA Expansion Register
VsSInt			EQU			$002					; Slot Interrupt Register
VsIFR			EQU			$003					; Interrupt Flag Register
VsMonP			EQU			$010					; Monitor Parameters Register
VsSEnb			EQU			$012					; Slot Interrupt Enable Register
VsIER			EQU			$013					; Interrupt Flag Enable Register

;  ======  VIA2 BufferB Equivalent   Address: $50026000	 =====
;*VsResr		EQU			0						; reserved
;*VsResr		EQU			1						; reserved
;*VsResr		EQU			2						; reserved
VsFC3			EQU			3						; select 32-bit map.  0=24 bit, 1=32 bit
;*VsResr		EQU			4						; reserved
;*VsResr		EQU			5						; reserved
VsSndExt		EQU			6						; Always reads as 1 - play sounds in Mono
;*VsResr		EQU			7						; reserved

;  ======  Future Expansion   Address: $50026001	 =====
VsA2Mode		EQU			0						; 0=512*384 mode, 1=560*384 mode
VsVResEn		EQU			1						; 1=enable vertical counter reset for video genlock
VsFlWrEn	 	EQU			2						; 1=enable writes to flash EEPROM
Vs1BV			EQU			3						; 1=low base for 1-bit mode, 0=high base
VsPg2			EQU			4						; 1=main video page, 0=sec video page
;*VsResr		EQU			5						; reserved
VsSiz0			EQU			6						; RAM size control bit 00=1MB, 01=1.5MB
VsSiz1			EQU			7						; 	10=3MB,11=9MB

;  ======  Slot Interrupts   Address: $50026002	 =====
;*VsResr		EQU			0						; reserved
;*VsResr		EQU			1						; reserved
;*VsResr		EQU			2						; reserved
;*VsResr		EQU			3						; reserved
;*VsResr		EQU			4						; reserved
VsSIRQ			EQU			5						; expansion slot interrupt
VsVBLInt		EQU			6						; slot zero (built-in) VBL interrupt
;*VsResr		EQU			7						; reserved


;  ======  Interrupt Flags   Address: $50026003	 =====
VsSCSIDRQ		EQU			0						; 1 = SCSI DRQ interrup
VsAnySlot		EQU			1						; 1 = any slot(0-6).IRQ int
;*VsResr		EQU			2						; reserved
VsSCSIRQ		EQU			3						; 1 = SCSI IRQ interrupt
VsSndIRQ		EQU			4						; 1 = Apple Sound Chip interrupt
;RvResr			EQU 		5 						; reserved
;RvResr			EQU 		6 						; reserved
RvSetClr		EQU			7						; on READ, 1 = any enabled interrupt
													; on WRITE, 1 = 1-bits in bits 0-6 write 1's
													;  			0 = 1-bits in bits 0-6 write 0's

;  ======  Monitor Parameters   Address: $50026010	 =====
;*VsResr		EQU			0						; (lsb)
VsColor			EQU			1						; (compat w/RBV) R/W 000 = 1bit, R/W 010 = 4bit
;*VsResr		EQU			2						; (msb)
VsMonConn		EQU			3						; (lsb)1=no monitor connected
;*VsResr		EQU			4						; (compat w/RBV)
VsMonSel		EQU 		5 						; (msb) Monitor select 1=Jersey, 0=Rubik
;*VsResr		EQU 		6 						; reserved
;*VsResr		EQU			7						; reserved


;  ======  Slot Interrupts Enable   Address: $50026012	 =====
;*VsResr		EQU			0						; reserved
;*VsResr		EQU			1						; reserved
;*VsResr		EQU			2						; reserved
;*VsResr		EQU			3						; reserved
;*VsResr		EQU			4						; reserved
VsExtIRQEn		EQU 		5 						; expansion slot interrupt enabled
VsIntIRQEn		EQU 		6 						; internal video interrupt enabled
VsSetClr		EQU			7						; on READs, always reads 0
													; on WRITEs, 1 = 1-bits in bits 0-6 write 1's
													;  			0 = 1-bits in bits 0-6 write 0's

;  ======  Interrupt Flags Enable   Address: $50026013	 =====
VsSCSIDRQEn		EQU			0						; 1 = SCSI DRQ interrupt enabled
VsAnySlotEn		EQU			1						; 1 = any slot(0-6).IRQ int. enabled
;*VsResr		EQU			2						; reserved
VsSCSIRQEn		EQU			3						; 1 = SCSI IRQ interrupt enabled
VsSndIRQEn		EQU			4						; 1 = Apple Sound Chip interrupt enabled
;VsResr			EQU 		5 						; reserved
;VsResr			EQU 		6 						; reserved
;RvSetClr		EQU			7						; on READs, always reads 1
													; on WRITEs, 1 = 1-bits in bits 0-6 write 1's
													;  			0 = 1-bits in bits 0-6 write 0's


;----------
; V8 register definitions - generally compatible with the VISA equates above, but a few equates
;	have changed names.
;----------

; these registers are accessed off of the V8 lomem
V8Exp			EQU			$001					; V8 Expansion Register
V8SInt			EQU			$002					; V8 Slot Interrupt Register
V8MonP			EQU			$010					; Monitor Parameters Register
V8SEnb			EQU			$012					; Slot Interrupt Enable Register

;  ======  Future Expansion   Address: $50F26001	 =====
V8A2Mode		EQU			0						; 0=512*384 mode, 1=560*384 mode
V8512Row		EQU			1						; 1=V8 rowbytes is 256, 0=rowbytes is 512
V8vRAMIn	 	EQU			2						; 1=refresh video from vRAM, 0=refresh from dRAM
;*V8Resr		EQU			3						; no 1BV on V8
;*V8Resr		EQU			4						; no VP2 on V8
V8Siz0			EQU			5						; RAM size control bit 0
V8Siz1			EQU			6						; RAM size control bit 1
V8Siz2			EQU			7						; RAM size control bit 2

;  ======  Monitor Parameters   Address: $50F26010	 =====
V8Col0			EQU			0						; Video depth control bit 0
V8Col1			EQU			1						; Video depth control bit 1
V8Col2			EQU			2						; Video depth control bit 2
V8MonID1		EQU			3						; Monitor sense ID bit 1
V8MonID2		EQU			4						; Monitor sense ID bit 2
V8MonID3		EQU			5						; Monitor sense ID bit 3
;*VsResr		EQU 		6 						; reserved
;*VsResr		EQU			7						; reserved

;  ======  Slot Interrupts Enable   Address: $50F26012	 =====
;*V8Resr		EQU			0						; reserved
;*V8Resr		EQU			1						; reserved
;*V8Resr		EQU			2						; reserved
;*V8Resr		EQU			3						; reserved
;*V8Resr		EQU			4						; reserved
V8ExtIRQEn		EQU 		5 						; expansion slot interrupt enabled
V8IntIRQEn		EQU 		6 						; internal video interrupt enabled
;*V8Resr		EQU			7						; reserved


;----------
; Elsie VDAC register definitions
;----------

; VISA/Bt450 registers

VsDACwAddReg	EQU			$0000					;   offset from vDACBase for write address reg
VsDACwDataReg	EQU			$0001					;   offset from vDACBase for write data reg

; V8/Ariel registers

V8DACrAddReg	EQU			$0000					; offset for read address reg
V8DACwAddReg	EQU			$0000					; offset for write address reg
V8DACrDataReg	EQU			$0001					; offset for read data reg
V8DACwDataReg	EQU			$0001					; offset for write data reg
V8DACrCntlReg	EQU			$0002					; offset for read control reg
V8DACwCntlReg	EQU			$0002					; offset for write control reg
V8DACrKeyReg	EQU			$0003					; offset for read key color reg
V8DACwKeyReg	EQU			$0003					; offset for write key color reg

V8vRAMBase		EQU			$50F40000				; base address of V8 VRAM, if present

; End of VISA changes								<4> <cv>


;----------
; DAFB register definitions (offsets from DAFBBase in ProductInfo) ($F980 0000)
;----------

DAFB_BaseOffset		EQU			$0				; DAFB offset from DAFBBase
DAFB_ParmSize		EQU			$5				; size of DAFB programmed subset
DAFB_NumRegs		Equ			(16-4)			; Number of DAFB registers (Color Regs are really vRAM).

DAFB_VidBaseHi		EQU			$0				; DAFB video base address, bits 20:9
DAFB_VidBaseLo		EQU			$4				; DAFB video base address, bits 8:5 (4:0 always zero)
DAFB_RowWords		EQU			$8				; DAFB rowlongs size
DAFB_ClkCfg			EQU			$C				; DAFB clock configuration
DAFB_Config			EQU			$10				; DAFB general configuration
DAFB_BlkWrtEn		EQU			$14				; DAFB block write enable
DAFB_PgMdEn			EQU			$18				; DAFB page mode enable
DAFB_Sense			EQU			$1C				; DAFB sense line
DAFB_Reset			EQU			$20				; DAFB reset control
DAFB_SCSIch0		EQU			$24				; Turbo SCSI channel 0 control (not used)
DAFB_SCSIch1		EQU			$28				; Turbo SCSI channel 1 control (not used)
DAFB_Test			EQU			$2C				; DAFB test control

DAFB_CRB0			EQU			$30				; vRAM Color Register, bank 0
DAFB_CRB1			EQU			$34				; vRAM Color Register, bank 1
DAFB_CRB2			EQU			$38				; vRAM Color Register, bank 2
DAFB_CRB3			EQU			$3C				; vRAM Color Register, bank 3

;----------
; Swatch (in DAFB) register definitions (offsets from DAFBBase in ProductInfo)
;----------

Swatch_BaseOffset	EQU			$100			; Swatch offset from DAFBBase
Swatch_BaseOffset1	EQU			$124			; parameter offset
Swatch_ParmSize1	EQU			$12				; size of Swatch parameter list
; ••• This number is off by 2, we think.  BG/NJV
; Swatch_NumRegs		Equ			30				; Number of Swatch registers.
Swatch_NumRegs		Equ			28				; Number of Swatch registers.

Swatch_Mode			EQU			$100			; Swatch general control
Swatch_IntMsk		EQU			$104			; Swatch interrupt control
Swatch_IntStat		EQU			$108			; Swatch interrupt status
Swatch_ClrCrsrInt	EQU			$10C			; Swatch clear cursor interrupt (not used in this form)
Swatch_ClrAnimInt	EQU			$110			; Swatch clear animation interrupt (not used in this form)
Swatch_ClrVBLInt	EQU			$114			; Swatch clear VBL interrupt (not used in this form)
Swatch_CrsrLine		EQU			$118			; Swatch cursor interrupt trigger line
Swatch_AnimLine		EQU			$11C			; Swatch animation interrupt trigger line
Swatch_Test			EQU			$120			; Swatch counter test
Swatch_HSyncRegs	EQU			$124			; Swatch horizontal sync registers (set as a group)
Swatch_HSerr		Equ			$124			;   HSerr
Swatch_Hlfln		Equ			$128			;   Hlfln
Swatch_HEq			Equ			$12C			;   HEq
Swatch_HSP			Equ			$130			;   HSP
Swatch_HBWay		Equ			$134			;   HBWay
Swatch_HBrst		Equ			$138			;   HBrst
Swatch_HBP			Equ			$13C			;   HBP
Swatch_HAL			Equ			$140			;   HAL
Swatch_HFP			Equ			$144			;   HFP
Swatch_HPix			Equ			$148			;   HPix
Swatch_VSyncRegs	EQU			$14C			; Swatch vertical sync registers (set as a group)
Swatch_VHLine		Equ			$14C			;	VHLine
Swatch_VSync		Equ			$150			;	VSync
Swatch_VBPEq		Equ			$154			;	VBPEq
Swatch_VBP			Equ			$158			;	VBP
Swatch_VAL			Equ			$15C			;	VAL
Swatch_VFP			Equ			$160			;	VFP
Swatch_VFPEq		Equ			$164			;	VFPEq
Swatch_TimeAdj		EQU			$168			; Swatch miscellaneous timing adjust
Swatch_ActLine		EQU			$16C			; Swatch active video line (read-only)

;----------
; ACDC register definitions (offsets from DAFBBase in ProductInfo, also in vDACBase)
;----------

ACDC_AddrReg		EQU			$200			; set position in ACDC internal RAM
ACDC_DataReg		EQU			$210			; read/write data in ACDC internal RAM
ACDC_ConfigReg		EQU			$220			; ACDC offset from DAFBBase
ACDC_ParmSize		EQU			$1				; size of ACDC parameter list


;----------
; National Clock Chip register definitions (offsets from DAFBBase in ProductInfo)
;----------

Clk_BaseOffset		EQU			$300			; National offset from DAFBBase
Clk_ChipIntOffset	EQU			$C0				; Clock Chip Interface offset from National offset from DAFBBase <H33>
Clk_ParmSize		EQU			$10 			; size of National parameter list
Clk_ParmSize1		Equ			$0A				; (Once programmed, the last six bytes are always the same.)

;----------
; Misc. DAFB Parms
;----------
Misc_ParmSize		Equ			$4				; Just for consistency with other DAFB parms.


;----------
; GSC register definitions (offsets from VDACAddr in ProductInfo) ($50F2 0000)					<H5> jmp
;----------
GSCDeviceID			Equ		$00						; Device revision register; read only.
GSCPanelID			Equ		$01						; “Senseline” read/write register.
GSCPanelControl		Equ		$02						; Switches r/w sense of PanelID reg.
GSCPanelSetup		Equ		$03						; Panel intialization register.
GSCGrayScale		Equ		$04						; The depth-switching register.
GSCPolyAdj			Equ		$05						; Allows for grayscale adjustment.
GSCPanelAdj			Equ		$06						; Allows for panel adjustment.
GSCACDClk			Equ		$07						; Who knows?
GSCRefreshRate		Equ		$08						; Refresh cycles per scanline.
GSCBlankShade		Equ		$09						; Shade of gray for depth switches.
GSCPanelSkew		Equ		$0A						; Who knows?

GSCDiag0			Equ		$1D						; Undocumented “diagnostic” registers.
GSCDiag1			Equ		$1E
GSCDiag2			Equ		$1F

;----------
; CSC register definitions (offsets from VDACAddr in ProductInfo) ($50F2 0000)					<H30> jmp
;----------
CSCDeviceID			Equ		$00						; Device revision register; read only.
CSCPanelID			Equ		$02						; “Senseline” register; read only.
CSCPanelIDControl	Equ		$04						; Extended senseline control.
CSCPanelType		Equ		$06						; Controls mono/color, size, etc….
CSCPanelSetup		Equ		$08						; Controls polarity, power, etc….
CSCDataOutputForm	Equ		$0A						; Controls datapath output type.
CSCFRCControl		Equ		$0C						; “DAC” control from CLUT for panel.
CSCPolyMAdj			Equ		$0E						; M adjustment for FRC.
CSCPolyNAdj			Equ		$10						; N adjustment for FRC.
CSCDisplayDataForm	Equ		$12						; 1,2,4,8,16 bpp.
CSCDisplayStatus	Equ		$14						; IFR,IER,blanking.
CSCRefreshRate		Equ		$16						; Controls refresh cycles per scanline.
CSCVRAMControl		Equ		$18						; Controls VRAM clocking.
CSCHSkewHi			Equ		$1A						; Effectively, controls the horizontal
CSCHSkewLo			Equ		$1C						;	timing.
CSCACDClkHi			Equ		$1E						; Effectively, controls the dot-clock
CSCACDClkLo			Equ		$20						; 	timing.
CSCVSkewHi			Equ		$22						; Effectively, control the vertical
CSCVSkewLo			Equ		$24						; 	timing.
CSCMemConfig		Equ		$26						; Controls addressing for type of VRAM.
CSCLPStart			Equ		$28						; Controls start of timing diagram.
CSCLPWidth			Equ		$2A						; Controls width of timing diagram.
CSCFLMControl		Equ		$2C						; What does this do?

CSCFrstReg			Equ		CSCPanelType			; First CSC register we need to save/restore.
CSCLastReg			Equ		CSCFLMControl+2			; Last  CSC register we need to save/restore.
CSCNumRegs			Equ		((CSCLastReg-CSCFrstReg)/2) ; Total number of registers to save/restore.

CSCGTweak			Equ		$3C						; For “tweaking” the gray-only panels.

CSCAddrRegW			Equ		$40						; Sets the index of the NEXT Palette Write.
CSCAddrRegR			Equ		$46						; Sets the index of the NEXT Palette Read.
CSCDataReg			Equ		$42						; Accessed as an R-G-B tripple into the Palette.

CSCMaskReg			Equ		$44						; Logically masks out video data; set to all $F's.

;----------
; Sonora register definitions (offsets from SonoraAddr in ProductInfo) ($50F0 0000)				<H4><H6>
;----------

SonoraVIA2Base	Equ			$26000					; Base address of VIA2

SonoraVIA2Data	Equ			$00						; VIA2 Data Register
SonoraRAMSize	EQU			$01						; DRAM config
SonoraSlotIFR	Equ			$02						; Slot Interrupt Flags Register
SonoraVIA2IFR	Equ			$03						; VIA2 Interrupt Flags Register
SonoraVRAMSize	Equ			$04						; VRAM config
SonoraSpeedReg	Equ			$05						; System CPU Speed (waitstate) Register
SonoraSlotIER	Equ			$12						; Slot Interrupt Enable Register
SonoraVIA2IER	Equ			$13						; Interrupt Flag Register
SonoraVdCtlBase	Equ			$28000					; Base address of video control registers

SonoraVdModeReg	Equ			$00						; Monitor code and video blanking register
SonoraVdColrReg Equ			$01						; Framebuffer pixel depth control register
SonoraVdSenseRg	Equ			$02						; Senseline register

; Bits for Misc Sonora Regs
;
SonoraSetClr	Equ			7						; on WRITEs, 1 = 1-bits in bits 0-6 write 1's
													;  			 0 = 1-bits in bits 0-6 write 0's

; Bits for SonoraSlotIER
;
SonoraVBLIRQEn	Equ			6						; Enable/Disable built-in video VBL

;----------
; Additional register definitions implemented in the Ardbeg variation of the Sonora chip		<HK4><H31> thru next <H31>
;----------

ArdbegPwr		EQU			$00A					; Ardbeg chip Power Management register

;----------
; Power Management register bit definitions
;----------
ArdbegPwrSaver	EQU 		0						; 1=Monitor power saver mode enabled (monitor power is off) <H31>

;----------
; Ariel register definitions (offsets from VDACAddr in ProductInfo) ($50F2 4000)				<H6>
;----------
ArielAddrReg	Equ			0						; Offset to r/w address register
ArielDataReg	Equ			1						; Offset to r/w data register
ArielConfigReg	Equ			2						; Offset to r/w control register
ArielKeyReg		Equ			3						; Offset to r/w key color register

;----------
; FIFO Memory Definitions for Whitney/Hardrock machines
;----------
FIFOMEM_BASE	Equ			$50F24000				; Logical address assignment for base of FIFO's
FIFO_0_OFFSET	Equ			(16*1024)
FIFO_1_OFFSET	Equ			(32*1024)
FIFO_2_OFFSET	Equ			(48*1024)

;----------
; Whitney register definitions <ged>
;----------

WhitneyPwrCtl	Equ			$50F96000				; Whitney power control register
WhitneyRev		Equ			$50F96004				; Whitney revision register

;----------
; Whitney power register bit definitions 														<K4>
;----------

WhitneySCCclk	equ			7						; 1 = SCC pClk forced low
WhitneyInt3En	equ			6						; 1 = MDM_IRQ_L causes level 3 interrupt
WhitneySWIMclk	equ			5						; 1 = Swim clock forced low
WhitneySWIMReset equ		4						; 0 = reset SWIM chip
WhitneyKEYclk	equ			3						; 1 = KEY_C16 forced low
WhitneySCCpwr	equ			2						; 1 = power off serial driver chip
WhitneyEnetReset equ		1						; 0 = reset SONIC chip
WhitneyEnetPwr	equ			0						; 1 = power off Sonic chip
;----------
; MMC register definitions (offsets from MMCAddr in ProductInfo) ($50F3 0400)				<P2><SM4> rb, start
;----------

MMC_DRAMspeed0	EQU			$00						; DRAM timing register 0 [M0].
MMC_DRAMspeed1	EQU			$04						; DRAM timing register 1 [M1].

MMC_CPUspeed0	EQU			$08						; Clock speed 0 [M2].
MMC_CPUspeed1	EQU			$0C						; Clock speed 1 [M3].

MMC_ROMspeed0	EQU			$10						; ROM cycle time 0 [M4].
MMC_ROMspeed1	EQU			$14						; ROM cycle time 1 [M5].
MMC_ROMspeed2	EQU			$18						; ROM cycle time 2 [M6].

MMC_DSPspeed	EQU			$1C						; DSP clock speed [M7].

MMC_DRAMwidth0	EQU			$20						; DRAM width 0 [M8].
MMC_DRAMwidth1	EQU			$24						; DRAM width 1 [M9].
MMC_DRAMwidth2	EQU			$28						; DRAM width 2 [M10].
MMC_DRAMwidth3	EQU			$2C						; DRAM width 3 [M11].

MMC_EPROMmode	EQU			$30						; EPROM mode [M12].

MMC_DRAMrange2	EQU			$34						; DRAM bank range 0 [M13].
MMC_DRAMrange1	EQU			$38						; DRAM bank range 1 [M14].
MMC_DRAMrange0	EQU			$3C						; DRAM bank range 2 [M15].

MMC_CPUID0		EQU			$40						; CPU ID 0 [M16].
MMC_CPUID1		EQU			$44						; CPU ID 1 [M17].

MMC_ClockSelect	EQU			$48						; Endeavor Input Clock Select (NTSC/PAL) [M18].

MMC_Bypass		EQU			$4C						; RGB or Composite bypass [M19].

;----------
; YMCA register definitions (offsets from YMCAAddr in ProductInfo) ($50F3 0400)			<SM16> fau, start
;----------
YMCABase		EQU			$50F30400				; Used in YMCASizeBank 'cause we ran out of registers.  <SM17>
YMCAMaxSize		EQU			5						; Maximum value that can be programed into the size registers
BankBdryRegSize	EQU			7						; Size in bits of the boundary registers
BankSizeRegSize	EQU			3						; Size in bits of the size register

YMCA_DRAMspeed0	EQU			$00						; DRAM timing register 0 [M0].
YMCA_DRAMspeed1	EQU			$04						; DRAM timing register 1 [M1].

YMCA_CPUspeed0	EQU			$08						; Clock speed 0 [M2].
YMCA_CPUspeed1	EQU			$0C						; Clock speed 1 [M3].

YMCA_ROMspeed0	EQU			$10						; ROM cycle time 0 [M4].
YMCA_ROMspeed1	EQU			$14						; ROM cycle time 1 [M5].
YMCA_ROMspeed2	EQU			$18						; ROM cycle time 2 [M6].

YMCA_DSPspeed	EQU			$1C						; DSP clock speed [M7].

YMCA_DRAMwidth0	EQU			$20						; DRAM width 0 [M8].
YMCA_DRAMwidth1	EQU			$24						; DRAM width 1 [M9].
YMCA_DRAMwidth2	EQU			$28						; DRAM width 2 [M10].
YMCA_DRAMwidth3	EQU			$2C						; DRAM width 3 [M11].

YMCA_EPROMmode	EQU			$30						; EPROM mode [M12].

YMCA_040Mode	EQU			$34						; 040 Special Mode [M13].

YMCA_CPUID0		EQU			$38						; CPU ID 0 [M14].
YMCA_CPUID1		EQU			$3C						; CPU ID 1 [M15].
YMCA_CPUID2		EQU			$40						; CPU ID 2 [M16].
YMCA_CPUID3		EQU			$44						; CPU ID 3 [M17].

YMCA__ClockSelect	EQU		$48						; Endeavor Input Clock Select [M18].
YMCA_Bypass 		EQU		$4C						; Composite out or RGB [M19].

YMCA_DRAMBank0_A20 EQU		$50						; DRAM Bank0 Addr A20 [M20].
YMCA_DRAMBank0_A21 EQU		$54						; DRAM Bank0 Addr A21 [M21].
YMCA_DRAMBank0_A22 EQU		$58						; DRAM Bank0 Addr A22 [M22].
YMCA_DRAMBank0_A23 EQU		$5C						; DRAM Bank0 Addr A23 [M23].
YMCA_DRAMBank0_A24 EQU		$60						; DRAM Bank0 Addr A24 [M24].
YMCA_DRAMBank0_A25 EQU		$64						; DRAM Bank0 Addr A25 [M25].
YMCA_DRAMBank0_A26 EQU		$68						; DRAM Bank0 Addr A26 [M26].
YMCA_DRAMBank0_Sz0 EQU		$6C						; DRAM Bank0 Size 0   [M27].
YMCA_DRAMBank0_Sz1 EQU		$70						; DRAM Bank0 Size 1   [M28].
YMCA_DRAMBank0_Sz2 EQU		$74						; DRAM Bank0 Size 2   [M29].

YMCA_DRAMBank1_A20 EQU		$78						; DRAM Bank1 Addr A20 [M30].
YMCA_DRAMBank1_A21 EQU		$7C						; DRAM Bank1 Addr A21 [M31].
YMCA_DRAMBank1_A22 EQU		$80						; DRAM Bank1 Addr A22 [M32].
YMCA_DRAMBank1_A23 EQU		$84						; DRAM Bank1 Addr A23 [M33].
YMCA_DRAMBank1_A24 EQU		$88						; DRAM Bank1 Addr A24 [M34].
YMCA_DRAMBank1_A25 EQU		$8C						; DRAM Bank1 Addr A25 [M35].
YMCA_DRAMBank1_A26 EQU		$90						; DRAM Bank1 Addr A26 [M36].
YMCA_DRAMBank1_Sz0 EQU		$94						; DRAM Bank1 Size 0   [M37].
YMCA_DRAMBank1_Sz1 EQU		$98						; DRAM Bank1 Size 1   [M38].
YMCA_DRAMBank1_Sz2 EQU		$9C						; DRAM Bank1 Size 2   [M39].

YMCA_DRAMBank2_A20 EQU		$A0						; DRAM Bank2 Addr A20 [M40].
YMCA_DRAMBank2_A21 EQU		$A4						; DRAM Bank2 Addr A21 [M41].
YMCA_DRAMBank2_A22 EQU		$A8						; DRAM Bank2 Addr A22 [M42].
YMCA_DRAMBank2_A23 EQU		$AC						; DRAM Bank2 Addr A23 [M43].
YMCA_DRAMBank2_A24 EQU		$B0						; DRAM Bank2 Addr A24 [M44].
YMCA_DRAMBank2_A25 EQU		$B4						; DRAM Bank2 Addr A25 [M45].
YMCA_DRAMBank2_A26 EQU		$B8						; DRAM Bank2 Addr A26 [M46].
YMCA_DRAMBank2_Sz0 EQU		$BC						; DRAM Bank2 Size 0   [M47].
YMCA_DRAMBank2_Sz1 EQU		$C0						; DRAM Bank2 Size 1   [M48].
YMCA_DRAMBank2_Sz2 EQU		$C4						; DRAM Bank2 Size 2   [M49].

YMCA_DRAMBank3_A20 EQU		$C8						; DRAM Bank3 Addr A20 [M50].
YMCA_DRAMBank3_A21 EQU		$CC						; DRAM Bank3 Addr A21 [M51].
YMCA_DRAMBank3_A22 EQU		$D0						; DRAM Bank3 Addr A22 [M52].
YMCA_DRAMBank3_A23 EQU		$D4						; DRAM Bank3 Addr A23 [M53].
YMCA_DRAMBank3_A24 EQU		$D8						; DRAM Bank3 Addr A24 [M54].
YMCA_DRAMBank3_A25 EQU		$DC						; DRAM Bank3 Addr A25 [M55].
YMCA_DRAMBank3_A26 EQU		$E0						; DRAM Bank3 Addr A26 [M56].
YMCA_DRAMBank3_Sz0 EQU		$E4						; DRAM Bank3 Size 0   [M57].
YMCA_DRAMBank3_Sz1 EQU		$E8						; DRAM Bank3 Size 1   [M58].
YMCA_DRAMBank3_Sz2 EQU		$EC						; DRAM Bank3 Size 2   [M59].

YMCA_DRAMBank4_A20 EQU		$F0						; DRAM Bank4 Addr A20 [M60].
YMCA_DRAMBank4_A21 EQU		$F4						; DRAM Bank4 Addr A21 [M61].
YMCA_DRAMBank4_A22 EQU		$F8						; DRAM Bank4 Addr A22 [M62].
YMCA_DRAMBank4_A23 EQU		$FC						; DRAM Bank4 Addr A23 [M63].
YMCA_DRAMBank4_A24 EQU		$100					; DRAM Bank4 Addr A24 [M64].
YMCA_DRAMBank4_A25 EQU		$104					; DRAM Bank4 Addr A25 [M65].
YMCA_DRAMBank4_A26 EQU		$108					; DRAM Bank4 Addr A26 [M66].
YMCA_DRAMBank4_Sz0 EQU		$10C					; DRAM Bank4 Size 0   [M67].
YMCA_DRAMBank4_Sz1 EQU		$110					; DRAM Bank4 Size 1   [M68].
YMCA_DRAMBank4_Sz2 EQU		$114					; DRAM Bank4 Size 2   [M69].

YMCA_DRAMBank5_A20 EQU		$118					; DRAM Bank5 Addr A20 [M70].
YMCA_DRAMBank5_A21 EQU		$11C					; DRAM Bank5 Addr A21 [M71].
YMCA_DRAMBank5_A22 EQU		$120					; DRAM Bank5 Addr A22 [M72].
YMCA_DRAMBank5_A23 EQU		$124					; DRAM Bank5 Addr A23 [M73].
YMCA_DRAMBank5_A24 EQU		$128					; DRAM Bank5 Addr A24 [M74].
YMCA_DRAMBank5_A25 EQU		$12C					; DRAM Bank5 Addr A25 [M75].
YMCA_DRAMBank5_A26 EQU		$130					; DRAM Bank5 Addr A26 [M76].
YMCA_DRAMBank5_Sz0 EQU		$134					; DRAM Bank5 Size 0   [M77].
YMCA_DRAMBank5_Sz1 EQU		$138					; DRAM Bank5 Size 1   [M78].
YMCA_DRAMBank5_Sz2 EQU		$13C					; DRAM Bank5 Size 2   [M79].

YMCA_DRAMBank6_A20 EQU		$140					; DRAM Bank6 Addr A20 [M80].
YMCA_DRAMBank6_A21 EQU		$144					; DRAM Bank6 Addr A21 [M81].
YMCA_DRAMBank6_A22 EQU		$148					; DRAM Bank6 Addr A22 [M82].
YMCA_DRAMBank6_A23 EQU		$14C					; DRAM Bank6 Addr A23 [M83].
YMCA_DRAMBank6_A24 EQU		$150					; DRAM Bank6 Addr A24 [M84].
YMCA_DRAMBank6_A25 EQU		$154					; DRAM Bank6 Addr A25 [M85].
YMCA_DRAMBank6_A26 EQU		$158					; DRAM Bank6 Addr A26 [M86].
YMCA_DRAMBank6_Sz0 EQU		$15C					; DRAM Bank6 Size 0   [M87].
YMCA_DRAMBank6_Sz1 EQU		$160					; DRAM Bank6 Size 1   [M88].
YMCA_DRAMBank6_Sz2 EQU		$164					; DRAM Bank1 Size 2   [M89].

YMCA_DRAMBank7_A20 EQU		$168					; DRAM Bank7 Addr A20 [M90].
YMCA_DRAMBank7_A21 EQU		$16C					; DRAM Bank7 Addr A21 [M91].
YMCA_DRAMBank7_A22 EQU		$170					; DRAM Bank7 Addr A22 [M92].
YMCA_DRAMBank7_A23 EQU		$174					; DRAM Bank7 Addr A23 [M93].
YMCA_DRAMBank7_A24 EQU		$178					; DRAM Bank7 Addr A24 [M94].
YMCA_DRAMBank7_A25 EQU		$17C					; DRAM Bank7 Addr A25 [M95].
YMCA_DRAMBank7_A26 EQU		$180					; DRAM Bank7 Addr A26 [M96].
YMCA_DRAMBank7_Sz0 EQU		$184					; DRAM Bank7 Size 0   [M97].
YMCA_DRAMBank7_Sz1 EQU		$188					; DRAM Bank7 Size 1   [M98].
YMCA_DRAMBank7_Sz2 EQU		$18C					; DRAM Bank7 Size 2   [M99].

YMCA_Test_Mode 		EQU		$190					; Enable Test Mode    [M100].
YMCA_Refresh_Test   EQU		$194					; Refresh Test Mode   [M101].

;													;											<SM16> fau, end
;----------
; MUNI (NuBus) register definitions																<P6>
;----------

; <SM7> rb, • TEMP for EVT1							;											<SM7> rb

MUNIBaseEVT1	EQU			$50F30800				; Base address of Muni for EVT1				<SM9> rb


MUNIBase		EQU			$50F30000				; Base address of Muni.						<SM7> rb



MUNI_IntCntrl	EQU			$00						; Interrupt control register.
MUNI_IntStatus	EQU			$04						; Interrupt status register.
MUNI_Control	EQU			$08						; System control register.
MUNI_BlkAttmpt	EQU			$0C						; Block attempt register.
MUNI_Status		EQU			$10						; Status register.
MUNI_Test		EQU			$14						; Test control register.

;----------
; Civic register definitions (offsets from CivicAddr in ProductInfo) ($50F3 6000)
;----------

Civic_VBLInt	Equ			$000					; Read-only VBL flag register
Civic_VBLEnb	Equ			$110					; Enables VBL interrupt.
Civic_VBLClr	Equ			$120					; Clear VBL interrupt.

Civic_Enable	Equ			$004					; Enables Civic’s timing generator (Casio).
Civic_Reset		Equ			$10C					; Resets Casio.

Civic_VDCInt	Equ			$008					; Read-only VDC flag register.
Civic_VDCClr	Equ			$00C					; Clears VDC interrupt.
Civic_VDCEnb	Equ			$010					; Enables VDC interrupt.
Civic_VDCClk	Equ			$018					; Enables VDC clock.

Civic_VidInSize	Equ			$014					; Controls video-in Rows (1024 vs. 1536 bytes).

Civic_VidInDble	Equ			$208					; Controls whether Civic Doubles each Video-in Field

Civic_ScanCtl	Equ			$01C					; Controls progressive vs. interlaced scans.

Civic_GSCDivide	Equ			$020					; Controls graphics clock divide count.
Civic_VSCDivide	Equ			$02C					; Controls video-in clock divide count.

Civic_VRAMSize	Equ			$040					; Controls VRAM sizing (1 vs. 2 Mbytes).

Civic_RfrshCtl	Equ			$044					; Controls the refresh mode.

Civic_BusSize	Equ			$04C					; Controls the bus size (32 vs. 64 bits).

Civic_SpeedCtl	Equ			$050					; Controls the timing (25 vs. 33 MHz).

Civic_ConvEnb	Equ			$054					; Enables convolution.

Civic_ReadSense	Equ			$088					; Sense-line registers.
Civic_SenseCtl	Equ			$058					;
Civic_Sense0	Equ			$05C					;
Civic_Sense1	Equ			$060					;
Civic_Sense2	Equ			$064					;
Civic_SenseTst	Equ			$068					;

Civic_SyncClr	Equ			$06C					; Disables RGB (Sync) output.

Civic_BaseAddr	Equ			$0C0					; Base address of active video.
Civic_RowWords	Equ			$094					; Row long words of active video.

Civic_AdjF1		Equ			$128					; Timing adjust registers.
Civic_AdjF2		Equ			$124					;
Civic_Piped		Equ			$440					;

Civic_HSerr		Equ			$180					; Horizontal timing registers.
Civic_HlfLn		Equ			$280					;
Civic_HEq		Equ			$2C0					;
Civic_HSP		Equ			$300					;
Civic_HBWay		Equ			$340					;
Civic_HAL		Equ			$380					;
Civic_HFP		Equ			$3C0					;
Civic_HPix		Equ			$400					;

Civic_VHLine	Equ			$480					; Vertical timing registers.
Civic_VSync		Equ			$4C0					;
Civic_VBPEqu	Equ			$500					;
Civic_VBP		Equ			$540					;
Civic_VAL		Equ			$580					;
Civic_VFP		Equ			$640					;
Civic_VFPEqu	Equ			$680					;
Civic_CurLine	Equ			$6C0					;

Civic_VInHAL	Equ			$1C0					; Video-in timing registers.
Civic_VInHFPD	Equ			$200					;
Civic_VInHFP	Equ			$240					;
Civic_VInVAL	Equ			$5C0					;
Civic_VInVFP	Equ			$600					;

Civic_HLDB		Equ			$114					; Horizontal test/control registers.
Civic_HHLTB		Equ			$118					;
Civic_HActHi	Equ			$11C

Civic_VLDB		Equ			$100					; VSync test/control registers.
Civic_VHLTB		Equ			$104					;
Civic_VActHi	Equ			$108					;

Civic_TestEnb	Equ			$12C					; Enables Casio test mode.
Civic_CntTest	Equ			$140					; Count test register.

;----------
; Sebastian register definitions (offsets from SebastianAddr in ProductInfo) ($50F3 0000)
;----------

SebastAddrReg	Equ			$000					; CLUT/DAC Address register.
SebastDataReg	Equ			$010					; CLUT/DAC Data register.
SebastPCBR		Equ			$020					; CLUT/DAC Pixel Bus Control register.

;----------
; Endeavor register definitions
;----------

Endeavor		Equ			$50F2E000				; Base address of Endeavor in Cyclone.

EndeavorM		Equ			$000					; 8-bit numerator.
EndeavorN		Equ			$010					; 8-bit denominator.
EndeavorClk		Equ			$020					; Clock select (A or B).

;----------
; MSC register definitions (offsets from MSCAddr in ProductInfo) ($50F2 6000)
;----------

MSCSlotIFR		EQU			$02						; slots interrupt flags
MSCVIA2IFR		EQU			$03						; VIA 2 interrupt flags
MSCConfig		EQU			$10						; RAM, clock configuration
MSCSlotIER		EQU			$12						; slots interrupt enables
MSCVIA2IER		EQU			$13						; VIA 2 interrupt enables
MSCClkCntl		EQU			$21						; peripherals clock control
MSCSndCntl		EQU			$22						; sound control
MSCFlashWrEnb	EQU			$23						; flash ROM write enable
MSCPowerCycle	EQU			$50FA0000-$50F26000		; CPU power off control register			<H2>

;  ======  VIA2 BufferB Equivalent		Address: $50F26000	 =====
MSCEnableFPU	EQU			0						; 0 = enable on-board floating point processor	<H29>
;v2PMack		EQU 		1 						; Power manager handshake acknowledge
;v2PMreq		EQU 		2 						; Power manager handshake request
;reserved3		EQU			3						; reserved
;reserved4		EQU			4						; reserved
;reserved5		EQU			5						; reserved
;reserved6		EQU			6						; reserved
;reserved7		EQU			7						; reserved

;  ======  Slot Interrupt Flags			Address: $50F26002	 =====
;reserved0		EQU			0						; reserved
;reserved1		EQU			1						; reserved
;reserved2		EQU			2						; reserved
;reserved3		EQU			3						; reserved
;reserved4		EQU			4						; reserved
;RvIRQE			EQU 		5 						; slot E interrupt
;RvIRQLCD		EQU			6						; LCD display VBL interrupt
;reserved7		EQU			7						; reserved

;  ======  VIA 2 Interrupt Flags		Address: $50F26003	 =====
;RvSCSIDRQ		EQU			0						; 1 = SCSI DRQ interrupt
;RvAnySlot		EQU			1						; 1 = any slot(0-6).IRQ int
;reserved2		EQU			2						; reserved
;RvSCSIRQ		EQU			3						; 1 = SCSI IRQ interrupt
;RvSndIRQ		EQU			4						; 1 = Apple Sound Chip interrup
;reserved5		EQU			5						; reserved
;reserved6		EQU			6						; reserved
;RvSetClr		EQU			7						; on READ, 1 = any enable interrupt

;  ======  MSC Configuration			Address: $50F26010	 =====
MSC25MHz		EQU			0						; 1 = 25MHz system, 0 = 33MHz system
MSCEconoBit		EQU			1						; 1 = econo-mode enabled (switches to 16MHz)
MSCFastROM		EQU			2						; 1 = 100ns ROMs installed, 0 = 120ns ROMs installed
;reserved3		EQU			3						; reserved
MSCBank8M		EQU			4						; 1 = banks 4-7 are 8MB, 0=banks 4-7 are 2MB
MSCSize0		EQU			5						; RAM size bit
MSCSize1		EQU			6						; RAM size bit
MSCSize2		EQU			7						; RAM size bit

;  ======  Slot Interrupt Enables		Address: $50F26012	 =====
;reserved0		EQU			0						; reserved
;reserved1		EQU			1						; reserved
;reserved2		EQU			2						; reserved
;reserved3		EQU			3						; reserved
;reserved4		EQU			4						; reserved
;RvIRQEEn		EQU 		5 						; slot E interrupt enabled
;RvIRQLCDEn		EQU			6						; LCD display VBL interrupt enabled
;RvSetClr		EQU			7						; on READs, always reads 0

;  ======  VIA 2 Interrupt Enables		Address: $50F26013	 =====
;RvSCSIDRQEn	EQU			0						; 1 = SCSI DRQ interrupt enabled
;RvAnySlotEn	EQU			1						; 1 = any slot(0-6).IRQ int. enabled
;reserved2		EQU			2						; reserved
;RvSCSIRQEn		EQU			3						; 1 = SCSI IRQ interrupt enabled
;RvSndIRQEn		EQU			4						; 1 = Apple Sound Chip interrupt enabled
;reserved5		EQU			5						; reserved
;reserved6		EQU			6						; reserved
;RvSetClr		EQU			7						; on READs, always reads 0
													; on WRITEs, 1 = 1-bits in bits 0-6 write 1's
													;  			0 = 1-bits in bits 0-6 write 0's

;  ======  Peripherals Clock Control	Address: $50F26021	 =====
MSCIOClk		EQU			0						; 1=15.6672MHz I/O clock running, 0=stopped
MSCSCCClk		EQU			1						; 1=3.672MHz SCC clock running, 0=stopped
MSCSCSIReset	EQU			2						; 1=SCSI reset not asserted, 0=reset asserted (clocks stop)
MSCLCDReset		EQU			3						; 1=LCD reset not asserted, 0=reset asserted (clocks stop)
;reserved4		EQU			4						; reserved
;reserved5		EQU			5						; reserved
;reserved6		EQU			6						; reserved
;reserved7		EQU			7						; reserved

;  ======  Sound Control				Address: $50F26022	 =====
MSCSndPower		EQU			0						; 1=DFAC power on, 0=DFAC power off
;reserved1		EQU			1						; reserved
;reserved2		EQU			2						; reserved
;reserved3		EQU			3						; reserved
;reserved4		EQU			4						; reserved
;reserved5		EQU			5						; reserved
MSCSndBusy		EQU			6						; 1=access to FIFO since last access to this register
MSCSndLatch		EQU			7						; 1=DFAC is powered up and initialized


MSCDefConfig	EQU			(1<<MSC25MHz)|\			; 25MHz system								<H9>
							(0<<MSCEconoBit)|\		; econo-mode disabled						<H9>
							(0<<MSCFastROM)|\		; 120ns ROMs installed						<H9>
							(0<<MSCBank8M)|\		; assume 2MB each in banks 4-7				<H19>
							(%000<<MSCSize0)		; set 2MB so there's real RAM for BootBeep	<H10>


BIOSAddr		EQU			$50F18000				; verified by hasBIOSAddr in ExtValid		<H26><SM18>

BIOS_Config		EQU			0						; contains bit 0:  0 = BCLK ≥ 33MHz			<H26>
													;                  1 = BCLK ≤ 25MHz			<H26>
BIOS_SONIC_SCSI	EQU			$200					; contains SONIC and SCSI parameters		<H26>
BIOSSCSIFilter	EQU			$40						; bit 6 = SONIC stuff, all the rest are SCSI<H31>
													; (bit 7 in BIOS is undefined)				<H31>
BIOScfg20MHz	EQU			$1B						; 3-clk PDMA Write and Read 				<H27><SM18>
BIOScfg25MHz	EQU			$3F						; 3-clk PDMA Write and Read/DRQCHK on		<H27><SM18>
BIOScfg33MHz	EQU			$12						; 4-clk PDMA Write and Read 				<H27><SM18>
BIOScfg40MHz	EQU			$00						; 5-clk PDMA Write and Read					<H27><SM18>

BIOS_REVISION	EQU			$300					; bits 5:7 is BIOS revision number			<H26>
bBIOSW1Cmplt	EQU			$2						; bit positions...			 				<H27>
bBIOSR1Cmplt	EQU			$1						;					 						<H27>
bBIOSSCSIBERR	EQU			$0						;						 					<H27>

BIOS_PDMA		EQU			$300					; bits 0:2 are Pseudo-DMA control bits		<H26>
BIOS_SCSI_RESID	EQU			$400					; bits 0:16 are latched SCSI data			<H26>
BIOS_BRIGHTNESS	EQU			$500					; 8 bits of 0-$FF brightness				<H31>
BIOS_CONTRAST	EQU			$501					; 8 bits of 0-$FF contrast					<H31>
BIOS_Timeout	EQU			$600					; bits 0:11 are watchdog timer timeout cntr	<H26>

BIOS_Config2	EQU			$100					; for Primus/Optimus bios					<H35>
bBIOSBR30116BIT	EQU			$0						; bit positions...							<H35>
bBIOSIOCSTime	EQU			$1						;											<H35>
bBIOSENETIRQLVL	EQU			$2						;											<H35>

;__________________________________________________________________________________________		<SM23> SAM
;	AMIC (Apple Memory mapped I/O Controller) Creative name huh? Equates
;	First used on PDM/Cold Fusion
;__________________________________________________________________________________________

AMICBase		EQU			$50F30000				; AMIC base
AMICDMABase		EQU			$50F31000				; DMA Buffer Base Address (256k alignment)
AMICSCSIDMABase	EQU			$0000					; SCSI DMA Buffer Base Address [scsi has its own buffer] (8 byte alignment)

AMICSCSICntrl	EQU			$1008					; SCSI DMA control register

AMICEnetTxCntrl	EQU			$0C20					; Ethernet transmit DMA control register
AMICEnetRxCntrl	EQU			$1028					; Ethernet receive DMA control register

AMICFloppyCntrl	EQU			$1068					; Floppy DMA control register

AMICSCCTxACntrl	EQU			$1088					; SCC port A transmit DMA control register
AMICSCCRxACntrl	EQU			$1098					; SCC port A receive DMA control register

AMICSCCTxBCntrl	EQU			$10A8					; SCC port B transmit DMA control register
AMICSCCRxBCntrl	EQU			$10B8					; SCC port B receive DMA control register

AMICIrqBase		EQU			$50F2A000				; AMIC's interrupt register base
AMICIrqFlags	EQU			$0000					; Interrupt source register
AMICDMAFlags0	EQU			$0008					; DMA interrupt source register
AMICDMAFlags1	EQU			$000A					; DMA interrupt source register

PDMrbvSize 		EQU			768*1024				; 768k for RBV							<SM24>
PDMDMAbufSize	EQU			160*1024				; 160k for the DMA buffer
PDMDMAlogAddr	EQU			$61000000				; Logical address of the DMA buffer

;__________________________________________________________________________________________
;	BART (PDM/Cold Fusion NuBus Controller) Equates
;	First used on PDM/Cold Fusion
;__________________________________________________________________________________________
BARTBase		EQU			$F0000000				; BART Register Base

BARTResetReg	EQU			$F0000000				; bit zero of this register will reset NuBus
BARTResetBit	EQU			$0

BARTSlowReg		EQU			$F0000001				; Setting bit 8 will add wait states
BARTSlowBit		EQU			$8

BARTOffSltE		EQU			$F0000011				; Setting bit 8 will cause slot E to be disabled (for Cold Fusion)
BARTOFFBit		EQU			$8

BARTBurstReg	EQU			$80						; Offset from base to slot zero burst reg (not actually used directly)
BARTBurstRegOff	EQU			$08						; Offset from Busrt Reg to next slot Reg ($80, $78, $70, $68 ... $10)
BARTBurstBit	EQU			$8


;__________________________________________________________________________________________
;
;
; Memory Controllers - Register Definitions and Misc Equates for Memory Controllers.  Included
; are: FMC, ORWELL, JAWS, Niagra, Ponti, djMEMC, Pratt
;
;
;__________________________________________________________________________________________


;---------------------------------------------------
;  FMC (Fitch Memory Controller) Equates
;---------------------------------------------------

FMCConfig		equ			$0						; offset to configuration register.  It is a 16
													; bit wide register with a 1 bit wide data port
													; on d24, so do byte writes (and rotates) and
													; let dynamic bus sizing replicate it on d24-31.

FMCLatch		equ			$10						; offset to 'latch config data' register (latches
													; on a write to here)
FMCInit			EQU			$F3EF					; config reg initial value				<4.5><4.6><4.9><1>
FMCRPUInit		EQU			$F3FF					; config reg initial value (parity)		<1>


;---------------------------------------------------
;  Orwell Memory Controller Equates	<5>
;---------------------------------------------------

;	Orwell only has one input/output data bit.  So to store or retrieve any configuration register
;	information, you must read/write a succession of long-word addresses, starting at the addresses
;	below, with the ONLY valid data bit being {reg}:0.  Valued being read must be assembled one bit
;	at a time; values being written must be loaded into the config registers 1 bit at a time.  The
;	new config. register values do not become active until a "latch" register address associated
;	with the config. register is written.
;
;	The below addresses correspond to longword addresses where bit 0 of whatever data register used to
;	read/write the location will be stored.  The Orwell configuration register is a 34-bit register,
;	with each bit written to/read by addressing the appropriate longword offset.
;
;	The configuration register can be thought of like this:
;
;		+---------------------------------------------------------------------------------------------+
;		| PAR_ODD | PAR_ENB | REFRESH | ROM_SPEED | DRAM_SPEED | CLK_SPEED | BANK_D | BANK_C | BANK_B |
;		+---------------------------------------------------------------------------------------------+
;			28        27     26     24 23       21  20       19     18      17   12  11    6  5      0
;
;																												<T6>
;		+---------------------------------------------------------------------+									<T6>
;		|    RAS    | Optional WRITE | Optional Read  | Optional Read  | Page |									<T6>
;		| Precharge |   wait state   | 2nd wait state | 1st wait state | Mode |									<T6>
;		+---------------------------------------------------------------------+									<T6>
;			 33            32                31               30          29									<T6>

;			***		Register Offsets	***

OrCfgRegAddr		EQU			0						; starting offset of config reg. bits
OrCfgRegSize		EQU			34						; number of bits in the configuration register				<T6>

OrBankFieldSize		EQU			6						; each bank config. reg. field is 6 bits wide
OrBankBCfgAddr		EQU			OrCfgRegAddr			; starting offset of BankB(5:0)
OrBankCCfgAddr		EQU			OrBankBCfgAddr+(4*OrBankFieldSize); starting offset of BankC(5:0)
OrBankDCfgAddr		EQU			OrBankCCfgAddr+(4*OrBankFieldSize); starting offset of BankD(5:0)
OrClkSpeedAddr		EQU			OrBankDCfgAddr+(4*OrBankFieldSize); starting address of Clock_Speed
														; ... Clock_Speed is 1 bit (0=25MHz)
OrDRAMSpeedAddr		EQU			OrClkSpeedAddr+4		; starting address of DRAM Speed(1:0)
OrDRAMFieldSize		EQU			2						; DRAM speed config reg. field is 2 bits wide
OrROMSpeedAddr		EQU			OrDRAMSpeedAddr+(4*OrDRAMFieldSize); starting address of ROM Speed(2:0)
OrROMFieldSize		EQU			3						; ROM speed config reg. field is 3 bits wide
OrRefreshAddr		EQU			OrROMSpeedAddr+(4*OrROMFieldSize); starting address of Refresh Rate(2:0)
OrRefreshSize		EQU			3						; Refresh speed config reg. field is 3 bits wide
OrParityEnbAddr		EQU			OrRefreshAddr+(4*OrRefreshSize); starting address of parity enable/disable
														; ... Parity_Enable is 1 bit (0=parity OFF)
OrParityTypAddr		EQU			OrParityEnbAddr+4		; starting address of parity type (even/odd)
														; ... Parity_Type is 1 bit (0=parity EVEN)
OrPageMode			EQU			OrParityTypAddr+4		;															<T6>
OrWaitRead1			EQU			OrPageMode+4			;															<T6>
OrWaitRead2			EQU			OrWaitRead1+4			;															<T6>
OrWaitWrite1		EQU			OrWaitRead2+4			;															<T6>
OrRASPrecharge		EQU			OrWaitWrite1+4			;															<T6>

OrLatchOffset		EQU			$A0						; offset from start of config reg. where latches live		<T6>
OrwellLatches		EQU			OrCfgRegAddr+OrLatchOffset; starting address of Latch Addresses						<T6>

OrLoadBanks			EQU			OrwellLatches			; Load Bank Config Reg. Latch address						<T6>
OrLoadSpeeds		EQU			OrLoadBanks+4			; Load Clock, DRAM and ROM Speeds Latch address
OrLoadRefresh		EQU			OrLoadSpeeds+4			; Load Refresh interval Latch address
OrLoadParity		EQU			OrLoadRefresh+4			; Load Parity enable/disable and type Latch address

OrLoadMode			EQU			OrLoadParity+4			; Load Page Mode On/Off address								<T6>
OrLoadWaitStates	EQU			OrLoadMode+4			; Load Read/Write extra waitstates address					<T6>
OrLoadPrecharge		EQU			OrLoadWaitStates+4		; Load RAS precharge address								<T6>

OrParityStatus		EQU			$100					; A0-BC = LS 8 bits, C0-DC   = LM 8 bits					<T6>
														; E0-FC = HM 8 bits, 100-11C = MS 8 bits
OrParErrInByte0		EQU			$180					; =1 if parity error occurred in byte 0
OrParErrInByte1		EQU			$184					; =1 if parity error occurred in byte 1
OrParityError		EQU			$188					; =1 if parity error occurred (period)

;			***		Initializing Values at Bootup Time		***

ORINITBankB			EQU			$10						; 10=Bank B at 64MB
ORINITBankC			EQU			$20						; 20=Bank C at 128MB
ORINITBankD			EQU			$30						; 30=Bank D at 192MB

ORINITClock25		EQU			1						; 1=25MHz, 0=33MHz											<T12>
ORINITClock33		EQU			0						;															<T12>
ORINITDRAMSpeed		EQU			1						; 0=100ns, 1=80ns, 2=60ns							<10>
ORINITROMSpeed25	EQU			2						; *n* = Clock_Access-3 (0 = 3 Clock_Access)					<T6><T12>
ORINITROMSpeed33	EQU			4						; *n* = Clock_Access-3 (0 = 3 Clock_Access)					<T6><T12>
ORINITREFRESH25		EQU			2						; 0=25MHz 7.8µsec,  1=33MHz, 7.8µsec				<21>	<T12>
														; 2=25MHz 15.6µsec, 3=33MHz 15.6µsec				<21>	<T12>
ORINITREFRESH33		EQU			3						;													<21>	<T12>
ORINITParity		EQU			0						; 0=parity OFF, 1=parity ON
ORINITParType		EQU			1						; 0=even, 1=odd

;	Additional (programmable) wait states for reads and writes

ORINITPageMode		EQU			0						; 0=off, 1=on												<T6>
ORINITWaitRd1		EQU			0						; 0=off, 1=on (unless Rd2 = 1, in which case it is interpreted as off)<T6>
ORINITWaitRd2		EQU			0						; 0=off, 1=on (unless Rd1 = 1, in which case it is interpreted as off)<T6>
ORINITWaitWr1		EQU			0						; 0=off, 1=on												<T6>
ORINITRAS25			EQU			0						; 0=2 cycles, 1=3 cycles 									<T6>
ORINITRAS33			EQU			1						;															<T12>

;	These are 32-bit constants that hold all but 2 bits of the initial defaults we									  .
;	would want to jam into the Orwell configuration register.  These are arranged									  .
;	in order the register is memory-mapped to facilitate the code that sticks them									  .
;	in the register.  There are two bits that don't fit in a 32-bit constant, the									  .
;	optional -OrWaitWrite1- and the not-so-optional -OrRASPrecharge-.  Those values									  .
;	are used and initialized separately.																			  .

ORWELL_INIT25		EQU			\						;															<T6><T12>
								(ORINITWaitRd2<<31)|\	; initial value - are TWO read-related wait states needed? (0=no)<T6>
								(ORINITWaitRd1<<30)|\	; initial value - is  ONE read-related wait state needed? (0=no)<T6>
								(ORINITPageMode<<29)|\	; initial page mode value (OFF)								<T6>
								(ORINITParType<<28)|\	; initial parity even/odd value
								(ORINITParity<<27)|\	; initial parity on/off value
								(ORINITREFRESH25<<24)|\	; initial refresh rate value								<T12>
								(ORINITROMSpeed25<<21)|\; initial ROM speed value									<T12>
								(ORINITDRAMSpeed<<19)|\	; initial DRAM speed value
								(ORINITClock25<<18)|\	; initial clock speed value									<T12>
								(ORINITBankD<<12)|\		; initial Bank D starting address value
								(ORINITBankC<<6)|\		; initial Bank C starting address value
								(ORINITBankB)			; initial Bank B starting address value
ORWELL_INIT33		EQU			\						;															<T6><T12> thru next <T12>
								(ORINITWaitRd2<<31)|\	; initial value - are TWO read-related wait states needed? (0=no)<T6>
								(ORINITWaitRd1<<30)|\	; initial value - is  ONE read-related wait state needed? (0=no)<T6>
								(ORINITPageMode<<29)|\	; initial page mode value (OFF)								<T6>
								(ORINITParType<<28)|\	; initial parity even/odd value
								(ORINITParity<<27)|\	; initial parity on/off value
								(ORINITREFRESH33<<24)|\	; initial refresh rate value
								(ORINITROMSpeed33<<21)|\; initial ROM speed value
								(ORINITDRAMSpeed<<19)|\	; initial DRAM speed value
								(ORINITClock33<<18)|\	; initial clock speed value
								(ORINITBankD<<12)|\		; initial Bank D starting address value
								(ORINITBankC<<6)|\		; initial Bank C starting address value
								(ORINITBankB)			; initial Bank B starting address value						<T12>


;---------------------------------------------------
; JAWS Memory Controller Equates
;---------------------------------------------------

JAWSRAMWaitS	EQU			$00000					; RAM wait state control register offset
JAWSEconoMode	EQU			$04000					; Econo-Mode register offset									<21> HJR
JAWSROMWaitS	EQU			$06000					; ROM wait state control register offset

JAWSMemConfigA	EQU			$10000					; Contiguous memory (knitting) registers
JAWSMemConfigB	EQU			$12000					; Contiguous memory (knitting) registers
JAWSMemConfigC	EQU			$14000					; Contiguous memory (knitting) registers

JAWSPowerCycle	EQU			$20000					; CPU power off control register
JAWSSetCPUClock	EQU			$22000					; Controls the CPU clock frequency
JAWSPCBLevel	EQU			$30000					; Selects between SCC and SCC/SCSI combo
JAWSLockRAM		EQU			$32000					; Puts RAM in self refresh state
JAWSGetCPUClock	EQU			$34000					; Returns the CPU clock frequency

;---------------------------------------------------
; Niagra Memory Controller Equates
;---------------------------------------------------

NiagraVidCntCtr	EQU			$02000					; Video count options 									<21> HJR
NiagraGUR		EQU			$16000					; General Utility Registers (ponti register access)<SM4> rb
NiagraVidAcc1	EQU			$22000					; Video Accesses thru 64
NiagraVidAcc2	EQU			$24000					; Video Accesses thru 512
NiagraVidAcc3	EQU			$26000					; Video Accesses thru 2K
NiagraFlashEnbl	EQU			$30000					; Enable flash from Niagra
NiagraFPUAcc	EQU			$34000					; FPU access detected
NiagraSpeedReg	EQU			$36000					; Returns the CPU clock frequency

;---------------------------------------------------
; Pratt Memory Controller Equates
;---------------------------------------------------

PrattChipID		EQU			$5ffffff8				; Pratt ID register address (chip version)		CSR0
PrattSysStat	EQU			$0007					; CPU speed	register offset						CSR1								
PrattROMSpeed	EQU			$000B					; ROM speed register offset						CSR2
PrattRAMDensity	EQU			$000F					; RAM density register offset					CSR3
PrattRAMConfig	EQU			$0013					; RAM configuration register offset				CSR4
PrattRefresh	EQU			$0017					; RAM refresh register offset					CSR5
PrattNapReg		EQU			$001B					; PowerCycling enable register offset			CSR6
PrattVersion	EQU			$001F					; Unused register offset (always reads zero)	CSR7

													;CSR1 System Status Register
Pratt16MHzCPU	EQU			%00000000				; CPU speed reg config values (bits 0:1)
Pratt20MHzCPU	EQU			%00000001				; 
Pratt25MHzCPU	EQU			%00000010				; 
Pratt33MHzCPU	EQU			%00000011				;
PrattFlashLBit	EQU			2						; bit position for Flash detection (0 = Flash is present)
PrattROMBit		EQU			3						; bit position for ROM boot (1 = ROM in system)

Pratt250nsROM	EQU			%00000000				;CSR2 ROM speed reg config values
Pratt200nsROM	EQU			%00000001				;
Pratt150nsROM	EQU			%00000010				;
Pratt120nsROM	EQU			%00000011				;

													;CSR3/4 RAM sizing bit definitions
PrattDensBits	EQU			%00001111				; bit mask showing active density config bits
PrattBankBits	EQU			%00111111				; bit mask showing active bank occupancy bits
PrattDefDensity	EQU			%00000111				; Default RAM Density value for Pratt (all 8MB banks)
PrattDefConfig	EQU			%00111111				; Default RAM Bank Configuration for Pratt (all banks occupied)		
PrattNumbanks	EQU			6						; Total number of RAM banks, onboard plus expansion

Pratt0MBbank	EQU			%11111100				; Onboard RAM bank bit masks 
Pratt2MBbank	EQU			%11111110
Pratt4MBbank	EQU			%11111101
Pratt8MBbank	EQU			%11111111

Pratt0MBExBank	EQU			%11110011				; Expansion RAM bank bit masks
Pratt2MBExBank	EQU			%11110011
Pratt4MBExBank	EQU			%11111011
Pratt8MBExBank	EQU			%11110111

													;CSR5 Test Control Bits
PrattFreqRfsh	EQU			0						; Pratt frequent refresh control bit
PrattDBRfshOnly	EQU			1						; Do daughterboard refresh only bit
PrattShortRamp	EQU			2						; Do short power rampup bit

PrattPwrCyclBit	EQU			0						;CSR6 Power Cycling bit (= 1 to power cycle) 

;---------------------------------------------------								<SM4> rb, start
; Ponti Register Equates  (NiagraGUR register space + offset
;---------------------------------------------------

PontiSPIMdmCtl		EQU			$000
PontiSndCtl			EQU			$400
PontiSPISftReg		EQU			$800
PontiLmpSftCtl		EQU			$C00

; Ponti PontiSPIMdmCtl bit definitions
PontiSPIMdmId		EQU			0				; (1 = SPI modem connected)
PontiSPIAck			EQU			2				; (1 = ack idle)
PontiSPIReq			EQU			3				; (1 = req idle)
PontiSPIIrq			EQU			4				; (1 = interrupting)

; Ponti PontiSoundCtl bit definitions
PontiSndSPIIrqMsk	EQU			0				; (1 = mask int)			- irq mask for PontiSPIIrq
PontiSndIntMic		EQU			1				; (1 = using internal mic)	- flag to check which mike is used	<H22>
PontiSndLatchClr	EQU			2				; (pulse high to clear)		- line directly to latch
PontiSndLatchData	EQU			3				; (1 = snd ckt used)		- output value of the sound latch
PontiSndPWMOff		EQU			4				; (1 = PWM off)				- ultimate off to remove "pop"
PontiSndPwrOn		EQU			5				; (1 = power snd ckt)		- sw equal of latch output
PontiSndMux0		EQU			6				; (1 = ???)
PontiSndMux1		EQU			7				; (1 = modem sound {regardless of Mux0})

; Ponti PontiLmpSftCtl bit definitions
PontiLmpOff			EQU			0				; (1 = backlight on) 		- turn on the backlight tube
PontiLmpHWCtl		EQU			1				; (1 = Hardware control) 	- if set, hardware control loop
PontiLmpMux0		EQU			2				; (1 = 1/2 pot) 			- 1/2 scale pot reduction
PontiLmpMux1		EQU			3				; (1 = 1/4 pot) 			- 1/4 scale pot reduction
PontiLmpSPIDir		EQU			4				; (1 = shift out) 			- direction of shift register

;---------------------------------------------------								<K9> HJR
; HardRock Register Equates
;---------------------------------------------------
HardRockSlotBase	EQU			$FB000000

HardRockCodecICR	EQU			HardRockSlotBase + $1020
HardRockCodecSRCR	EQU			HardRockSlotBase + $1024
HardRockCodecEnReg	EQU			HardRockSlotBase + $1028
HardRockCodecOutAtt	EQU			HardRockSlotBase + $1030
HardRockCodecInGain	EQU			HardRockSlotBase + $1034

HardRockFifoBase	EQU			HardRockSlotBase + $2000
HardRockFifoControl	EQU			HardRockSlotBase + $2000 +4

HRChan_run12		EQU			12				; 1 = enable channel 12
HRChan_run9			EQU			9				; 1 = enable channel 9
HRChan_run7			EQU			7				; 1 = enable channel 7
HRChan_run6			EQU			6				; 1 = enable channel 6
HRChan_run5			EQU			5				; 1 = enable channel 5
HRChan_run4			EQU			4				; 1 = enable channel 4
HRChan_run3			EQU			3				; 1 = enable channel 3
HRChan_run2			EQU			2				; 1 = enable channel 2
HRChan_run1			EQU			1				; 1 = enable channel 1
HRSPI_Voice_Sel		EQU			0				; 1 = Voice DMA data goes through SPI Interface
												; 0 = Voice DMA data goes through CODEC Interface

HardRockFifoCTL0	EQU			HardRockFifoBase + $10
HardRockFifoCTL1	EQU			HardRockFifoBase + $20
HardRockFifoCTL2	EQU			HardRockFifoBase + $30

HardRockFifoBase0	EQU			HardRockFifoBase + $1C
HardRockFifoBase1	EQU			HardRockFifoBase + $2C
HardRockFifoBase2	EQU			HardRockFifoBase + $3C

HardRockFifoRec		RECORD		0,Increment		; 
HRFifoConfig		DS.W		1				; 0
HRFifoInt			DS.W		1				; 2
HRFifoReserved		DS.W		2				; 4
HRFifoReadptr		DS.W		1				; 8
HRFifoWriteptr		DS.W		1				; A
HRFifoBase			DS.L		1				; C
HRFiforecSize		EQU			*-HardRockFifoRec
					ENDR

HRFifoConfig64b		EQU			6				; Fifo config size of 64 bytes	
HRFifoConfig128b	EQU			7				; Fifo config size of 128 bytes	
HRFifoConfig256b	EQU			8				; Fifo config size of 256 bytes	
HRFifoConfig512b	EQU			9				; Fifo config size of 512 bytes	
HRFifoConfig1k		EQU			10				; Fifo config size of 1 kbytes	
HRFifoConfig2k		EQU			11				; Fifo config size of 2 kbytes	
HRFifoConfig4k		EQU			12				; Fifo config size of 4 kbytes	
HRFifoConfig8k		EQU			13				; Fifo config size of 8 kbytes	

HRFifoConfigVal		EQU			HRFifoConfig1k	; Currently set Fifo size to 1k
HRFifoSz			EQU			$400			; $400 = #1024 = 1k
HRFifoWrapVal		EQU			HRFifoSz-1

HardRockFifoIntMsk0	EQU			HardRockFifoBase + $12
HardRockFifoIntMsk1	EQU			HardRockFifoBase + $22
HardRockFifoIntMsk2	EQU			HardRockFifoBase + $32

HRIntMask			EQU			0				; 1 = interrupt masked, 0 = interrupt enabled

HardRockReadIntRec	RECORD		0,Increment		; 
HRIntFlags			DS.B		1
HRRcvFlags			DS.B		1
HRDataCount			DS.W		1
					ENDR

HardRockModemPwrReg	EQU			HardRockSlotBase + $20
HardRockModemRstClr	EQU			2				; 0 = deassertion of CHIQUITA_RESET_L is high level
												; 1 = deassertion of CHIQUITA_RESET_L is tristate level
HardRockModem_RST	EQU			1				; 0 = assert CHIQUITA_RESET_L
HardRockModem_PWR	EQU			0				; 1 = Enable power to modem

HardRockModem_base	EQU			HardRockSlotBase + $4000

HardRockSPIMdmCtl	EQU			$000
HardRockSPIAck		EQU			2				; (1 = ack idle)
HardRockSPIReq		EQU			3				; (1 = req idle)

HardRockSndCtl		EQU			$400
HardRockSndSPIIrqMsk EQU		0				; (1 = mask int)

HardRockSPISftReg	EQU			$800

HardRockLmpSftCtl	EQU			$C00
HardRockLmpSPIDir	EQU			4				; (1 = shift out) 			- direction of shift register

ModemExtCmdRec	RECORD			0,Increment		; 
modemcmdsel		ds.b			1
modemdata		ds.b			1
				endr

WriteFifoRect	RECORD			0,Increment		; 
writeflags		ds.b			1
writecnthi		ds.b			1
writecntlo		ds.b			1
writepad		ds.b			1				;															<K9>
				endr


;-------------------------------------																		<H21> thru next <H21>
;	djMEMC memory controller equates
;-------------------------------------

;	This hard-coded I/O address is in here because there is no more room in the
;	Universal tables to hold this information.

MEMCAddr			EQU		$50F0E000				; same for both Wombat + WLCD memory maps

;	djMEMC-specific CPU_ID bit values

djVIA_CPU_TYPE_MASK	EQU		%01000010				; PA6, PA1 = CPU type bits								<SM18>
djCPU_TYPE_VAIL040	EQU		%00000000				; Vail 040   = 00										<SM18>
djCPU_TYPE_FRIDGE	EQU		%00000010				; Frigidaire = 01										<SM18>
djCPU_TYPE_WLCD		EQU		%01000000				; WLCD       = 10										<SM18>
djCPU_TYPE_LEGO		EQU		%01000010				; Lego       = 11										<SM18>

djVIA_CPU_SPEED_MASK EQU	%00010100				; PA4, PA2 = CPU speed bits								<SM18>
djCPU_SPEED_20MHZ	EQU		%00000000				; 20MHz      = 00										<SM18>
djCPU_SPEED_25MHZ	EQU		%00000100				; 25MHz      = 01										<SM18>
djCPU_SPEED_33MHZ	EQU		%00010000				; 33MHz      = 10										<SM18>
djCPU_SPEED_40MHZ	EQU		%00010100				; 40MHz      = 11										<SM18>

MEMCRegisterStart	EQU		0
MEMCIntleaveEnable	EQU		MEMCRegisterStart		; DRAM interleave enable reg.
dj_OneBufferedBusBit EQU	5
;	djMEMC supports up to a maximum of 10 (TEN) DRAM banks
dj_MaxBanks			EQU		10						;														<H22>

MEMCDRAMCfg0		EQU		MEMCIntleaveEnable+4	; Bank 0 cfg reg
MEMCDRAMCfg1		EQU		MEMCDRAMCfg0+4			; Bank 1 cfg reg
MEMCDRAMCfg2		EQU		MEMCDRAMCfg1+4			; Bank 2 cfg reg
MEMCDRAMCfg3		EQU		MEMCDRAMCfg2+4			; Bank 3 cfg reg
MEMCDRAMCfg4		EQU		MEMCDRAMCfg3+4			; Bank 4 cfg reg
MEMCDRAMCfg5		EQU		MEMCDRAMCfg4+4			; Bank 5 cfg reg
MEMCDRAMCfg6		EQU		MEMCDRAMCfg5+4			; Bank 6 cfg reg
MEMCDRAMCfg7		EQU		MEMCDRAMCfg6+4			; Bank 7 cfg reg
MEMCDRAMCfg8		EQU		MEMCDRAMCfg7+4			; Bank 8 cfg reg
MEMCDRAMCfg9		EQU		MEMCDRAMCfg8+4			; Bank 9 cfg reg

MEMCmemTop			EQU		MEMCDRAMCfg9+4			; Top of stitched RAM
MEMCconfig			EQU		MEMCmemTop+4			; "Multiple bit DRAM/ROM configuration register"
MEMCRefresh			EQU		MEMCconfig+4			; DRAM refresh rate register


;__________________________________________________________________________________________
;
;
; Interrupt Vector Definitions and Masks
;
;
;__________________________________________________________________________________________



;---------------------------------------------------
; Interrupt Masks
;---------------------------------------------------

hiIntMask 		EQU 		$0700					; programmer switch only
pwrOffEnbl		EQU 		$2500					; mask to allow poweroff interrupts
sccIntMask		EQU 		$0400					; SCC interrupt level
sccEnblMask   	EQU 		$FBFF					; mask to enable SCC interrupts
slotIntMask   	EQU 		$0200		   			; slot's interrupt level	<v1.4><1.9>
viaIntMask		EQU 		$0100					; VIA1 interrupt level
loIntMask 		EQU 		$0100


;---------------------------------------------------
; Hardware Base Addresses
;---------------------------------------------------

WrOffs			EQU			0						; SCSI write addrs are same as read base
MskIOP1			EQU			1						; IOP 1 (SWIM) is level 1 interrupt
MskVIA1			EQU			1						; VIA 1 is level 1
MskADB			EQU			1						; ADB is level 1
Msk60Hz			EQU			1						; 60 Hz is level 1
MskSCSI			EQU			2						; SCSI is level 2
MskSound		EQU			2						; sound is level 2						<4.5>
MskSlots		EQU			2						; slots are level 2 interrupts
MskRTC			EQU			3						; RTC is level 3
MskIOP0			EQU			4						; IOP 0 (& SCC chip) is level 4
MskPwrOff		EQU			6						; Poweroff button is level 6
MskNMI			EQU			7						; NMI switch is level 7


; ---------------------------------------------------------------------------------------------------	<T8>
;		Bit definitions for the Cache Control Register (CACR) on various CPUs							<T8>
; ---------------------------------------------------------------------------------------------------	<T8>
;
;	020 CACR:		(from MC68020 User's Manual, 3rd Ed.  pg. 6-3)										<T8>
;			+------------------------------------------------+											<T8>
;			|  0  ..............  0 |  C  |  CE  |  F  |  E  |											<T8>
;			+------------------------------------------------+											<T8>
;			  31                  4    3      2     1     0												<T8>
;
;				C   =  Clear Cache																		<T8>
;				CE  =  Clear Entry																		<T8>
;				F   =  Freeze Cache																		<T8>
;				E   =  Enable (Inst.) Cache																<T8>
;
;
;	030 CACR:		(from MC68030 User's Manual, 2nd Ed.  pg 6-15)										<T8>
;			+------------------------------------------------------------------------------------+		<T8>
;			|  0  ...  0  | WA | DBE | CD | CED | FD | ED | 0 | 0 | 0 | IBE | CI | CEI | FI | EI |		<T8>
;			+------------------------------------------------------------------------------------+		<T8>
;			 31       14    13    12   11    10    9    8   7   6   5    4    3     2    1     0		<T8>
;
;				WA  =	Write Allocate																	<T8>
;				DBE =	Data Burst Allocate																<T8>
;				CD	=	Clear Data Cache																<T8>
;				CED	=	Clear Entry in Data Cache														<T8>
;				FD	=	Freeze Data Cache																<T8>
;				ED	=	Enable Data Cache																<T8>
;				IBE	=	Instruction Burst Enable														<T8>
;				CI	=	Clear Instruction Cache															<T8>
;				CEI	=	Clear Entry in Instruction Cache												<T8>
;				FI	=	Freeze Instruction Cache														<T8>
;				EI	=	Enable Instruction Cache														<T8>
;
;
;	040 CACR:		(from MC68040 User's Manual, 1st Ed.,  pg. 7-19)									<T8>
;			+-------------------------------------+														<T8>
;			|  DE  |  0 ... 0  |  IE  |  0 ... 0  |														<T8>
;			+-------------------------------------+														<T8>
;			   31    30     16    15    14     0														<T8>
;
;				DE	=	Enable Data Cache																<T8>
;				IE	=	Enable Instruction Cache														<T8>
;

;	MC68040 CACR bits of note:

CACR_IE_040				EQU		15				; bit # of instruction cache enable/disable on 040s		<T8>
CACR_DE_040				EQU		31				; bit # of data cache enable/disable on 040s			<T8>

;	MC68020 and MC68030 CACR bits of note:

CACR_EI_020_030			EQU		0				; bit # of inst. cache enable/disable on 020/030s		<T8>
CACR_FI_020_030			EQU		1				; bit # of inst. cache freeze on 020/030s				<T8>
CACR_CEI_020_030		EQU		2				; bit # of inst. cache flush entry on 020/030s			<T8>
CACR_CI_020_030			EQU		3				; bit # of inst. cache flush on 020/030s				<T8>
CACR_IBE_030			EQU		4				; bit # of data cache burst enable on 030s				<T8>
CACR_ED_030				EQU		8				; bit # of data cache enable/disable on 030s			<T8>
CACR_FD_030				EQU		9				; bit # of data cache freeze on 030s					<T8>
CACR_CED_030			EQU		10				; bit # of data cache flush entry on 030s				<T8>
CACR_CD_030				EQU		11				; bit # of data cache flush on 030s						<T8>
CACR_DBE_030			EQU		12				; bit # of data cache burst enable on 030s				<T8>
CACR_WA_030				EQU		13				; bit # of write allocate enable on 030s				<T8>

;__________________________________________________________________________________________
;
;
; Miscellaneous Equates - Look Here If You Can't Find It Anywhere Else.
;
;
;__________________________________________________________________________________________



Machine   		EQU 		7						; new Machine number for patches			<18>

;---------------------------------------------------
; System Software Information
;---------------------------------------------------

numOsTrap 		EQU 		256   					; number of os traps
ToolTable 		EQU 		$0E00 					; start of toolbox trap table
numTbTrap 		EQU 		1024   					; number of toolbox traps
numTrapMask   	EQU 		numTbTrap-1				; mask for number of tb traps
JMemMgr24		EQU			$1E00					; jump vector start for 24 bit Memory Manager 		<v1.9>
JMemMgr32		EQU			$1F00					; jump vector start for 32 bit Memory Manager 		<v1.9>
HeapStart 		EQU 		$2800 					; Low mem is now 10k bytes							<SM13>
defSysHeap		EQU 		$18000    				; Default size of the system heap
nDfltStackSize	EQU 		$6000 					; Default stack size

**** maybe not so temporary to allow things to build ****									<3.5>
oneSecConst   	EQU 		8 						; gets converted to $80000 for onesec constant<3.5>
	IF BlackBirdDebug THEN
ROMStart  		EQU 		$40000000 				; ••PN BlackBirdstarting address of final ROM code	<3.5>
	ELSE
ROMStart  		EQU 		$40800000 				; starting address of final ROM code	<3.5>
	ENDIF
snd2MemTop		EQU 		$300  					; SoundLow to Memtop
pwm2MemTop		EQU 		$2FF  					; PWMBuffer to MemTop
bufWorldSize  	EQU 		8192		   			; total size of the BufPtr world		<H16>

;---------------------------------------------------								<SM4> rb, start
;  Sound parameters																			<P4>
;---------------------------------------------------
sampleSize		equ			4				; number of bytes per sample
bufferSize		equ			960				; number of samples per buffer
sampleRate		equ			24 * 1024		; 24KHz sample rate

;---------------------------------------------------------------------
;  Whitney Sound Register Offsets (from ASC base in UniversalTables.a)
;---------------------------------------------------------------------
wSndInABWritePtr	equ			$f54		; [word] A/B input FIFO write pointer (alias at $f04)
wSndInAReadPtr		equ			$f52		; [word] A input FIFO read pointer
wSndInBReadPtr		equ			$f56		; [word] B input FIFO read pointer

wSndOutAWritePtr	equ			$f58		; [word] A output FIFO write pointer
wSndOutBWritePtr	equ			$f5c		; [word] B output FIFO write pointer
wSndOutABReadPtr	equ			$f5a		; [word] A/B output FIFO read pointer (alias at $f26)

wSndControl			equ			$f40		; [byte] configures Singer power/FIFO size/sample rate, etc.
wSndFIFOBase		equ			$f44		; [long] physical base address of FIFO
wSndFIFOBaseHi		equ			$f44		; [word] high order (physical) word of FIFO base address in RAM
wSndFIFOBaseLo		equ			$f46		; [word] low order word of FIFO base address in RAM

wSndAData			equ			$1000		; [word] 16-bit sound in/out data for left channel
wSndBData			equ			$1800		; [word] 16-bit sound in/out data for right channel

wSndSingerCtl1		equ			$f48		; [word] Singer mute/input select/gain control
wSndSingerCtl2		equ			$f4a		; [word] Singer attenuation/digital out control
wSndSingerStat1		equ			$f4c		; [word] Singer valid/clipping/error/rev status
wSndSingerStat2		equ			$f4e		; [word] Singer digital input status

;---------------------------------------------------
;  Whitney Sound Register Bit Definitions
;---------------------------------------------------

; === sndControl register ===
wSampleRateMsk	equ			$03				; Mask for sample rate bits
wFIFOSizeMsk	equ			$0C				; Mask for FIFO size bits

wSampleRate		equ			0				; Sample rate field for Singer Serial Clock (2 bits)
wSampleRate1	equ			0				;  lsbit
wSampleRate2	equ			1				;  msbit

wFIFOSize		equ			2				; FIFO size (2 bits)
wFIFOSize1		equ			2				;  lsbit
wFIFOSize2		equ			3				;  msbit

wSingerClk		equ			4				; Singer master clock enable
wSingerPower	equ			5				; Singer power enable
wSingerSNDFlag	equ			6				; Singer sound flag
;				equ			7				; unused

; === sndSingerCtl1 register ===
wRGainMsk		equ			$000F			; Mask for right channel input gain
wLGainMsk		equ			$00F0			; Mask for left channel input gain
wRGain			equ			0				; Singer right input A/D gain (4 bits)
wRGain1			equ			0				;  lsb
wRGain2			equ			1
wRGain3			equ			2
wRGain4			equ			3				;  msb

wLGain			equ			4				; Singer left input A/D gain (4 bits)
wLGain1			equ			4				;  lsb
wLGain2			equ			5
wLGain3			equ			6
wLGain4			equ			7				;  msb

wInSelRight		equ			8				; Input select for right channel
wInSelLeft		equ			9				; Input select for left channel

wMute			equ			10				; Mute enable

wWordAOut		equ			11				; Word A Out 17:21 (5 bits) - 0's, see Singer spec
;				equ			12
;				equ			13
;				equ			14
;				equ			15

; === sndSingerCtl2 register ===
wDigOut			equ			0				; Singer digital output (4 bits)
wDigOut4		equ			0				;  output 4
wDigOut3		equ			1				;  output 3
wDigOut2		equ			2				;  output 2
wDigOut1		equ			3				;  output 1

wRAtten			equ			4				; Singer right D/A attenuation (4 bits)
wRAtten1		equ			4				;  lsb
wRAtten2		equ			5
wRAtten3		equ			6
wRAtten4		equ			7				;  msb

wLAtten			equ			8				; Singer left D/A attenuation (4 bits)
wLAtten1		equ			8				;  lsb
wLAtten2		equ			9
wLAtten3		equ			10
wLAtten4		equ			11				;  msb


wWordBOut		equ			12				; Word B Out 49:52 (5 bits) - 0's in SM1, see Singer spec
;				equ			13
;				equ			14
;				equ			15

; === sndSingerStat1 register ===
wRev			equ			0				; Singer revision number (4 bits)
wRev1			equ			0				;  lsb
wRev2			equ			1
wRev3			equ			2
wRev4			equ			3				;  msb

wErr			equ			4				; Singer error code (4 bits)
wErr1			equ			4				;  lsb
wErr2			equ			5
wErr3			equ			6
wErr4			equ			7				;  msb

wRClip			equ			8				; Right clipping indicator
wLClip			equ			9				; Left clipping indicator

wADValid		equ			10				; A/D valid data indicator

wWordAIn		equ			11				; Word A In 17:21 (5 bits), see Singer spec
;				equ			12
;				equ			13
;				equ			14
;				equ			15

; === sndSingerStat2 register ===
wDigIn			equ			0				; Singer digital input (4 bits)
wDigIn4			equ			0				;  input 4
wDigIn3			equ			1				;  input 3
wDigIn2			equ			2				;  input 2
wDigIn1			equ			3				;  input 1

wWordBIn		equ			4				; Word B In 49:60 (12 bits), see Singer spec
;				equ			5
;				equ			6
;				equ			7
;				equ			8
;				equ			9
;				equ			10
;				equ			11
;				equ			12
;				equ			13
;				equ			14
;				equ			15

;---------------------------------------------------
;  PSC Hardware Defs
;---------------------------------------------------

; === Hardware Base Addresses ===
PSCBase			equ			$50f31000		; Base address of the PSC

;---------------------------------------------------
;  PSC Sound Register Offsets
;---------------------------------------------------
sndComCtl		equ			$200			; [word] sound and communications control
singerCtl		equ			$204			; [long] singer sound CODEC control
singerStat		equ			$208			; [long] singer sound CODEC status  (read only)
sndPhase		equ			$20c			; [long] sound subsystem phase  (read only)
sndInBase		equ			$210			; [long] sound input double-buffer base address
sndOutBase		equ			$214			; [long] sound output double buffer base address
sndSize			equ			$218			; [word] sound input and output buffer size
dspOverRun		equ			$21C			; [byte] DSP overrun status register.

;---------------------------------------------------
;  PSC Sound Register Bit Definitions
;---------------------------------------------------
; === sndComCtl register ===
pSubFrmInSel	equ			0				; singer sound CODEC input subframe select
pSubFrmInSel1	equ			0				; singer sound CODEC input subframe select, lsbit
pSubFrmInSel2	equ			1				; singer sound CODEC input subframe select, msbit

pSubFrmOutSel	equ			2				; singer sound CODEC output subframe select
pSubFrmOutSel1	equ			2				; singer sound CODEC output subframe select, lsbit
pSubFrmOutSel2	equ			3				; singer sound CODEC output subframe select
pSubFrmOutSel3	equ			4				; singer sound CODEC output subframe select
pSubFrmOutSel4	equ			5				; singer sound CODEC output subframe select, msbit

pFrmIntEn		equ			6				; frame interrupt enable
pSndInEn		equ			7				; sound input DMA enable
pSndOutEn		equ			8				; sound output DMA enable

pSndRate		equ			9				; singer sound CODEC sampling rate control
pSndRate1		equ			9				; singer sound CODEC sampling rate control, lsbit
pSndRate2		equ			10				; singer sound CODEC sampling rate control, msbit

pComRate		equ			11				; communications CODEC sampling rate contrl
pComRate1		equ			11				; communications CODEC sampling rate contrl, lsbit
pComRate2		equ			12				; communications CODEC sampling rate contrl, msbit
;				equ			13				; unused
;				equ			14				; unused
;				equ			15				; unused


sndComCtlInit 	equ 		(0<<pSubFrmInSel)|\		; Input subframe zero selected
							(0<<pSubFrmOutSel)|\	; Ouput subframe zero selected
							(0<<pFrmIntEn)|\		; frame interrupts disabled
							(0<<pSndInEn)|\			; sound input disabled
							(0<<pSndOutEn)|\		; sound output disabled
							(0<<pSndRate)|\			; 24KHz sampling rate selected
							(0<<pComRate)			; communications CODEC, we just don't care

soundOutEnable	equ 		(0<<pSubFrmInSel)|\		; Input subframe zero selected
							(1<<pSubFrmOutSel)|\	; Ouput subframe zero selected
							(0<<pFrmIntEn)|\		; frame interrupts enabled
							(0<<pSndInEn)|\			; sound input disabled
							(1<<pSndOutEn)|\		; sound output disabled
							(0<<pSndRate)|\			; 24KHz sampling rate selected
							(0<<pComRate)			; communications CODEC, we just don't care



; === singerCtl register ===
pOutputPort	equ			0					; set digital output port
pOutputPort1	equ			0				; set digital output port, lsb
pOutputPort2	equ			1				; set digital output port
pOutputPort3	equ			2				; set digital output port
pOutputPort4	equ			3				; set digital output port, msb

pRightAtten		equ			4				; right ouput attenutaion
pRightAtten1	equ			4				; right ouput attenutaion, lsb
pRightAtten2	equ			5				; right ouput attenutaion
pRightAtten3	equ			6				; right ouput attenutaion
pRightAtten4	equ			7				; right ouput attenutaion, msb

pLeftAtten		equ			8				; Left ouput attenutaion
pLeftAtten1		equ			8				; Left ouput attenutaion, lsb
pLeftAtten2		equ			9				; Left ouput attenutaion
pLeftAtten3		equ			10				; Left ouput attenutaion
pLeftAtten4		equ			11				; Left ouput attenutaion, msb

pRightGain		equ			12				; right input gain
pRightGain1		equ			12				; right input gain, lsb
pRightGain2		equ			13				; right input gain
pRightGain3		equ			14				; right input gain
pRightGain4		equ			15				; right input gain, msb

pLeftGain		equ			16				; left input gain
pLeftGain1		equ			16				; left input gain, lsb
pLeftGain2		equ			17				; left input gain
pLeftGain3		equ			18				; left input gain
pLeftGain4		equ			19				; left input gain, msb

pRightInMux		equ			20				; right input mux
pLeftInMux		equ			21				; left input mux
pMute			equ			22				; mute bit
pExpCtl			equ			23				; expand bit for control
;				equ			24				; unused
;				equ			25				; unused
;				equ			26				; unused
;				equ			27				; unused
;				equ			28				; unused
;				equ			29				; unused
;				equ			30				; unused
;				equ			31				; unused

singerCtlInit	equ			(%1111<<pOutputPort)|\	; digitial ouput ports selected
							(0<<pRightAtten)|\		; right output attenuation set to zero
							(0<<pLeftAtten)|\		; left output attenuation set to zero
							(%0101<<pRightGain)|\	; right input gain set to middle
							(%0101<<pLeftGain)|\	; left input gain set to middle
							(0<<pRightInMux)|\		; input muxes irrelevant
							(0<<pLeftInMux)|\		;
							(1<<pMute)|\			; mute ON
							(0<<pExpCtl)			; no expand

unMute			equ			(%1111<<pOutputPort)|\	; digitial ouput ports selected
							(0<<pRightAtten)|\		; right output attenuation set to zero
							(0<<pLeftAtten)|\		; left output attenuation set to zero
							(%0101<<pRightGain)|\	; right input gain set to middle
							(%0101<<pLeftGain)|\	; left input gain set to middle
							(0<<pRightInMux)|\		; input muxes irrelevant
							(0<<pLeftInMux)|\		;
							(0<<pMute)|\			; mute OFF
							(0<<pExpCtl)			; no expand



; === singerStat register ===
pInputPort1		equ			0				; set digital Input port, lsb
pInputPort2		equ			1				; set digital Input port
pInputPort3		equ			2				; set digital Input port
pInputPort4		equ			3				; set digital Input port, msb
;				equ			4				; unused
;				equ			5				; unused
;				equ			6				; unused
;				equ			7				; unused
;				equ			8				; unused
;				equ			9				; unused
;				equ			10				; unused
;				equ			11				; unused
pRevNum1		equ			12				; revision number, lsb
pRevNum2		equ			13				; revision number
pRevNum3		equ			14				; revision number
pRevNum4		equ			15				; revision number, msb
pSingerStatus1	equ			16				; status bits, lsb
pSingerStatus2	equ			17				; status bits
pSingerStatus3	equ			18				; status bits
pSingerStatus4	equ			19				; status bits, msb
pOFRight		equ			20				; right channel overflow
pOFLeft			equ			21				; left channel overflow
pValidData		equ			22				; valid sound data
pExpStat		equ			23				; expand bit for status
;				equ			24				; unused
;				equ			25				; unused
;				equ			26				; unused
;				equ			27				; unused
;				equ			28				; unused
;				equ			29				; unused
;				equ			30				; unused
;				equ			31				; unused


; === sound phase register ===
pPreScaleLSB	equ			0				; pre-scaler lsbit
pReScaleMSB		equ			5				; pre-Scaler msbit
pOffsetLSB		equ			6				; sample offset lsbit
pOffsetMSB		equ			17				; sample offset msbit
;				equ			18				; unused
;				equ			19				; unused
;				equ			20				; unused
;				equ			21				; unused
;				equ			22				; unused
;				equ			23				; unused
;				equ			24				; unused
;				equ			25				; unused
;				equ			26				; unused
;				equ			27				; unused
;				equ			28				; unused
;				equ			29				; unused
;				equ			30				; unused
;				equ			31				; unused

phaseOffsetMsk	equ			$003FFFC0		;										<SM4> rb, end

;---------------------------------------------------
; PSC DSP Register Bit Definitions						<SM10> ejb
;---------------------------------------------------

; === dspOverrun register ===
pdspReset		equ			0				; when set places the dsp in reset state
pdspResetEn		equ			1				; when cleared disables the dspReset bit
pdspFrameOvr	equ			2				; when set indicates cat2 frame overrun on the dsp
;				equ			3				; unused
;				equ			4				; unused
;				equ			5				; unused
;				equ			6				; unused
pdspSet			equ			7				; "0" clears, "1" sets for any bit field [0:6] containing a "1"

;---------------------------------------------------
; ???
;---------------------------------------------------

seRegs			EQU 		$0C30 					; offset to Sys Error Regs w/o Overlay

;---------------------------------------------------
; Hardware configuration bits.
;---------------------------------------------------

hwCbSCSI  		EQU 		15        				; SCSI port present
hwCbClock 		EQU 		14        				; New clock chip present
hwCbExPRAM		EQU 		13        				; Extra Parameter Ram valid.
hwCbFPU   		EQU 		12        				; FPU chip present.
hwCbMMU   		EQU 		11        				; Some kind of MMU present (see MMUType for what kind).
hwCbADB   		EQU 		10        				; Apple Desktop Bus present.
hwCbAUX			EQU			9						; Running A/UX					<2.8>
hwCbPwrMgr		EQU			8						; Power Manager present			<2.8>
hwCmSCSI  		EQU 		(1 << hwCbSCSI)
hwCmClock 		EQU 		(1 << hwCbClock)
hwCmExPRAM		EQU 		(1 << hwCbExPRAM)
hwCmFPU   		EQU 		(1 << hwCbFPU)
hwCmMMU   		EQU 		(1 << hwCbMMU)
hwCmADB   		EQU 		(1 << hwCbADB)
hwCmAUX			EQU			(1 << hwCbAUX)
hwCmPwrMgr		EQU			(1 << hwCbPwrMgr)


;---------------------------------------------------
; HcMac Clock Change Addresses
;---------------------------------------------------

Clock16M  		EQU 		$FE0000   				; Go to sixteen megahertz clock throughput
Clock1M   		EQU 		$FE0002   				; Go to one megahertz clock throughput (adds 64 wait states)


;---------------------------------------------------
; SCC Clock Rates, Baud Rate Constants
;---------------------------------------------------

nuMacClock		EQU 		36864
nuMacConst		EQU 		115200

macClock  		EQU 		36707 					; in Hz * 100
macConst  		EQU 		114709    				; in Hz/32

hcMacClock		EQU 		36720 					; SCC clock rates
hcMacConst		EQU 		114750


;---------------------------------------------------
; Deep Shit Rectangle info
;---------------------------------------------------

dsRectTL  		EQU 		(64<<16)+32       		; top left = 64,32
dsRectBR  		EQU 		(190<<16)+480     		; bottom right = 190,480
dsRectHei 		EQU 		(DSrectBR**$FFFF0000)-(DSrectTL**$FFFF0000)>>16
dsRectLen 		EQU 		(DSrectBR**$FFFF)-(DSrectTL**$FFFF)


;---------------------------------------------------
; System Error Equates
;---------------------------------------------------

seVars			EQU 		seRegs        			; start of system error data space (wrap city)
seVSize   		EQU 		128       				; # of bytes in space
seD0  			EQU 		seVars        			; loc of saved reg D0
seA0  			EQU 		seD0+32       			; loc of saved reg A0
seA7  			EQU 		seA0+28       			; loc of saved reg A7
sePC  			EQU 		seA7+4        			; loc of saved PC
seSR  			EQU 		sePC+4        			; loc of saved SR
seAccess  		EQU 		seSR+2        			; PC address during bus/address error
seCmdSize 		EQU 		seAccess+4    			; # of bytes of parameters passed in _debugger call
se000BE   		EQU 		seCmdSize+2       		; 8 bytes of bus error info for 68000
seLastVar 		EQU 		se000BE+8     			; last var in System Error data space


;---------------------------------------------------
; ROM based debugger nub
;---------------------------------------------------

rdPort			EQU 		seLastVar     			; Number of port currently in use (0 => no link, 1 => A, 2 => B)
rdCode			EQU 		rdPort+2      			; Ptr to code download buffer.
rdAtrap   		EQU 		rdCode+4      			; Saved Rom Atrap handler
rdLowTrap 		EQU 		rdAtrap+4     			; low value for trap handling
rdHiTrap  		EQU 		rdLowTrap+2       		; high value for trap handling
rdResult  		EQU 		rdHiTrap+2    			; result of executing down-loaded code, etc. (16 bytes)
rdEnd 			EQU 		rdResult+16       		; end of vars


;---------------------------------------------------
; Microbug
;---------------------------------------------------

; NOTE: Keep mbDotAddr immediately before mBlocAddr

mbBufSize 		EQU 		34
mbBuffer  		EQU 		seLastVar     			; buffer for input
mbSign			EQU 		mbBuffer+mbBufSize    	; ST => negative sign during conversion
mbDotAddr 		EQU 		mbSign+2      			; saved address
mBlocAddr 		EQU 		mbDotAddr+4       		; saved location


;---------------------------------------------------
; Alternate ROM vectors
;---------------------------------------------------

DiagROM   		EQU 		$F80000   				; Alternate ROM - initial vector
DiagROM1  		EQU 		$F80080   				; Alternate ROM - memory sizing vector
DiagROM2  		EQU 		$F80088   				; Alternate ROM - init I/O vector


;---------------------------------------------------
; Timing constants
;---------------------------------------------------

VIAClockHz		EQU			783360					; VIA clock rate is 783360 Hz.		<2.8>
nTicks			EQU 		VIAClockHz/1000   		; VIA timer ticks per msec
oneSecTicks   	EQU 		60    					; ticks, of course
				IF &TYPE('__SysEqu__') = 'UNDEFINED' THEN
TimeSCSIDB		EQU			$0B24					; DBRAs & SCSI access per millisecond <1.9>
				ENDIF

ramChk			EQU 		1024      				; Amount of memory tested for stack.



;__________________________________________________________________________________________
;
;
; ROM Header RECORD Definition
;
;
;__________________________________________________________________________________________

ROMHeader		RECORD		0,INCREMENT				; offsets to fields in base of ROM
ResetSP				DS.L		1					; $0000 SP to be loaded at reset time
CheckSum			EQU			ResetSP				; $0000 hiram stuffs checksum here
ResetPC				DS.L		1					; $0004 PC to be loaded at reset time
MachineNumber		DS.B		1					; $0008 Machine Number
ROMVersion			DS.B		1					; $0009 ROM Version Number
ReStart				DS.W		2					; $000A JMP to StartBoot routine
BadDisk				DS.W		2					; $000E JMP to eject disk, and ReBoot routine
ROMRelease			DS.W		1					; $0012 ROM Release in HEX, eg. $10B5 is 1.0ß5
PatchFlags			DS.B		1					; $0014 ROM overpatch basis					<H14>
					DS.B		1					; $0015 unused								<H14>
ForeighOSTbl		DS.L		1					; $0016 offset to foreign OS vector table
RomRsrc				DS.L		1					; $001A HiRam stuffs offset to ROM rsrc header here
Eject				DS.W		2					; $001E JMP to DoEject routine
DispTableOff		DS.L		1					; $0022 offset to the compressed dispatch table
Critical			DS.W		2					; $0026 JMP to Critical error handler
ResetEntry			DS.W		2					; $002A JMP to Reset Entry Point routine.
RomLoc				DS.B		1					; $002E (Bit 0: In Ram, Bit 1: In Emulator)
					DS.B		1					; $002F unused
CheckSum0			DS.L		1					; $0030 checksum 0
CheckSum1			DS.L		1					; $0034 checksum 1
CheckSum2			DS.L		1					; $0038 checksum 2
CheckSum3			DS.L		1					; $003C checksum 3
RomSize				DS.L		1					; $0040 HiRam stuffs size of ROM in bytes here
EraseIconOff		DS.L		1					; $0044 Offset to code to ease the Happy Mac icon
InitSys7ToolboxOff	DS.L		1					; $0048 Offset to System 7.0 toolbox init code
SubVers				DS.L		1					; $004C Yet another subversion (sigh)
				ENDR


;---------------------------------------------------
; Romulator ROM location bits and TestFor Macro
;---------------------------------------------------

locValid1		EQU			7						; this must be 1
locValid2		EQU			6						; this must be 0
inEmulatorBit	EQU			1						; running in emulator
inRamBit		EQU			0						; running in ram

;----------
; TestInRam Macro																	<4.4>
;
; This macro tests the RomLoc byte in the ROM header to determine the ROM is located
; in RAM.
;----------
			MACRO
				TestInRam	&reg
			    lea		@testInRamData,&reg
				move.w	#$1,(&reg)					; write to "ROM"
				tst.w	@testInRamData				; did it stick?
				bra.s	@testDone
@testInRamData	dc.w	0
@testDone
			ENDM

;----------
; WhitneyRevAtLeast Macro
;	Sets the Z bit in the CCR if Whitney revision is greater or equal to &rev parameter passed in
;	 else clears the Z bit
; NOTE: This macro no longer supports the original rev Whitney b/c the hack used will interfere with
;		modem operation.
;----------
			MACRO
				WhitneyRevAtLeast	&rev
				cmpi.b	#&rev,WhitneyRev
				bmi.s	@older
				ori		#$04,CCR				;set the Z bit
				bra.s	@exit
@older			andi	#$FB,CCR				;clear the Z bit
@exit
			ENDM	

;----------
; PrattFlashSystem Macro
;	Sets the Z bit in the CCR if Pratt detects Flash on the expansion board,
;	 else clears the Z bit
;----------
PrattSysStatReg	EQU		$50080007
			MACRO
				PrattFlashSystem	
				btst.b	#PrattFlashLBit,PrattSysStatReg		; Is this a flash rom system
			ENDM	

ForAmusementOnly	equ		0
				If	ForAmusementOnly then
;__________________________________________________________________________________________
;
;
; Old 16 bit Equates for onMac, onMacPP, and onHcMac
;
;
;__________________________________________________________________________________________

;=======================================;
;  Macintosh Plus Hardware Information	;
;=======================================;

hwCfgBits 		EQU 		hwCmSCSI++hwCmClock
machine   		EQU 		0
rom85Bits 		EQU 		$7F   					; New ROMs, No Power Off.

; === Interrupt Masks ===
hiIntMask 		EQU 		$0700					; programmer switch only
sccIntMask		EQU 		$0200 					; SCC interrupt Level		<1.5>
sccEnblMask   	EQU 		$F9FF 					; mask to enable SCC interrupts
viaIntMask		EQU 		$0100 					; mask for VIA (and VBL) interrupts
loIntMask 		EQU 		$0100

; === VIA1 BUFFER A ===
;vSound			EQU 		$7    					; sound volume bits (0..2)
vSndPg2   		EQU 		3 						; select sound page 2 if 0
;vOverlay  		EQU 		4 						; overlay bit (overlay when 1)
;vHeadSel  		EQU 		5 						; head select line for Sony
vPage2			EQU 		6 						; select video page 2 if 0
;vSCCWrReq 		EQU 		7 						; SCC write/request line

vAOut 			EQU 		(vSound)|\				; sound volume bits are outputs
							(1<<vSndPg2)|\			; sound page 2 select is an output
							(1<<vOverlay)|\			; overlay bit is an output
							(1<<vHeadSel)|\			; head select line is an output
							(1<<vPage2)|\			; video page 2 select is an output
							(0<<vSCCWrReq)			; SCC write/request line is an input

vAInit 			EQU 		(1)|\					; sound volume level initially 1
							(1<<vSndPg2)|\			; main sound buffer selected
							(0<<vOverlay)|\			; overlay is turned off
							(1<<vHeadSel)|\			; head select line is an output
							(1<<vPage2)|\			; main screen buffer selected
							(0<<vSCCWrReq)			; SCC write/request line is an input


; === VIA1 BUFFER B ===
;vRTCData  		EQU 		0 						; real time clock data
;vRTCClk   		EQU 		1 						; real time clock clock pulses
;vRTCEnb   		EQU 		2 						; clock enable (0 for enable)
vSW   			EQU 		3 						; mouse switch (0 when down)
vX2   			EQU 		4 						; mouse X level
vY2   			EQU 		5 						; mouse Y level
vH4   			EQU 		6 						; horizontal sync
;vSndEnb   		EQU 		7 						; /sound enable (reset when 1)

vBOut 			EQU 		(1<<vRTCData)|\			; real time clock data initially an output
							(1<<vRTCClk)|\			; real time clock clock is an output
							(1<<vRTCEnb)|\			; clock enable is an output
							(0<<vSW)|\				; mouse switch is an input
							(0<<vX2)|\				; mouse X level is an input
							(0<<vY2)|\				; mouse Y level is an input
							(0<<vH4)|\				; horizontal sync is an input
							(1<<vSndEnb)			; sound enable is an output

vBInit 			EQU 		(1<<vRTCData)|\			; real time clock data is one
							(1<<vRTCClk)|\			; real time clock clock is high
							(1<<vRTCEnb)|\			; clock initially disabled
							(0<<vSW)|\				; mouse switch is an input
							(0<<vX2)|\				; mouse X level is an input
							(0<<vY2)|\				; mouse Y level is an input
							(0<<vH4)|\				; horizontal sync is an input
							(1<<vSndEnb)			; sound is disabled

vBufM			EQU 		vBufB  					; mouse state is buffer B


; === Hardware Base Addresses ===

PhaseRead 		EQU 		$F00000   				; Phase read address

VBase 			EQU 		$EFE1FE   				; VIA base address
AVBufA			EQU 		VBase+vBufA 			; VIA buffer A
AVBufB			EQU 		VBase+vBufB  			; VIA buffer B
AVBufM			EQU 		VBase+vBufM  			; VIA buffer with mouse button bit

SCCRBase  		EQU 		$9FFFF8   				; SCC base read address
SCCWBase  		EQU 		$BFFFF9   				; SCC base write address
sccWrite  		EQU 		SCCWBase-SCCRBase		; general offset for write from read

SCSIRd			EQU 		$580000   				; base addr SCSI interface - READ
SCSIWr			EQU 		$580001   				; base addr SCSI interface - WRITE
wrOffs			EQU 		SCSIWr-SCSIRd			; write addrs are +1 to the read base

SoundLow  		EQU 		$3FFD00   				; sound buffer start address
snd2MemTop		EQU 		$300  					; SoundLow to Memtop

PWMBuffer 		EQU 		$3FFD01   				; PWM bytes are low bytes
pwm2MemTop		EQU 		$2FF  					; PWMBuffer to MemTop

; === Video Parameters ===

ScreenLow 		EQU 		$3FA700   				; top of screen screen address
scrn2MemTop   	EQU 		$5900 					; ScreenBase to Memtop

; === Hardware Base Addresses ===

romBSize  		EQU 		$20000    				; 128K bytes in ROM $0075
ROMStart  		EQU 		$400000   				; starting address of ROM code

DBase 			EQU 		$DFE1FF   				; disk address base

; === System Software Information ===
bufWorldSize  	EQU 		scrn2MemTop   			; total size of the BufPtr world

oneSecConst   	EQU 		2 						; gets converted to $20000 for onesec constant
numOsTrap 		EQU 		256   					; number of os traps
ToolTable 		EQU 		$0C00 					; start of toolbox trap table
numTbTrap 		EQU 		512   					; number of toolbox traps
numTrapMask   	EQU 		numTbTrap-1				; mask for number of tb traps
HeapStart 		EQU 		$1400 					; Mac Plus starting point
defSysHeap		EQU 		$B700 					; Default size of the system heap
nDfltStackSize	EQU 		$2000 					; Default stack size

oneSec			EQU 		95528 					; looptimes						*** patch only ***
halfSec   		EQU 		onesec/2				;								*** patch only ***
stlDelay  		EQU 		$30   					; default bus settle delay		*** patch only ***
ROMDoEject		EQU 		$40001E   				; jump to DoEject utility		*** patch only ***
dACKRd			EQU 		$200  					; offset of psuedo-DMA - READ	*** patch only ***


;=======================================;
;	Macintosh SE Hardware Information	;
;=======================================;

hwCfgBits 		EQU 		hwCmSCSI++hwCmClock++hwCmADB
machine   		EQU 		2
rom85Bits 		EQU 		$7F   					; New ROMs, No Power Off.

; === Interrupt Masks ===
hiIntMask 		EQU 		$0700					; programmer switch only
sccIntMask		EQU 		$0200 					; SCC interrupt Level		<1.5>
sccEnblMask   	EQU 		$F9FF 					; mask to enable SCC interrupts
viaIntMask		EQU 		$0100 					; mask for VIA (and VBL) interrupts
loIntMask 		EQU 		$0100

; === VIA1 BUFFER A ===
;vSound			EQU 		$7    					; sound volume bits (0..2)
;vSync 			EQU 		3 						; Synchronous modem
vDriveSel 		EQU 		4 						; int drive select (lower drive when 1)
;vHeadSel  		EQU 		5 						; head select line for Sony
vPage2			EQU 		6 						; select video page 2 if 0
;vSCCWrReq 		EQU 		7 						; SCC write/request line

vAOut 			EQU 		(vSound)|\				; sound volume bits are outputs
							(1<<vSync)|\			; Synchronous modem is an output
							(1<<vDriveSel)|\		; int drive select is an output
							(1<<vHeadSel)|\			; head select line is an output
							(1<<vPage2)|\			; video page 2 select is an output
							(0<<vSCCWrReq)			; SCC write/request line is an input

vAInit 			EQU 		(1)|\					; sound volume level initially 1
							(1<<vSync)|\			; Synchronous modem disabled (active low)
							(0<<vDriveSel)|\		; upper floppy drive selected
							(1<<vHeadSel)|\			; head select line is an output
							(1<<vPage2)|\			; main screen buffer selected
							(0<<vSCCWrReq)			; SCC write/request line is an input



; === VIA1 BUFFER B ===
;vRTCData  		EQU 		0 						; real time clock data
;vRTCClk   		EQU 		1 						; real time clock clock pulses
;vRTCEnb   		EQU 		2 						; clock enable (0 for enable)
;vFDBInt   		EQU 		3 						; Front Desk bus interrupt
;vFDesk1   		EQU 		4 						; Front Desk bus state bit 0
;vFDesk2   		EQU 		5 						; Front Desk bus state bit 1
vSCSIMask 		EQU 		6 						; SCSI IRQ mask
vH4   			EQU 		vSCSIMask				; SCSI IRQ mask (was horiz. sync)
;vSndEnb   		EQU 		7 						; /sound enable (reset when 1)

vBOut 			EQU 		(1<<vRTCData)|\			; real time clock data initially an output
							(1<<vRTCClk)|\			; real time clock clock is an output
							(1<<vRTCEnb)|\			; clock enable is an output
							(0<<vFDBInt)|\			; Front Desk bus interrupt is an input
							(1<<vFDesk1)|\			; FDB state bit 0 is an output
							(1<<vFDesk2)|\			; FDB state bit 1 is an output
							(1<<vSCSIMask)|\		; SCSI IRQ mask is an output
							(1<<vSndEnb)			; sound enable is an output

vBInit 			EQU 		(1<<vRTCData)|\			; real time clock data is one
							(1<<vRTCClk)|\			; real time clock clock is high
							(1<<vRTCEnb)|\			; clock initially disabled
							(0<<vFDBInt)|\			; Front Desk bus interrupt is an input
							(1<<vFDesk1)|\			; FDB state bit 0 is initially state 3
							(1<<vFDesk2)|\			; FDB state bit 1 is initially state 3
							(1<<vSCSIMask)|\		; SCSI IRQ mask is initially masked
							(1<<vSndEnb)			; sound is disabled


; === Hardware Base Addresses ===

VBase 			EQU 		$EFE1FE   				; VIA base address
AVBufA			EQU 		VBase+vBufA 			; VIA buffer A
AVBufB			EQU 		VBase+vBufB  			; VIA buffer B

SCCRBase  		EQU 		$9FFFF8   				; SCC base read address
SCCWBase  		EQU 		$BFFFF9   				; SCC base write address
sccWrite  		EQU 		SCCWBase-SCCRBase		; general offset for write from read

SCSIRd			EQU 		$5FF000   				; base addr SCSI interface - READ
SCSIWr			EQU 		$5FF001   				; base addr SCSI interface - WRITE
MacSCSIBase   	EQU 		$5FF000   				; base addr SCSI READ interface
MacSCSIDMA		EQU 		$5FF200   				; base addr SCSI DMA
MacSCSIHsk		EQU 		$5FF200   				; base addr SCSI handshake
wrOffs			EQU 		SCSIWr-SCSIRd			; write addrs are +1 to the read base

SoundLow  		EQU 		$3FFD00   				; sound buffer start address
snd2MemTop		EQU 		$300  					; SoundLow to Memtop

PWMBuffer 		EQU 		$3FFD01   				; PWM bytes are low bytes
pwm2MemTop		EQU 		$2FF  					; PWMBuffer to MemTop

; === Video Parameters ===

ScreenLow 		EQU 		$3FA700   				; top of screen screen address
scrn2MemTop   	EQU 		$5900 					; ScreenBase to Memtop

; === Hardware Base Addresses ===

romBSize  		EQU 		$40000    				; 256K bytes in present ROM
ROMStart  		EQU 		$400000   				; starting address of ROM code

DBase 			EQU 		$DFE1FE   				; disk address base

; === System Software Information ===
bufWorldSize  	EQU 		scrn2MemTop   			; total size of the BufPtr world

oneSecConst   	EQU 		2 						; gets converted to $20000 for onesec constant
numOsTrap 		EQU 		256   					; number of os traps
ToolTable 		EQU 		$0E00 					; start of toolbox trap table

numTbTrap 		EQU 		512   					; number of toolbox traps
numTrapMask   	EQU 		numTbTrap-1				; mask for number of tb traps
HeapStart 		EQU 		$1600 					; Aladdin starting point

defSysHeap		EQU 		$18000    				; Default size of the system heap
nDfltStackSize	EQU 		$2000 					; Default stack size


;===========================================;
;	Macintosh Portable Hardware Information	;
;===========================================;

hwCfgBits 		EQU 		hwCmSCSI++hwCmClock++hwCmADB++hwCbPwrMgr				; <2.8>
machine   		EQU 		3
rom85Bits 		EQU 		$7F   					; New ROMs, No Power Off.


; === Interrupt Masks ===
hiIntMask 		EQU 		$0700					; programmer switch only
sccIntMask		EQU 		$0200 					; SCC interrupt Level		<1.5>
sccEnblMask   	EQU 		$F9FF 					; mask to enable SCC interrupts
viaIntMask		EQU 		$0100 					; mask for VIA (and VBL) interrupts
loIntMask 		EQU 		$0100


; === VIA1 BUFFER A ===
													; 68000 <-> PowerMgr data bus
vAIn  			EQU 		$00   					; VBufA output bits (all inputs)
vAOut 			EQU 		$FF   					; VBufA output bits (all outputs)
vAInit			EQU 		$00   					; VBufA initial values


; === VIA1 BUFFER B ===
vPMreq			EQU 		0 						; Power manager handshake request
vPMack			EQU 		1 						; Power manager handshake acknowledge
vTestJ			EQU 		2 						; Test jumper
;vSync 			EQU 		3 						; Synchronous modem
vDriveSel 		EQU 		4 						; int drive select (lower drive when 1)
;vHeadSel  		EQU 		5 						; head select line for Sony
vStereo   		EQU 		6 						; Stereo sound enable
;vSCCWrReq 		EQU 		7 						; SCC write/request line		(input)
;vSndEnb   		EQU 		7 						; /sound enable (reset when 1)	(output)

vBOut 			EQU 		(1<<vPMreq)|\			; Power mgr handshake request is an output
							(0<<vPMack)|\			; Power mgr handshake acknowledge is an input
							(0<<vTestJ)|\			; Test jumper is an input
							(1<<vSync)|\			; Synchronous modem is an output
							(1<<vDriveSel)|\		; int drive select is an output
							(1<<vHeadSel)|\			; head select line is an output
							(0<<vStereo)|\			; Stereo sound detect is an input
							(1<<vSndEnb)			; sound enable is an output

vBInit 			EQU 		(1<<vPMreq)|\			; Power mgr handshake not requesting
							(1<<vPMack)|\			; Power mgr handshake acknowledge is an input
							(1<<vTestJ)|\			; Test jumper is an input
							(1<<vSync)|\			; Synchronous modem disabled (active low)
							(1<<vDriveSel)|\		; lower floppy drive selected
							(0<<vHeadSel)|\			; head select line is an output
							(1<<vStereo)|\			; Stereo sound detect is an input
							(1<<vSndEnb)			; sound is disabled

vBufD 			EQU 		vBufB 					; disk head select is buffer B


; === Hardware Base Addresses ===

VBase 			EQU 		$F70000   				; VIA base address
AVBufA			EQU 		VBase+vBufA 			; VIA buffer A
AVBufB			EQU 		VBase+vBufB  			; VIA buffer B

SCCRBase  		EQU 		$FD0000   				; SCC base read address
SCCWBase  		EQU 		$FD8000   				; SCC base write address
sccWrite  		EQU 		SCCWBase-SCCRBase		; general offset for write from read

SCSIRd			EQU 		$F90000   				; base address of SCSI interface - READ
SCSIWr			EQU 		$F90001   				; base address of SCSI interface - WRITE
MacSCSIBase   	EQU 		$F90000   				; base address of SCSI READ interface
MacSCSIDMA		EQU 		$F90200   				; base address of SCSI DMA
MacSCSIHsk		EQU 		$F90200   				; base address of SCSI handshake
wrOffs			EQU 		SCSIWr-SCSIRd			; write addrs are +1 to the read base

SndBase   		EQU 		$FB0000   				; sound chip's base address

MapperBase		EQU 		$FC0000   				; Mapper RAM base address

RAMconfigBase 	EQU 		$FE0200   				; Internal/external RAM control register
RAMconfigInit	EQU			$0006					; Init test register						<v2.6>

; === Video Parameters ===

ScreenLow 		EQU 		$FA8000   				; top of screen screen address
hcVideoSize   	EQU 		$8000 					; 32k of video memory
HcVideoStart  	EQU 		ScreenLow
HcVideoEnd		EQU 		HcVideoStart+hcVideoSize
NTSCMaxX		EQU			512						; NTSC output is narrow
NTSCOffset		EQU			8						;  and centered
LCDmode			EQU			0						; Normal built in screen
Mac2mode		EQU			1						; Custom screen for Mac2
NTSCmode		EQU			2						; NTSC output for Topanga

; === Hardware Base Addresses ===

romBSize  		EQU 		$40000    				; 256K bytes in present ROM
ROMStart  		EQU 		$900000   				; starting address of ROM code

DBase 			EQU 		$F6E1FF   				; disk address base

AccessBase		EQU 		$FC0200   				; SLIM card DTACK counter load address (what a mouthful)
SLIMinserted	EQU			3						; SLIMs inserted bit 						<v2.6>

; === System Software Information ===
snd2MemTop		EQU 		$300  					; SoundLow to Memtop
pwm2MemTop		EQU 		$2FF  					; PWMBuffer to MemTop
bufWorldSize  	EQU 		snd2MemTop    			; total size of the BufPtr world

oneSecConst   	EQU 		2 						; gets converted to $20000 for onesec constant
numOsTrap 		EQU 		256   					; number of os traps
ToolTable 		EQU 		$0E00 					; start of toolbox trap table
numTbTrap 		EQU 		1024   					; number of toolbox traps
numTrapMask   	EQU 		numTbTrap-1				; mask for number of tb traps
HeapStart 		EQU 		$1E00 					; Portable starting point	<1.2>
DefSysHeap		EQU 		$18000    				; Default size of the system heap
NDfltStackSize	EQU 		$2000 					; Default stack size


;===================================================;
;	Universal 16 bit Macintosh Hardware Information	;
;===================================================;


; === Interrupt Masks ===
hiIntMask 		EQU 		$0700					; programmer switch only
sccIntMask		EQU 		$0200 					; SCC interrupt Level		<1.5>
sccEnblMask   	EQU 		$F9FF 					; mask to enable SCC interrupts
viaIntMask		EQU 		$0100 					; mask for VIA (and VBL) interrupts
loIntMask 		EQU 		$0100

; === VIA1 BUFFER A ===
;vSound			EQU 		$7    					; sound volume bits (0..2)
vSndPg2   		EQU 		3 						; select sound page 2 if 0
;vSync 			EQU 		3 						; Synchronous modem
;vOverlay  		EQU 		4 						; overlay bit (overlay when 1)
;vDriveSel 		EQU 		4 						; int drive select (lower drive when 1)
;vHeadSel  		EQU 		5 						; head select line for Sony
vPage2			EQU 		6 						; select video page 2 if 0
;vSCCWrReq 		EQU 		7 						; SCC write/request line

; === VIA1 BUFFER B ===
;vRTCData  		EQU 		0 						; real time clock data
;vRTCClk   		EQU 		1 						; real time clock clock pulses
;vRTCEnb   		EQU 		2 						; clock enable (0 for enable)
vSW   			EQU 		3 						; mouse switch (0 when down)
;vFDBInt   		EQU 		3 						; Front Desk bus interrupt
vX2   			EQU 		4 						; mouse X level
;vFDesk1   		EQU 		4 						; Front Desk bus state bit 0
vY2   			EQU 		5 						; mouse Y level
;vFDesk2   		EQU 		5 						; Front Desk bus state bit 1
vH4   			EQU 		6 						; horizontal sync
vSCSIMask 		EQU 		6 						; SCSI IRQ mask
;vSndEnb   		EQU 		7 						; /sound enable (reset when 1)

vPMreq			EQU 		0 						; Power manager handshake request
vPMack			EQU 		1 						; Power manager handshake acknowledge
vTestJ			EQU 		2 						; Test jumper
;vSync 			EQU 		3 						; Synchronous modem
;vDriveSel 		EQU 		4 						; int drive select (lower drive when 1)
;vHeadSel  		EQU 		5 						; head select line for Sony
vStereo   		EQU 		6 						; Stereo sound enable
;vSCCWrReq 		EQU 		7 						; SCC write/request line		(input)

; === VIA1 BUFFER A/B ===
;vSync 			EQU 		3 						; Synchronous modem						<3.1>
vDriveSel 		EQU 		4 						; int drive select (lower drive when 1)	<3.1>
;vHeadSel  		EQU 		5 						; head select line for Sony				<3.1>
;vSCCWrReq 		EQU 		7 						; SCC write/request line				<3.1>

; === Hardware Base Addresses ===

wrOffs			EQU 		1						; write addrs are +1 to the read base

; === System Software Information ===

numOsTrap 		EQU 		256   					; number of os traps
ToolTable 		EQU 		$0E00 					; start of toolbox trap table
numTbTrap 		EQU 		1024   					; number of toolbox traps
numTrapMask   	EQU 		numTbTrap-1				; mask for number of tb traps
HeapStart 		EQU 		$1E00 					; Laguna starting point	<1.2>
DefSysHeap		EQU 		$18000    				; Default size of the system heap
NDfltStackSize	EQU 		$2000 					; Default stack size



  				ENDIF								; ForAmusementOnly

HardwarePrivate EQU 		1

  				ENDIF								; __INCLUDINGHARDWAREPRIVATEEQU__

