;
;	File:		STCritTests.a
;
;	Contains:	This file includes the critical test routines run at system start up.  There are also
;				some routines not run at startup but which are available to the Test Manager through 
;				the TJump Test Table.
;
;	Copyright:	© 1983-1991 by Apple Computer, Inc., all rights reserved.
;
;	Change History (most recent first):
;
;		 <2>	 9/18/91	JSM		Add a header.
;	   <2.6>	 7/17/89	GMR		Added extra pass through memory if parity exists for Mod3Test
;									and RevMod3Test.
;	   <2.5>	 7/15/89	GMR		Added Gary D's optimized Mod3Test and RevMod3Test.
;	   <2.4>	  7/8/89	CCH		Modified to work with Romulator.
;	   <2.3>	 6/26/89	GMR		Changed to use (sp) instead of sp when referencing memory chunk
;									table, to work with new size memory output.
;	   <2.2>	 6/20/89	rle		create stub call to size memory--need to return pointer to table
;									in d6 for board burn in
;	   <2.1>	 6/11/89	GMR		Changed ref's to BaseOfRom to be BigLEA's.
;	   <2.0>	 5/26/89	rle		cleaned up file to remove obsolete code; address line test now
;									runs the same for all machines (depends upon memory size
;									location table)
;	   <1.9>	 5/16/89	rle		modified mod3 and revmod3 tests to run an additional pass for
;									parity ram testing when parity ram is installed; modified
;									address line test to function correctly for bank a only/bank b
;									only/bank a and bank b systems; added dynamic bus sizing test
;	   <1.8>	 4/11/89	rle		import BaseOfRom for stub file builds
;	   <1.7>	 3/28/89	rle		now uses equates from "STEqu.a"
;	   <1.6>	  3/6/89	GGD		Modified to use pc-relative BaseOfROM instead of hard coded
;									ROMStart equate to make code less hardware dependent.
;	   <1.5>	 2/21/89	rwh		fixed AddrLineTest to not use MacII code for FourSquare.
;	   <1.4>	 2/16/89	rwh		added support for Fitch Memory Controller rev 1. When FMC2
;									arrives, may need to change these for a contiguous physical
;									memory model.
;	   <1.3>	 2/10/89	RLE		update equates to support minimal f-19 build
;	   <1.2>	  2/6/89	RLE		replaced NuMac conditionals with more generic identifiers
;	   <1.1>	  2/2/89	RLE		STCritTests.a is now an independent file, responsible for
;									importting and exportting the procedures it needs and others
;									need; fixed a lot of conditional statements to make them more
;									generic and less CPU-specific; adjusted address line test to run
;									on MDU-based machines; still need to make it run from bank B
;	   <1.0>	 1/11/89	RLE		derived from version 1.4 of StartTest.a modified version history
;									markers for all old versions to start with "[" instead of
;									"<"--this allows changes in STCritTeststo be tracked separately;
;									the SizeMemory routines were removed from this section; they are
;									now under OS group control; we just jump to SizeMemory to find
;									out the top of logical/physical memory
;
	
		PRINT	OFF
		LOAD		'StandardEqu.d'
		INCLUDE		'HardwareEqu.a'
		INCLUDE		'STEqu.a'	;					<v1.7>

		IF hasIopScc THEN		;					<v1.1>
    		  INCLUDE	'IOPequ.a'
		ENDIF		

		PRINT	ON
			
		IF CPU = 20 THEN
		  MACHINE MC68020
		ENDIF
		
		IF CPU = 30 THEN
		  MACHINE MC68030
		ENDIF
		
		STRING	ASIS

CritProc	PROC				;					<v1.1>

		EXPORT	SizeMem			;					<v2.2>
		EXPORT	Mod3Test
		EXPORT	RevMod3Test
		EXPORT	ExtRAMTest
		EXPORT	AddrLineTest
		EXPORT	DataBusTest
		EXPORT	StartUpROMTest
		EXPORT	RomTest
		EXPORT	NoTest
		
		IF CPU > 10 THEN		;					<v1.9>
		EXPORT	dynamic_bussize_test	;					<v1.9>
		ENDIF				;					<v1.9>
		
		IMPORT	BaseOfRom		;					<v1.8>
		IMPORT	SizeMemory		;					<v2.2>
		IMPORT	RomLoc			;					<v2.4>
		
		IF hasMac2Via2 THEN		;					<v1.1>
		IMPORT	BankASize		;					<v1.1>
		ENDIF				;					<v1.1>
		
;---------------------------------------------------------------------------		<v2.2>
;  This routine calls the OS SizeMemory routine, and returns the pointer		<v2.2>
;  to the memory location table in register d6.  This is required for use		<v2.2>
;  with the test manager serial interface for board burn in.				<v2.2>
;---------------------------------------------------------------------------		<v2.2>
;
SizeMem				;							<v2.2>
	move.l	a6,a4		;save return address (a4 not destroyed)			<v2.2>
	bsr6	SizeMemory	;make OS call						<v2.2>
	move.l	(sp),d6		;return start of memory location table			<v2.2><v2.3>
	jmp	(a4)		;go back home						<v2.2>

	
;
;---------------------------------------------------------------------------
;  Data bus test walks 0 and 1 bits across the data buss to verify that
;  memory can be accessed.
;
;  On entry, a6 = return to caller.
;	     a0 = test address
;
;  On exit, d6 = failed bit mask.
;
;  Register usage:
;
;	d0 =	data bit register
;	d1 =	data bit register
;	d2 =	loop counter
;
;	a0 =	address pointer
;
;  This test assumes interrupts are masked out with #$2500.
;---------------------------------------------------------------------------
;
DataBusTest
	moveq	#1,d0			;first data pattern is 1 in 0's
	moveq	#-2,d1			;next data pattern, $FFFFFFFE, 0 in 1's	[C660>/[C798>
	
	move.w	#$00FF,d2		;loop counter = 256
		
@10	movem.l	d0-d1,(a0)		;write test patterns

	eor.l	d0,(a0)			;read and write low test location
	or.l	(a0),d6			;if any bad bits, or to fail reg
	
	eor.l	d1,4(a0)		;read and write high test loc
	or.l	4(a0),d6		;if any bad bits, or to fail reg
	
	rol.l	#1,d0			;rotate the bit		
	rol.l	#1,d1			;rotate the bit
	
	dbra	d2,@10			;continue until bit shifted to carry
		
	
	IF CPU = 00 THEN	;					<v1.1>
	
	move.l	d6,d0			;copy of longword bad bits
	swap	d0			;bad bit mask to lower word
	or.w	d0,d6			;
	and.l	#$0000FFFF,d6		;only lower word		[A322>
	
	ENDIF
	
	jmp	(a6)			;return to caller, no errors


;
;---------------------------------------------------------------------------
;  StartUpROMTest is run normally only at system startup.  It uses the longword
;  checksum residing in location 0.  The Test Manager also supports a checksum test
;  that uses the 2 or 4 sums residing in locations ROMStart+$0030 through $003F
;  as separate sums for each ROM chip.
;
;---------------------------------------------------------------------------
;
StartUpROMTest
	moveq	#0,d0			;clear checksum accumulator
	moveq	#0,d1			;clear scratch
	
	BigLea	BaseOfROM,a0		;point at ROM start, expected checksum	<v1.6><2.1>
	move.l	(a0)+,d4		;load up expected
	move.l	#myROMsize,d3		;get appropriate size of ROM image less exp sum size
	
ROMLoop
	move.w	(a0)+,d0		;fetch a ROM word
	add.l	d0,d1			;add to checksum
	subq.l	#1,d3			;count a loop
	bne.s	ROMLoop			;until done...
		
	nop				;some nops for debug (leave these here for emulator use)	
	nop				;some nops for debug	
	
	eor.l	d4,d1			;result should be zero
CkSumBr	beq.s	@10

	IF forRomulator THEN		;				<2.4>
	TestInRam   A0			; are we running in RAM? 	<2.4>
	bne.s	@10			; if so, force chksum good	<2.4>
	ENDIF				;				<2.4>
	
	move.w	#$FFFF,d6		;set a failed code in result register [A310>

@10	jmp	(a6)			;and exit
	
	
;---------------------------------------------------------------------------
;
;  Mod3Test is a fast test of the entire memory array.
;
;  Inputs:	a0 = bottom memory area to test
;			a1 = top of memory area to test + 1
;			a6 = return to caller
;
;  Outputs:	d6.l is a failed bit mask
;	    	a0,a1 still pointing to bottom and top of area to test
;
;  Register usage:
;
;	d0 =	test data register
;	d1 =	test data register
;	d2 =	test data register
;	d3 =	test data register
;	d4 =	test data register
;	d5 =	test data register
;	d6 =	failed bit mask
;
;	a0 =	pointer to bottom test area
;	a1 =	pointer to top of test area
;	a2 =	copy of a0
;	a3 =	unsued	
;	a4 = 	unused
;	a5 =	unused
;
;
;  This test writes a modulo 3 pattern to all of memory, then shifts the
;  pattern by writing the appropriate starting pattern, reading the next
;  in memory, exclusive oring this with the previous location, then writing
;  it back to the same location.  Any errors while reading (or writing) are
;  propagated to the end of memory.  At the end of the test the last 3 long
;  word entries must be as expected or an error has occurred.
;
;  In order to properly determine the failing bank with this test, it is best
;  to call the test with a0/a1 set to test one bank at a time.
;
;  There are three cases that can occur at the end of memory, depending on
;  what size memory is being tested.  Observe the last three long words:
;
;  Case 0: 
;
;	(LAST-12) $BD6BD6BD (LAST-8) $D6BD6BD6 (LAST-4) $6BD6BD6B
;		
;  Case 1: 
;
;	(LAST-12) $D6BD6BD6 (LAST-8) $6BD6BD6B (LAST-4) $BD6BD6BD
;		
;  Case 2: 
;
;	(LAST-12) $6BD6BD6B (LAST-8) $BD6BD6BD (LAST-4) $D6BD6BD6
;
;  The last three longs are compared against the appropriate table entries
;  based on the case determined when memory is filled the first time.
;  On exit, D6 reflects any bad bits found.
;
;  This test should only be called with a0/a1 pointing at mod 4 bounds.  The
;  code assumes this and tests accordingly on 32 bit longword bounds, however
;  calling this test with other bounds will result in a bus error since non-
;  existent memory may be addressed. Also, upper - lower must be >= 24.
;
;  This test assumes interrupts are masked out with #$2500.
;---------------------------------------------------------------------------
		align	4
Mod3Test					;					<2.5>

@FillRegs	reg	d0/d1/d2/d3/d4/d5
	movem.l	Mod3Pat,@FillRegs		;load up 2 copies of the test patterns
	movea.l	a0,a2				; starting address
	suba.w	#120,a1				; subtract slop from loop terminator
	bra.s	@Fill120Start
@Fill120Loop
	movem.l	@FillRegs,(a2)
	movem.l	@FillRegs,24(a2)
	movem.l	@FillRegs,48(a2)
	movem.l	@FillRegs,72(a2)
	movem.l	@FillRegs,96(a2)
	adda.w	#120,a2				; point past block just written
@Fill120Start
	cmpa.l	a1,a2
	ble.s	@Fill120Loop			; fill until < 120 bytes remaining

	suba.w	#12-120,a1			; subtract slop from loop terminator
	moveq.l	#12,d5				; address increment value
	bra.s	@Fill12Start
@Fill12Loop
	movem.l	d0-d2,(a2)
	adda.w	d5,a2				; point past bytes just written
@Fill12Start
	cmpa.l	a1,a2
	ble.s	@Fill12Loop			; fill until < 12 bytes remaining
	adda.w	d5,a1				; restore end address

; Now pick up the last maximum 8 bytes not written

	moveq	#4,d4				;case 0, offset = 4
	cmpa.l	a2,a1				;maybe it came out even?
	beq.s	@FillDone			;done filling memory

	move.l	d0,(a2)+			;write one more long
	moveq	#8,d4				;case 1, offset = 8
	cmpa.l	a2,a1				;compare against real mem top
	beq.s	@FillDone			;done filling memory
	
	move.l	d1,(a2)+			;write one more long
	moveq	#0,d4				;case 2, offset = 0

@FillDone
	movea.l	a0,a2				;copy starting address
	
; Memory is filled with the mod 3 pattern.  The pattern is sequenced through
; three iterations for the test by exclusive oring in the following manner. 		

	move.l	a1,d3				;first get the top boundary
	sub.l	a0,d3				; = number of bytes to test
	subq.l	#4,d3				;less 4 bytes
	moveq.l	#$3F,d2				; mask for index into loop
	and.w	d3,d2				; compute the index
	neg.w	d2				; index backwards
	lsr.l	#6,d3				; 64 bytes per loop

	eor.l	d1,(a2)				;write starting pattern
	addi.l	#$FFFFFFFF,d5			;help any floating bits float up
	jmp	@61(d2.w)			; jump to the correct starting position

@60	move.l	(a2)+,d2			;read a pattern
	eor.l	d2,(a2)				;generate next pattern
	move.l	(a2)+,d2			;read a pattern
	eor.l	d2,(a2)				;generate next pattern
	move.l	(a2)+,d2			;read a pattern
	eor.l	d2,(a2)				;generate next pattern
	move.l	(a2)+,d2			;read a pattern
	eor.l	d2,(a2)				;generate next pattern
	move.l	(a2)+,d2			;read a pattern
	eor.l	d2,(a2)				;generate next pattern
	move.l	(a2)+,d2			;read a pattern
	eor.l	d2,(a2)				;generate next pattern
	move.l	(a2)+,d2			;read a pattern
	eor.l	d2,(a2)				;generate next pattern
	move.l	(a2)+,d2			;read a pattern
	eor.l	d2,(a2)				;generate next pattern
	move.l	(a2)+,d2			;read a pattern
	eor.l	d2,(a2)				;generate next pattern
	move.l	(a2)+,d2			;read a pattern
	eor.l	d2,(a2)				;generate next pattern
	move.l	(a2)+,d2			;read a pattern
	eor.l	d2,(a2)				;generate next pattern
	move.l	(a2)+,d2			;read a pattern
	eor.l	d2,(a2)				;generate next pattern
	move.l	(a2)+,d2			;read a pattern
	eor.l	d2,(a2)				;generate next pattern
	move.l	(a2)+,d2			;read a pattern
	eor.l	d2,(a2)				;generate next pattern
	move.l	(a2)+,d2			;read a pattern
	eor.l	d2,(a2)				;generate next pattern
	move.l	(a2)+,d2			;read a pattern
	eor.l	d2,(a2)				;generate next pattern
@61	dbra	d3,@60				; until done
	subi.l	#$00010000,d3			; adjust outer loop count
	bpl.s	@60

	IF hasRBV THEN				;						<v2.6>
	cmp.w	#ErrParRAM,d7			;have we finished parity ram test?		<v2.6>
	beq	@exit				;yep, we're outta here				<v2.6>
	ENDIF					;						<v2.6>

;  Now the final pass through the test area.

	cmp.l	d0,d1				; is this the second pass
	beq.s	@62				; if so, we're done
	move.l	d0,d1				; use pattern from D0 on final pass
	bra.s	@FillDone			; make another pass
@62

; Now pick up the appropriate 3 longs nearest the end point.  These should	
; match patterns based on the case in d4, which was set up in the memory
; fill earlier. If any error occurred during eoring, it is propagated to the end.

	movem.l	-12(a1),d0-d2			;pickup last 12 bytes

; and remember d4 is still set up..

	movem.l	Mod3Pat(d4.w),d3-d5		;get original test patterns	
	
	eor.l	d3,d0
	eor.l	d4,d1
	eor.l	d5,d2		
	or.l	d2,d0
	or.l	d1,d0				;compile final "bad bit" mask
	
	or.l	d0,d6				;record for caller
	
	IF CPU=00 THEN				;											<1.1>
	swap	d0				;bad bit mask to lower word
	or.w	d0,d6				;
	and.l	#$0000FFFF,d6			;only pass back lower word mask	
	ENDIF

	IF hasRBV THEN				;						<v2.6>
	btst	#parity,d7			;determine need for parity ram test		<v2.6>
	beq.s	@exit				;no parity ram, we're done			<v2.6>
	move.w	#ErrParRAM,d7			;set parity ram error code			<v2.6>
	movem.l	Mod3Pat+4,@FillRegs		;load up 2 copies of the test patterns		<v2.6>
	bra	@FillDone			;do one more pass if parity ram installed	<v2.6>
	ENDIF					;						<v2.6>
	
@exit	RTS6					;and return
		
; Table of test and compare patterns

Mod3Pat			
	dc.l	$6DB6DB6D			;case 2, offset = 0
	dc.l	$B6DB6DB6			;case 0, offset = 4
	dc.l	$DB6DB6DB			;case 1, offset = 8
	dc.l	$6DB6DB6D
	dc.l	$B6DB6DB6		
	dc.l	$DB6DB6DB		
	dc.l	$B6DB6DB6			
		
;---------------------------------------------------------------------------
;
;  RevMod3Test is a fast test of the entire memory array, very similar to the
;  Mod3Test above.  It tests memory with the test addresses generated in the
;  reverse direction.
;
;  changed reg a3 to a2 in following code to make it like mod3test	
;  and to free-up a3 for other stuff
;
;  Inputs:	a0 = bottom memory area to test
;			a1 = top of memory area to test + 1
;			a6 = return to caller
;
;  Outputs:	d6.l is a failed bit mask
;	    	a0,a1 still pointing to bottom and top of area to test
;
;  Register usage:
;
;	d0 =	test data register
;	d1 =	test data register
;	d2 =	test data register
;	d3 =	test data register
;	d4 =	test data register
;	d5 =	test data register
;	d6 =	failed bit mask
;
;	a0 =	pointer to bottom test area
;	a1 =	pointer to top of test area
;	a2 =	copy of a1
;	a3 =	unused
;	a4 =	unused
;	a5 =	unused
;
;  This test writes a modulo 3 pattern to all of memory, then shifts the
;  pattern by writing the appropriate starting pattern, reading the next
;  in memory, exclusive oring this with the previous location, then writing
;  it back to the same location.  Any errors while reading (or writing) are
;  propagated to the beginning of memory.  At the end of the test the first 3
;  long word entries must be as expected or an error has occurred.
;
;  In order to properly determine the failing bank with this test, it is best
;  to call the test with a0/a1 set to test one bank at a time.
;
;  There are three cases that can occur at the end of memory, depending on
;  what size memory is being tested.  Observe the last three long words:
;
;  Case 0: must write 3 more longs to fill memory, table offset = 8 for
;	   correct final compare patterns.
;
;	(FIRST+0) $6BD6BD6B (FIRST+4) $BD6BD6BD (FIRST+8) $D6BD6BD6
;		
;  Case 1: must write 1 more long to fill memory, table offset = 4 for
;	   correct final compare patterns.
;
;	(FIRST+0) $D6BD6BD6 (FIRST+4) $6BD6BD6B (FIRST+8) $BD6BD6BD
;		
;  Case 2: must write 2 more longs to fill memory, table offset = 0 for
;	   correct final compare patterns.
;
;	(FIRST+0) $BD6BD6BD (FIRST+4) $D6BD6BD6 (FIRST+8) $6BD6BD6B
;
;  The first three longs are compared against the appropriate table entries
;  based on the case determined when memory is filled the first time.
;  On exit, D6 reflects any bad bits found.
;
;  This test should only be called with a0/a1 pointing at mod 4 bounds.  The
;  code assumes this and tests accordingly on 32 bit longword bounds, however
;  calling this test with other bounds will result in a bus error since non-
;  existent memory may be addressed.  Also, upper - lower must be >= 24.
;
;  This test assumes interrupts are masked out with #$2500.
;
;---------------------------------------------------------------------------
	align	4
RevMod3Test					;					<2.5>

@FillRegs	reg	d0/d1/d2/d3/d4/d5
	movem.l	RevMod3Pat,@FillRegs		;load up 2 copies of the test patterns
	movea.l	a1,a2				; starting address
	adda.w	#120,a0				; add slop to loop terminator
	bra.s	@Fill120Start
@Fill120Loop
	movem.l	@FillRegs,-(a2)
	movem.l	@FillRegs,-(a2)
	movem.l	@FillRegs,-(a2)
	movem.l	@FillRegs,-(a2)
	movem.l	@FillRegs,-(a2)
@Fill120Start
	cmpa.l	a2,a0
	ble.s	@Fill120Loop			; fill until < 120 bytes remaining

	adda.w	#12-120,a0			; add slop to loop terminator
	bra.s	@Fill12Start
@Fill12Loop
	movem.l	d0-d2,-(a2)
@Fill12Start
	cmpa.l	a2,a0
	ble.s	@Fill12Loop			; fill until < 12 bytes remaining
	suba.w	#12,a0				; restore bottom address

; Now pick up the last maximum 8 bytes not written

	moveq	#8,d4				;case 0, offset = 8
	cmpa.l	a2,a0				;compare against real mem bottom
	beq.s	@FillDone			;done filling memory
	
	move.l	d2,-(a2)			;write one more long
	moveq	#4,d4				;case 1, offset = 4
	cmpa.l	a2,a0				;compare against real mem bottom
	beq.s	@FillDone			;done filling memory
		
	move.l	d1,-(a2)			;write one more long
	moveq	#0,d4				;case 2, offset = 0

@FillDone		
	movea.l	a1,a2				;copy ending address
	subq.l	#4,a2				;adjust to last longint
	
; Memory is filled with the mod 3 pattern.  The pattern is sequenced through
; three iterations for the test by exclusive oring in the following manner. 		

	move.l	a2,d3				;first get the top boundary
	sub.l	a0,d3				; = number of bytes to test
	moveq.l	#$3F,d0				; mask for index into loop
	and.w	d3,d0				; compute the index
	neg.w	d0				; index backwards
	lsr.l	#6,d3				; 64 bytes per loop

	eor.l	d1,(a2)				;write starting pattern
	addi.l	#$FFFFFFFF,d5			;help any floating bits float up
	jmp	@61(d0.w)			; jump to the correct starting position

@60	move.l	(a2),d0				;read a pattern
	eor.l	d0,-(a2)			;generate next pattern
	move.l	(a2),d0				;read a pattern
	eor.l	d0,-(a2)			;generate next pattern
	move.l	(a2),d0				;read a pattern
	eor.l	d0,-(a2)			;generate next pattern
	move.l	(a2),d0				;read a pattern
	eor.l	d0,-(a2)			;generate next pattern
	move.l	(a2),d0				;read a pattern
	eor.l	d0,-(a2)			;generate next pattern
	move.l	(a2),d0				;read a pattern
	eor.l	d0,-(a2)			;generate next pattern
	move.l	(a2),d0				;read a pattern
	eor.l	d0,-(a2)			;generate next pattern
	move.l	(a2),d0				;read a pattern
	eor.l	d0,-(a2)			;generate next pattern
	move.l	(a2),d0				;read a pattern
	eor.l	d0,-(a2)			;generate next pattern
	move.l	(a2),d0				;read a pattern
	eor.l	d0,-(a2)			;generate next pattern
	move.l	(a2),d0				;read a pattern
	eor.l	d0,-(a2)			;generate next pattern
	move.l	(a2),d0				;read a pattern
	eor.l	d0,-(a2)			;generate next pattern
	move.l	(a2),d0				;read a pattern
	eor.l	d0,-(a2)			;generate next pattern
	move.l	(a2),d0				;read a pattern
	eor.l	d0,-(a2)			;generate next pattern
	move.l	(a2),d0				;read a pattern
	eor.l	d0,-(a2)			;generate next pattern
	move.l	(a2),d0				;read a pattern
	eor.l	d0,-(a2)			;generate next pattern
@61		dbra	d3,@60			; until done
	subi.l	#$00010000,d3			; adjust outer loop count
	bpl.s	@60

	IF hasRBV THEN				;						<v2.6>
	cmp.w	#ErrParRAM,d7			;have we finished parity ram test?		<v2.6>
	beq	@exit				;yep, we're outta here				<v2.6>
	ENDIF					;						<v2.6>

;  Now the final pass through the test area.

	cmp.l	d2,d1				; is this the second pass
	beq.s	@62				; if so, we're done
	move.l	d2,d1				; use pattern from D2 on final pass
	bra.s	@FillDone			; make another pass
@62

; Now pick up the appropriate 3 longs nearest the end point.  These should	
; match patterns based on the case in d4. If any error occurred during
; eoring, it is propagated through to the end.

	movem.l	(a0),d0-d2			;pickup first 12 bytes
	movem.l	RevMod3Pat(d4.w),d3-d5		;get original test patterns
	
	eor.l	d3,d0
	eor.l	d4,d1
	eor.l	d5,d2		
	or.l	d2,d0
	or.l	d1,d0				;compile final "bad bit" mask
	
	or.l	d0,d6				;record for caller
	
	IF CPU=00 THEN					;											<1.1>
	swap	d0				;bad bit mask to lower word
	or.w	d0,d6				;
	and.l	#$0000FFFF,d6			;only pass back lower word mask	
	ENDIF
	
	IF hasRBV THEN				;						<v2.6>
	btst	#parity,d7			;determine need for parity ram test		<v2.6>
	beq.s	@exit				;no parity ram, we're done			<v2.6>
	move.w	#ErrParRAM,d7			;set parity ram error code			<v2.6>
	movem.l	RevMod3Pat+4,@FillRegs		;load up 2 copies of the test patterns		<v2.6>
	bra	@FillDone			;do one more pass if parity ram installed	<v2.6>
	ENDIF					;						<v2.6>
	
@exit	RTS6					;and return
		
RevMod3Pat			
	dc.l	$6DB6DB6D			;case 2, offset = 0
	dc.l	$B6DB6DB6			;case 0, offset = 4
	dc.l	$DB6DB6DB			;case 1, offset = 8
	dc.l	$6DB6DB6D
	dc.l	$B6DB6DB6		
	dc.l	$DB6DB6DB		
	dc.l	$B6DB6DB6
	

;---------------------------------------------------------------------------
;  RomTest does a ROM checksum on the individual ROMs and returns an error
;  code in d6 indicating any failed ROMs.  The checksums are located in the
;  ROMs at dedicated addresses, forever defined to be as follows:
;
;		ROM 0	at ROMStart + $0030 - $0033
;		ROM 1	at ROMStart + $0034 - $0037
;		ROM 2	at ROMStart + $0038 - $003B
;		ROM 3	at ROMStart + $003C - $003F
;
;  On entry:	d6 =	0
;  On exit:	d6 =	$0000000X, where X = abcd, and a means ROM 3, 
;			b means ROM 2, c means ROM 1, and d means ROM 0
;
;  This test assumes interrupts are masked out with #$2500.
;
;---------------------------------------------------------------------------
;
RomTest	
	lea	myROMSums,a1		;point to end of first area	
	BigLea	BaseOfROM,a0		;point to start of ROM code		<v1.6><2.1>
	move.l	(a0)+,d0		;discard first long word of ROM
	
	move.l	a1,a2			;keep a copy			
	
	clr.l	d0			;clear summing registers
	clr.l	d1
	clr.l	d2
	clr.l	d3
	clr.l	d4
	clr.l	d5
			
	IF CPU = 00 THEN	;						<v1.2>
	
@10	move.w	(a0)+,d5		;read out 2 bytes
	move.b	d5,d4			;get byte 1
	add.l	d4,d1			;byte 1 sum
	lsr.l	#8,d5			;align next byte
	move.b	d5,d4			;get byte 0
	add.l	d4,d0			;byte 0 sum

	ELSE				;					<v1.2>
		
@10	move.l	(a0)+,d5		;read out 4 bytes
	move.b	d5,d4			;get byte 3
	add.l	d4,d3			;byte 3 sum
	lsr.l	#8,d5			;align next byte
	move.b	d5,d4			;get byte 2
	add.l	d4,d2			;byte 2 sum
	lsr.l	#8,d5			;align next byte
	move.b	d5,d4			;get byte 1
	add.l	d4,d1			;byte 1 sum
	lsr.l	#8,d5			;align next byte
	move.b	d5,d4			;get byte 0
	add.l	d4,d0			;byte 0 sum
	
	ENDIF
	
	cmpa.l	a0,a1			;done yet?
	bgt.s	@10

;  Now we jump past the 16 bytes of sums that live in low ROM space.

	adda.l	#16,a0			;pointing at code again
	lea	myROMEnd,a1		;and end of ROM image + 1
	
	IF CPU = 00 THEN		;					<v1.2>
	
@15	move.w	(a0)+,d5		;read out 2 bytes
	move.b	d5,d4			;get byte 1
	add.l	d4,d1			;byte 1 sum
	lsr.l	#8,d5			;align next byte
	move.b	d5,d4			;get byte 0
	add.l	d4,d0			;byte 0 sum

	ELSE				;					<v1.2>
	
@15	move.l	(a0)+,d5		;read out 4 bytes
	move.b	d5,d4			;get byte 3
	add.l	d4,d3			;byte 3 sum
	lsr.l	#8,d5			;align next byte
	move.b	d5,d4			;get byte 2
	add.l	d4,d2			;byte 2 sum
	lsr.l	#8,d5			;align next byte
	move.b	d5,d4			;get byte 1
	add.l	d4,d1			;byte 1 sum
	lsr.l	#8,d5			;align next byte
	move.b	d5,d4			;get byte 0
	add.l	d4,d0			;byte 0 sum
	
	ENDIF
	
	cmpa.l	a0,a1			;done yet?
	bgt.s	@15

;  a2 still points to the table of expected checksums in low ROM...
;  Check all 4 even though on Aladdin bytes 2,3 will be 0.

	move.l	(a2)+,d4		;byte 0 expected checksum
	eor.l	d4,d0			;any error?
	beq.s	@20			;no
	
	bset	#0,d6			;yes, flag byte 0 checksum error
	
@20	move.l	(a2)+,d4		;byte 1 expected checksum
	eor.l	d4,d1			;any error?
	beq.s	@30			;no
	
	bset	#1,d6			;yes, flag byte 1 checksum error

@30	move.l	(a2)+,d4		;byte 2 expected checksum
	eor.l	d4,d2			;any error?
	beq.s	@40			;no
	
	bset	#2,d6			;yes, flag byte 2 checksum error
	
@40	move.l	(a2)+,d4		;byte 3 expected checksum
	eor.l	d4,d3			;any error?
	beq.s	@50			;no
	
	bset	#3,d6			;yes, flag byte 3 checksum error
	
@50	jmp	(a6)			;exit test

;---------------------------------------------------------------------------
;  ExtRAMTest is a March pattern for testing RAM.  The algorithm is:
;
;	a)	write zeros to all RAM incrementing addresses
;	b)	read/verify/invert incrementing
;	c)	read/verify/invert decrementing
;	d)	read/verify/invert incrementing
;	e)	read/verify decrementing
;
;  On entry:
;
;	a0 =	points to start of test area
;	a1 =	points to end of test area
;
;  Register usage:
;
;	a0 = 	points to start of test area
;	a1 = 	points to end of test area
;	a2 = 	working address pointer
;	
;	d0 =	data pattern
;	d1 =	inverted data pattern
;	d2 =	loop counter
;	d3 =	saved loop counter
;
;  This test assumes interrupts are masked out, except for power off in NuMac.
;
;---------------------------------------------------------------------------
ExtRAMTest
	moveq	#0,d0			;starting data = 0
	moveq	#-1,d1			;inverted data = $FFFFFFFF
	
	move.l	a0,a2			;copy start area
	
	move.l	a1,d2			;first get the top boundary
	sub.l	a0,d2			; = number of bytes to test
	lsr.l	#2,d2			;divide by 4		
	move.l	d2,d3			;and keep a copy

@10	move.l	d0,(a2)+		;write a pattern
	subq.l	#1,d2			;count it		
	bne.s	@10			;until done	

;  RAM is at all 0's now

;  Now read/verify/invert incrementing

	move.l	d3,d2			;get count
	move.l	a0,a2			;and pointer

@20	tst.l	(a2)			;read/verify
	bne.s	@1000			;error
	
	eor.l	d1,(a2)+		;read/invert to 1's
	
	subq.l	#1,d2			;count it		
	bne.s	@20			;until done	
	
;  RAM is at all 1's now

;  Read/verify/invert decrementing, a2 points to 1 long past the top area

	move.l	d3,d2			;get count
	
@30	eor.l	d1,-(a2)		;read/invert to 0's
	bne.s	@1000			;error
	
	subq.l	#1,d2			;count it		
	bne.s	@30			;until done	
	
;  RAM is at all 0's now

;  Read/verify/invert incrementing, a2 points to start of test area

	move.l	d3,d2			;get count
	
@40	tst.l	(a2)			;read/verify
	bne.s	@1000			;error
	
	eor.l	d1,(a2)+		;read/invert to 1's
	
	subq.l	#1,d2			;count it		
	bne.s	@40			;until done	
	
;  RAM is at all 1's now

;  Read/verify/invert decrementing, a2 points to 1 long past the top area

	move.l	d3,d2			;get count
	
@50	eor.l	d1,-(a2)		;read/invert to 0's
	bne.s	@1000			;error
	
	subq.l	#1,d2			;count it		
	bne.s	@50			;until done	
	
;  RAM is at all 0's now

;  Read/verify incrementing, a2 points to start of test area	

	move.l	d3,d2			;get count	[C354>
	
@60	tst.l	(a2)+			;read/verify
	bne.s	@1000			;error

	subq.l	#1,d2			;count it		
	bne.s	@60			;until done	
	
	jmp	(a6)			;return no error
	
@1000	or.l	(a2),d6			;or in bad bits

	IF CPU = 00 THEN		;				<v1.1>	
	
	move.l	d6,d0			;copy 32 bit mask
	swap	d0			;bad bit mask to lower word
	or.w	d0,d6			;
	and.l	#$0000FFFF,d6		;only pass back lower word mask
	
	ENDIF
	
	jmp	(a6)


;---------------------------------------------------------------------------
;  AddrLineTest
;
;  This test writes a pattern in each memory address according to its address bit,
;  then reads each back and verifies the pattern.  This is then repeated in reverse.
;
;  The addresses tested are $0,$4,$8,$10,$20,$40...$n00000.. to bank A bound if
;  more than 1 bank exists, or to bank A bound div 2 if only one bank.
;
;  On entry:	d6   =	0
;		a6   =	return address
;		(sp) =	pointer to memory location table
;
;  On exit:	d6   =	bit map of any bad address line, 0 if no errors
;		a6   =	return address
;		(sp) =	pointer to memory location table
;
;---------------------------------------------------------------------------
AddrLineTest

;;compute top of memory									<v1.9>

	move.l	(sp),a1			;move memory table pointer into a1		<v1.9><v2.3>
	addq.l	#8,a1			;point to end of table for one bank systems	<v1.9>
	move.l	#$01ffffff,d4		;set up mask					<v1.9>
@402	cmpi.l	#-1,(a1)		;search for end of table			<v1.9>
	beq.s	@404			;found it!					<v1.9>
	move.l	(sp),a1			;move memory table pointer into a1		<v1.9><v2.3>
	move.l	(a1)+,a2		;move beginning of bank A into a2		<v1.9>
	add.l	(a1)+,a2		;compute top of bank A				<v1.9>
	addq.l	#8,a1			;point to next location field			<v1.9>
	bra.s	@02			;skip ahead					<v1.9>
@404	subq.l	#8,a1			;go back to last location			<v1.9>
	move.l	(a1)+,a0		;move beginning memory location to a0		<v1.9>
	add.l	(a1)+,a0		;add size to memory location to point to top	<v1.9>

	IF onMac | onMacPP | onHcMac THEN	;				
	
	move.l	(sp),a1			;move memory table pointer into a1		<v1.9><v2.3>
	move.l	(a1)+,a0		;move beginning of bank A into a0		<v1.9>
	add.l	(a1)+,a0		;compute top of bank A				<v1.9>
	move.l	a0,d0			;get top of memory
	lea	K512,a2			;prep with top of 512K constant
	cmp.l	#Meg1,d0		;see if RAM size > 1Meg
	ble.s	@000			;yes it is

	lea	Meg2,a2			;prep with top of 2Meg constant
@000	
	ELSE				;						<v1.9>

	move.l	(sp),a1			;move memory table pointer into a1		<v1.9><v2.3>
	move.l	(a1)+,a2		;move beginning of bank A into a2		<v1.1>
	add.l	(a1)+,a2		;compute top of bank A				<v1.1>

	ENDIF				;						<v1.1>
	
;  Now a2 has the top of bank A	+ 1, lets first see if thats the top of [contiguous] RAM

	cmp.l	a2,a0			;a2 = top of Bank A, a0 = top of RAM
	bgt.s	@05			;there is more than 1 bank
	
@02	move.l	a2,d0			;there is only 1 bank, so shift test address
	lsr.l	#1,d0
	and.l	d4,d0			;mask out bank starting location		<v1.9>
	move.l	d0,a2			;and use it as the top address to test

@05		
	move.l	(sp),a1			;move memory table pointer into a1		<v1.9><v2.3>
	move.l	(a1),a1			;load up beginning of bank A			<v1.1>
	clr.l	(a1)			;clear first address in bank A			<v1.1>
	
	moveq	#4,d5			;first test data
	
@10	move.l	d5,a3			;generate test address
	add.l	a1,a3			;add offset if necessary			<v1.9>
	move.l	d5,(a3)			;write test data to test address
	lsl.l	#1,d5			;calculate next test data *2
	cmp.l	a2,d5			;see if done
	ble.s	@10

;  Data has been written, read back in forward direction and verify

	move.l	(sp),a3			;move memory table pointer into a1		<v1.9><v2.3>
	move.l	(a3),d0			;should be 0
	and.l	d4,d0			;mask out bank starting location		<v1.9>
	bne.s	@1000			;... else error
	
	moveq	#4,d5			;first test data/address
	
@20	move.l	d5,a3			;generate test address
	add.l	a1,a3			;add offset if necessary			<v1.9>
	move.l	(a3),d0			;read test data from test address
	eor.l	d5,d0			;as expected?
	bne.s	@1000			;no, error
	lsl.l	#1,d5			;calculate next test data *2
	cmp.l	a2,d5			;see if done
	ble.s	@20

;  Now write data in backward direction, high to low addresses	
	
	move.l	a2,d5			;generate test data
	lsl.l	#1,d5			;prime with 2*test data/address
	
@30	lsr.l	#1,d5			;calculate next test data div 2
	cmp.l	#4,d5			;until data/address < 4
	blt.s	@35			;until test data/address < 0	
	move.l	d5,a3			;generate test address
	add.l	a1,a3			;add offset if necessary			<v1.9>
	move.l	d5,(a3)			;write test data to test address
	bra.s	@30			;again

;  Data has been written, read back forward and verify

@35	sub.l	a3,a3			;start at RAM bottom again
	add.l	a1,a3			;add offset if necessary			<v1.9>
	move.l	(a3),d0			;should be 0
	and.l	d4,d0			;mask out bank starting location		<v1.9>
	bne.s	@1000			;... else error
	
	moveq	#4,d5			;first test data/address
	
@40	move.l	d5,a3			;generate test address
	add.l	a1,a3			;add offset if necessary			<v1.9>
	move.l	(a3),d0			;read test data from test address
	eor.l	d5,d0			;as expected?
	bne.s	@1000			;no, error
	lsl.l	#1,d5			;calculate next test data *2
	cmp.l	a2,d5			;see if done
	ble.s	@40
	clr.l	d0			;done, clear error accumulator
	
@1000	move.l	d0,d6			;set any failed bits for caller
	jmp	(a6)			;return to caller
	
;
;---------------------------------------------------------------------------
;  No Test implemented
;
;---------------------------------------------------------------------------
NoTest	
	moveq	#0,d6
	jmp	(a6)
	
	
;---------------------------------------------------------------------------
;---------------------------------------------------------------------------
;---------------------------------------------------------------------------
;---------------------------------------------------------------------------
;dynamic bus sizing tests

;table for dynamic bus-sizing test must be kept in this order

dbs_table	dc.l	$00112233		;pattern for 1st two lw's lw bound
		dc.l	$88888888
		
		dc.l	$88001122		;lw+1(offset)
		dc.l	$33888888		
		
		dc.l	$88880011		;lw+2(offset)
		dc.l	$22338888		
		
		dc.l	$88888800		;lw+3(offset)
		dc.l	$11223388

		dc.l	$88888888		;lw+4(offset)
		dc.l	$00112233


;expected patterns for word accesses

		dc.l	$00118888		;w+0(offset)
		dc.l	$88888888
		
		dc.l	$88001188		;w+1(offset)
		dc.l	$88888888		
		
		dc.l	$88880011		;w+2(offset)
		dc.l	$88888888
		
		dc.l	$88888800		;w+3(offset)
		dc.l	$11888888
		
		dc.l	$88888888		;w+4(offset)
		dc.l	$00118888
		
;expected patterns for byte accesses

		dc.l	$00888888		;b+0(offset)
		dc.l	$88888888
		
		dc.l	$88008888		;b+1(offset)
		dc.l	$88888888
		
		dc.l	$88880088		;b+2(offset)
		dc.l	$88888888
		
		dc.l	$88888800		;b+3(offset)
		dc.l	$88888888
		
		dc.l	$88888888		;b+4(offset)
		dc.l	$00888888




;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; dynamic_bussize_test:	this test will verify that the dynamic bus sizing of the 
;			68020/68030 and dram memory subsystem are working properly.
;			this is accomplished by writing longword, word, and byte data
;			to locations + offset within a constant field of two longwords 
;			and then verifying that the correct bytes were written that 
;			constant field of two longwords 
;			
;
; entry:		a0.l = ptr to valid ram on longword boundary
;			a6.l = return address for bsr6
;
; exit:			if pass
;				d6.l = 0
;
;			else
;				d6.l = bitmask of failures in the following format
;
;				bit 0 set means lw + 0 (offset) test failed
;				bit 1 set means lw + 1 (offset) test failed
;				.
;				.
;				.
;				bit 14 set means byte + 4 (offset) test failed
;
;				see dbs_table for expected patterns
;
;				
; altered:		d0.l - d6.l, a1.l - a2.l
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
		
;do longwords 1st

dynamic_bussize_test
		move.l	#%0111111111111111,d6	;init failure mask
		
		lea.l	dbs_table,a1		;ptr to table of expected results
		lea.l	dbs_table+4,a2		;ptr to background pattern
		move.l	#$00112233,d0		;initialize write pattern
		clr.l	d1			;init bit position holder and offset values
dbs_lwb1	move.l	(a2),(a0)		;write background pattern 2 longwords
		move.l	(a2),4(a0)
		

		move.l	d0,(a0,d1.w)		;write pattern to ram lw + offset
		movem.l	(a0),d2-d3		;read back lw's on lw bounds
		movem.l	(a1)+,d4-d5		;get expected pattern from table
		cmp.l	d4,d2			;does 1st lw match expected
		bne.s	dbs_lwb2		;no, skip mask update
		cmp.l	d5,d3			;how about 2nd lw
		bne.s	dbs_lwb2		;no, skip mask update
		swap	d1			;get bit position info to update fail bitmask
		bclr.l	d1,d6			;clear appropriate bit to indicate pass this test
		swap	d1			;restore offset to lower word
dbs_lwb2	addq.l	#1,d1			;bump address offset
		swap	d1			;get bit position info to update fail bitmask
		addq.w	#1,d1			;bump bit position to for next offset test
		swap	d1			;restore offset to lower word
		
		cmpi.b	#4,d1			;all offsets tried
		bls.s	dbs_lwb1		;no, do another


;;;;;;;;;;;;;;

;now do words

dbs_word	move.w	#$0011,d0		;initialize write pattern
		clr.w	d1			;init bit position holder and offset values
@dbs_lwb1	move.l	(a2),(a0)		;write background pattern 2 longwords
		move.l	(a2),4(a0)
		

		move.w	d0,(a0,d1.w)		;write pattern to ram lw + offset
		movem.l	(a0),d2-d3		;read back lw's on lw bounds
		movem.l	(a1)+,d4-d5		;get expected pattern from table
		cmp.l	d4,d2			;does 1st lw match expected
		bne.s	@dbs_lwb2		;no, skip mask update
		cmp.l	d5,d3			;how about 2nd lw
		bne.s	@dbs_lwb2		;no, skip mask update
		swap	d1			;get bit position info to update fail bitmask
		bclr.l	d1,d6			;clear appropriate bit to indicate pass this test
		swap	d1			;restore offset to lower word
@dbs_lwb2	addq.l	#1,d1			;bump address offset
		swap	d1			;get bit position info to update fail bitmask
		addq.w	#1,d1			;bump bit position to for next offset test
		swap	d1			;restore offset to lower word
		
		cmpi.b	#4,d1			;all offsets tried
		bls.s	@dbs_lwb1		;no, do another

;;;;;;;;;;;;;;;;;;;;;;;;

;and finally bytes

dbs_byte	clr.l	d0			;initialize write pattern
		clr.w	d1			;init bit position holder and offset values
@dbs_lwb1	move.l	(a2),(a0)		;write background pattern 2 longwords
		move.l	(a2),4(a0)
		

		move.b	d0,(a0,d1.w)		;write pattern to ram lw + offset
		movem.l	(a0),d2-d3		;read back lw's on lw bounds
		movem.l	(a1)+,d4-d5		;get expected pattern from table
		cmp.l	d4,d2			;does 1st lw match expected
		bne.s	@dbs_lwb2		;no, skip mask update
		cmp.l	d5,d3			;how about 2nd lw
		bne.s	@dbs_lwb2		;no, skip mask update
		swap	d1			;get bit position info to update fail bitmask
		bclr.l	d1,d6			;clear appropriate bit to indicate pass this test
		swap	d1			;restore offset to lower word
@dbs_lwb2	addq.l	#1,d1			;bump address offset
		swap	d1			;get bit position info to update fail bitmask
		addq.w	#1,d1			;bump bit position to for next offset test
		swap	d1			;restore offset to lower word
		
		cmpi.b	#4,d1			;all offsets tried
		bls.s	@dbs_lwb1		;no, do another
		jmp	(a6)			;return to caller


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;							<v1.9>

	
	END				;						<v1.1>

