;
;	File:		USTCritTests.a
;
;	Contains:	This file includes the critical test routines run at system start up.  There are also
;				some routines not run at startup but which are available to the Test Manager through 
;				the TJump Test Table.
;
;	Copyright:	© 1983-1993 by Apple Computer, Inc., all rights reserved.
;
;	Change History (most recent first):
;
;	   <SM5>	01/07/93	HY		In AddrLineTest save return address in A4 instead 
;									of A3 before calling SizeMemory.
;	   <SM4>	 8/20/92	CCH		Removed unneeded “forRisc” conditional.
;	   <SM3>	 7/13/92	CCH		Don't check checksum when running on Cub Card.
;	   <SM2>	  5/2/92	kc		Roll in Horror. Comments follow:
;		<H2>	01/27/92	jmp		(BG,Z6) Added padding in Mod3Test and RevMod3Test because of our
;									STUPIP assembler optimizes things even when we dont want it to.
;									Also, conditionalized the PROC parts of this file for use in
;									lining up the UST part of HORROR with that of TERROR/Zydeco.
;		<T5>	  4/2/91	CCH		Rolled in changes from Scott Smyers': Made the startupROM test
;									always pass when built forRomulator but executed in ROM, not
;									RAM. (it used to fail when run in ROM, but force a pass when run
;									in RAM).
;		<T4>	12/14/90	HJR		Cleaned up the ROM checksum routines.
;		<T3>	  9/9/90	CCH		Fixed StartupROMTest to deal with one-meg ROMs as well.
;		<T2>	  9/5/90	CCH		Modifying ROM checksum test to deal with one-meg ROMs.
;		<14>	 1/23/92	RB		Forced a good ROM checksum when compiled forRomulator.
;		<13>	 9/18/91	JSM		Cleanup header.
;		<12>	10/30/90	SS		Tweeked fix <11> so that it uses the ROMHeader structure instead
;									of equates in STEqu.a.
;		<11>	10/22/90	SS		Fixed the ROM checksum routines so that they do not rely on a
;									build specific equate to get the ROM size.  This is so that the
;									same code will work when we go to a 1 Meg ROM without having to
;									add another conditional flag to activate the 1 Meg ROM size
;									equate.  Also cleaned up the code a little in these routines.
;		<10>	 9/20/90	BG		Removed <8>.  040s are now behaving more reliably.
;		 <9>	  8/2/90	CCH		Added NOPs between consecutive MOVEMs for flaky 040s.
;		 <8>	 4/26/90	SS		In AddrLineTest, return an error from SizeMemory if it fails.
;		 <7>	 4/26/90	SS		Rewrote the address line test to test all of memory, not just
;									bank A.  It will work even if banks are non-contiguous.  I also
;									added a call to SizeMemory to this test so that you don't have
;									to run the SizeMem test immediately before running this one.
;		 <6>	 4/24/90	SS		In the byte lane ROM checksum test, I changed to use offsets for
;									the address of the checksum in ROM and the end of ROM, instead
;									of whole hardcoded addresses.
;		 <5>	 4/20/90	SS		Changed the way I increment a register in the extended RAM test
;									to make it a little faster.
;		 <4>	 3/30/90	SS		Fixed a register usage problem which was destroying results in
;									one of the RAM tests if an error was found on the last pattern
;									test.  Note that this test is only run in RBI and test manager -
;									not on power up.
;		 <3>	 2/16/90	SS		Added flags to statements which were changed to support Ericson.
;		 <2>	 2/12/90	MA		Added moving inversions RAM test.  It is not executed at
;									startup, but is executed by the Test Manager the same as other
;									mem. tests.
;	   <1.3>	 8/22/89	GMR		Included the rest of Fremonts critical tests in this file.
;	   <1.2>	 7/25/89	CCH		If forRomulator flag is set, checksum is forced good when
;									running in RAM.
;	   <1.1>	 7/15/89	GMR		Fixed CPU=00 conditional for the RAM tests.
;	   <1.0>	 6/13/89	GMR		Added for first time to EASE.
;
		
		STRING	ASIS

CritProc	PROC

		IMPORT	BaseOfRom
		IMPORT	SizeMemory				;<7>
		EXPORT	Mod3Test
		EXPORT	RevMod3Test
		EXPORT	RomTest
		EXPORT	StartUpROMTest
		EXPORT	ExtRAMTest
		EXPORT	AddrLineTest
		EXPORT	DataBusTest
		EXPORT	dynamic_bussize_test
		EXPORT	MovInvTest				;<3>
		EXPORT	NoTest


;---------------------------------------------------------------------------
;
;  Mod3Test is a fast test of the entire memory array.
;
;  Inputs:	a0 = bottom memory area to test
;			a1 = top of memory area to test + 1
;			a6 = return to caller
;
;  Outputs:	d6.l is a failed bit mask
;	    	a0,a1 still pointing to bottom and top of area to test
;
;  Register usage:
;
;	d0 =	test data register
;	d1 =	test data register
;	d2 =	test data register
;	d3 =	test data register
;	d4 =	test data register
;	d5 =	test data register
;	d6 =	failed bit mask
;
;	a0 =	pointer to bottom test area
;	a1 =	pointer to top of test area
;	a2 =	copy of a0
;	a3 =	unsued	
;	a4 = 	unused
;	a5 =	unused
;
;
;  This test writes a modulo 3 pattern to all of memory, then shifts the
;  pattern by writing the appropriate starting pattern, reading the next
;  in memory, exclusive oring this with the previous location, then writing
;  it back to the same location.  Any errors while reading (or writing) are
;  propagated to the end of memory.  At the end of the test the last 3 long
;  word entries must be as expected or an error has occurred.
;
;  In order to properly determine the failing bank with this test, it is best
;  to call the test with a0/a1 set to test one bank at a time.
;
;  There are three cases that can occur at the end of memory, depending on
;  what size memory is being tested.  Observe the last three long words:
;
;  Case 0: 
;
;	(LAST-12) $BD6BD6BD (LAST-8) $D6BD6BD6 (LAST-4) $6BD6BD6B
;		
;  Case 1: 
;
;	(LAST-12) $D6BD6BD6 (LAST-8) $6BD6BD6B (LAST-4) $BD6BD6BD
;		
;  Case 2: 
;
;	(LAST-12) $6BD6BD6B (LAST-8) $BD6BD6BD (LAST-4) $D6BD6BD6
;
;  The last three longs are compared against the appropriate table entries
;  based on the case determined when memory is filled the first time.
;  On exit, D6 reflects any bad bits found.
;
;  This test should only be called with a0/a1 pointing at mod 4 bounds.  The
;  code assumes this and tests accordingly on 32 bit longword bounds, however
;  calling this test with other bounds will result in a bus error since non-
;  existent memory may be addressed. Also, upper - lower must be >= 24.
;
;  This test assumes interrupts are masked out with #$2500.
;---------------------------------------------------------------------------
			align	4
Mod3Test

@FillRegs	reg	d0/d1/d2/d3/d4/d5
		movem.l	Mod3Pat,@FillRegs		;load up 2 copies of the test patterns
		movea.l	a0,a2					; starting address
		suba.w	#120,a1					; subtract slop from loop terminator
		bra.s	@Fill120Start
@Fill120Loop
		movem.l	@FillRegs,(a2)
		movem.l	@FillRegs,24(a2)
		movem.l	@FillRegs,48(a2)
		movem.l	@FillRegs,72(a2)
		movem.l	@FillRegs,96(a2)
		adda.w	#120,a2					; point past block just written
@Fill120Start
		cmpa.l	a1,a2
		ble.s	@Fill120Loop			; fill until < 120 bytes remaining

		suba.w	#12-120,a1				; subtract slop from loop terminator
		moveq.l	#12,d5					; address increment value
		bra.s	@Fill12Start
@Fill12Loop
		movem.l	d0-d2,(a2)
		adda.w	d5,a2					; point past bytes just written
@Fill12Start
		cmpa.l	a1,a2
		ble.s	@Fill12Loop				; fill until < 12 bytes remaining
		adda.w	d5,a1					; restore end address

; Now pick up the last maximum 8 bytes not written

		moveq	#4,d4					;case 0, offset = 4
		cmpa.l	a2,a1					;maybe it came out even?
		beq.s	@FillDone				;done filling memory
	
		move.l	d0,(a2)+				;write one more long
		moveq	#8,d4					;case 1, offset = 8
		cmpa.l	a2,a1					;compare against real mem top
		beq.s	@FillDone				;done filling memory
		
		move.l	d1,(a2)+				;write one more long
		moveq	#0,d4					;case 2, offset = 0

@FillDone
		movea.l	a0,a2					;copy starting address
		
; Memory is filled with the mod 3 pattern.  The pattern is sequenced through
; three iterations for the test by exclusive oring in the following manner. 		

		move.l	a1,d3					;first get the top boundary
		sub.l	a0,d3					; = number of bytes to test
		subq.l	#4,d3					;less 4 bytes
		moveq.l	#$3F,d2					; mask for index into loop
		and.w	d3,d2					; compute the index
		neg.w	d2						; index backwards
		lsr.l	#6,d3					; 64 bytes per loop

		eor.l	d1,(a2)					;write starting pattern
		addi.l	#$FFFFFFFF,d5			;help any floating bits float up
		jmp		@61(d2.w)				; jump to the correct starting position

@60		move.l	(a2)+,d2				;read a pattern
		eor.l	d2,(a2)					;generate next pattern
		move.l	(a2)+,d2				;read a pattern
		eor.l	d2,(a2)					;generate next pattern
		move.l	(a2)+,d2				;read a pattern
		eor.l	d2,(a2)					;generate next pattern
		move.l	(a2)+,d2				;read a pattern
		eor.l	d2,(a2)					;generate next pattern
		move.l	(a2)+,d2				;read a pattern
		eor.l	d2,(a2)					;generate next pattern
		move.l	(a2)+,d2				;read a pattern
		eor.l	d2,(a2)					;generate next pattern
		move.l	(a2)+,d2				;read a pattern
		eor.l	d2,(a2)					;generate next pattern
		move.l	(a2)+,d2				;read a pattern
		eor.l	d2,(a2)					;generate next pattern
		move.l	(a2)+,d2				;read a pattern
		eor.l	d2,(a2)					;generate next pattern
		move.l	(a2)+,d2				;read a pattern
		eor.l	d2,(a2)					;generate next pattern
		move.l	(a2)+,d2				;read a pattern
		eor.l	d2,(a2)					;generate next pattern
		move.l	(a2)+,d2				;read a pattern
		eor.l	d2,(a2)					;generate next pattern
		move.l	(a2)+,d2				;read a pattern
		eor.l	d2,(a2)					;generate next pattern
		move.l	(a2)+,d2				;read a pattern
		eor.l	d2,(a2)					;generate next pattern
		move.l	(a2)+,d2				;read a pattern
		eor.l	d2,(a2)					;generate next pattern
		move.l	(a2)+,d2				;read a pattern
		eor.l	d2,(a2)					;generate next pattern
@61		dbra	d3,@60					; until done
		subi.l	#$00010000,d3			; adjust outer loop count
		bpl.s	@60
	
		cmp.w	#ErrParRAM,d7			;have we finished parity ram test?
		beq		@exit					;yep, we're outta here

;  Now the final pass through the test area.

		cmp.l	d0,d1					; is this the second pass
		beq.s	@62						; if so, we're done
		move.l	d0,d1					; use pattern from D0 on final pass
		bra.s	@FillDone				; make another pass
@62

; Now pick up the appropriate 3 longs nearest the end point.  These should	
; match patterns based on the case in d4, which was set up in the memory
; fill earlier. If any error occurred during eoring, it is propagated to the end.

		movem.l	-12(a1),d0-d2			;pickup last 12 bytes

; and remember d4 is still set up..
	
		movem.l	Mod3Pat(d4.w),d3-d5		;get original test patterns	
		
		eor.l	d3,d0
		eor.l	d4,d1
		eor.l	d5,d2		
		or.l	d2,d0
		or.l	d1,d0					;compile final "bad bit" mask
		
		or.l	d0,d6					;record for caller
		
		btst	#parity,d7				;determine need for parity ram test		
		beq.s	@exit					;no parity ram, we're done			
		move.w	#ErrParRAM,d7			;set parity ram error code			
		movem.l	Mod3Pat+4,@FillRegs		;load up 2 copies of the test patterns		
		bra		@FillDone				;do one more pass if parity ram installed	
@exit	RTS6							;and return
			
; Table of test and compare patterns

Mod3Pat			
		dc.l	$6DB6DB6D				;case 2, offset = 0
		dc.l	$B6DB6DB6				;case 0, offset = 4
		dc.l	$DB6DB6DB				;case 1, offset = 8
		dc.l	$6DB6DB6D
		dc.l	$B6DB6DB6		
		dc.l	$DB6DB6DB		
		
;---------------------------------------------------------------------------
;
;  RevMod3Test is a fast test of the entire memory array, very similar to the
;  Mod3Test above.  It tests memory with the test addresses generated in the
;  reverse direction.
;
;  changed reg a3 to a2 in following code to make it like mod3test	
;  and to free-up a3 for other stuff
;
;  Inputs:	a0 = bottom memory area to test
;			a1 = top of memory area to test + 1
;			a6 = return to caller
;
;  Outputs:	d6.l is a failed bit mask
;	    	a0,a1 still pointing to bottom and top of area to test
;
;  Register usage:
;
;	d0 =	test data register
;	d1 =	test data register
;	d2 =	test data register
;	d3 =	test data register
;	d4 =	test data register
;	d5 =	test data register
;	d6 =	failed bit mask
;
;	a0 =	pointer to bottom test area
;	a1 =	pointer to top of test area
;	a2 =	copy of a1
;	a3 =	unused
;	a4 =	unused
;	a5 =	unused
;
;  This test writes a modulo 3 pattern to all of memory, then shifts the
;  pattern by writing the appropriate starting pattern, reading the next
;  in memory, exclusive oring this with the previous location, then writing
;  it back to the same location.  Any errors while reading (or writing) are
;  propagated to the beginning of memory.  At the end of the test the first 3
;  long word entries must be as expected or an error has occurred.
;
;  In order to properly determine the failing bank with this test, it is best
;  to call the test with a0/a1 set to test one bank at a time.
;
;  There are three cases that can occur at the end of memory, depending on
;  what size memory is being tested.  Observe the last three long words:
;
;  Case 0: must write 3 more longs to fill memory, table offset = 8 for
;	   correct final compare patterns.
;
;	(FIRST+0) $6BD6BD6B (FIRST+4) $BD6BD6BD (FIRST+8) $D6BD6BD6
;		
;  Case 1: must write 1 more long to fill memory, table offset = 4 for
;	   correct final compare patterns.
;
;	(FIRST+0) $D6BD6BD6 (FIRST+4) $6BD6BD6B (FIRST+8) $BD6BD6BD
;		
;  Case 2: must write 2 more longs to fill memory, table offset = 0 for
;	   correct final compare patterns.
;
;	(FIRST+0) $BD6BD6BD (FIRST+4) $D6BD6BD6 (FIRST+8) $6BD6BD6B
;
;  The first three longs are compared against the appropriate table entries
;  based on the case determined when memory is filled the first time.
;  On exit, D6 reflects any bad bits found.
;
;  This test should only be called with a0/a1 pointing at mod 4 bounds.  The
;  code assumes this and tests accordingly on 32 bit longword bounds, however
;  calling this test with other bounds will result in a bus error since non-
;  existent memory may be addressed.  Also, upper - lower must be >= 24.
;
;  This test assumes interrupts are masked out with #$2500.
;
;---------------------------------------------------------------------------
		align	4
RevMod3Test

@FillRegs	reg	d0/d1/d2/d3/d4/d5
		movem.l	RevMod3Pat,@FillRegs	;load up 2 copies of the test patterns
		movea.l	a1,a2					; starting address
		adda.w	#120,a0					; add slop to loop terminator
		bra.s	@Fill120Start
@Fill120Loop
		movem.l	@FillRegs,-(a2)
		movem.l	@FillRegs,-(a2)
		movem.l	@FillRegs,-(a2)
		movem.l	@FillRegs,-(a2)
		movem.l	@FillRegs,-(a2)
@Fill120Start
		cmpa.l	a2,a0
		ble.s	@Fill120Loop			; fill until < 120 bytes remaining
	
		adda.w	#12-120,a0				; add slop to loop terminator
		bra.s	@Fill12Start
@Fill12Loop
		movem.l	d0-d2,-(a2)
@Fill12Start
		cmpa.l	a2,a0
		ble.s	@Fill12Loop				; fill until < 12 bytes remaining
		suba.w	#12,a0					; restore bottom address

; Now pick up the last maximum 8 bytes not written

		moveq	#8,d4					;case 0, offset = 8
		cmpa.l	a2,a0					;compare against real mem bottom
		beq.s	@FillDone				;done filling memory
		
		move.l	d2,-(a2)				;write one more long
		moveq	#4,d4					;case 1, offset = 4
		cmpa.l	a2,a0					;compare against real mem bottom
		beq.s	@FillDone				;done filling memory
			
		move.l	d1,-(a2)				;write one more long
		moveq	#0,d4					;case 2, offset = 0
	
@FillDone		
		movea.l	a1,a2					;copy ending address
		subq.l	#4,a2					;adjust to last longint
		
; Memory is filled with the mod 3 pattern.  The pattern is sequenced through
; three iterations for the test by exclusive oring in the following manner. 		

		move.l	a2,d3					;first get the top boundary
		sub.l	a0,d3					; = number of bytes to test
		moveq.l	#$3F,d0					; mask for index into loop
		and.w	d3,d0					; compute the index
		neg.w	d0						; index backwards
		lsr.l	#6,d3					; 64 bytes per loop
	
		eor.l	d1,(a2)					;write starting pattern
		addi.l	#$FFFFFFFF,d5			;help any floating bits float up
		jmp		@61(d0.w)				; jump to the correct starting position
	
@60		move.l	(a2),d0					;read a pattern
		eor.l	d0,-(a2)				;generate next pattern
		move.l	(a2),d0					;read a pattern
		eor.l	d0,-(a2)				;generate next pattern
		move.l	(a2),d0					;read a pattern
		eor.l	d0,-(a2)				;generate next pattern
		move.l	(a2),d0					;read a pattern
		eor.l	d0,-(a2)				;generate next pattern
		move.l	(a2),d0					;read a pattern
		eor.l	d0,-(a2)				;generate next pattern
		move.l	(a2),d0					;read a pattern
		eor.l	d0,-(a2)				;generate next pattern
		move.l	(a2),d0					;read a pattern
		eor.l	d0,-(a2)				;generate next pattern
		move.l	(a2),d0					;read a pattern
		eor.l	d0,-(a2)				;generate next pattern
		move.l	(a2),d0					;read a pattern
		eor.l	d0,-(a2)				;generate next pattern
		move.l	(a2),d0					;read a pattern
		eor.l	d0,-(a2)				;generate next pattern
		move.l	(a2),d0					;read a pattern
		eor.l	d0,-(a2)				;generate next pattern
		move.l	(a2),d0					;read a pattern
		eor.l	d0,-(a2)				;generate next pattern
		move.l	(a2),d0					;read a pattern
		eor.l	d0,-(a2)				;generate next pattern
		move.l	(a2),d0					;read a pattern
		eor.l	d0,-(a2)				;generate next pattern
		move.l	(a2),d0					;read a pattern
		eor.l	d0,-(a2)				;generate next pattern
		move.l	(a2),d0					;read a pattern
		eor.l	d0,-(a2)				;generate next pattern
@61		dbra	d3,@60					; until done
		subi.l	#$00010000,d3			; adjust outer loop count
		bpl.s	@60
	
		cmp.w	#ErrParRAM,d7			;have we finished parity ram test?
		beq	@exit						;yep, we're outta here

;  Now the final pass through the test area.

		cmp.l	d2,d1					; is this the second pass
		beq.s	@62						; if so, we're done
		move.l	d2,d1					; use pattern from D2 on final pass
		bra.s	@FillDone				; make another pass
@62

; Now pick up the appropriate 3 longs nearest the end point.  These should	
; match patterns based on the case in d4. If any error occurred during
; eoring, it is propagated through to the end.

		movem.l	(a0),d0-d2				;pickup first 12 bytes
		movem.l	RevMod3Pat(d4.w),d3-d5	;get original test patterns
		
		eor.l	d3,d0
		eor.l	d4,d1
		eor.l	d5,d2		
		or.l	d2,d0
		or.l	d1,d0					;compile final "bad bit" mask
		
		or.l	d0,d6					;record for caller
	
		
		btst	#parity,d7				;determine need for parity ram test
		beq.s	@exit					;no parity ram, we're done
		move.w	#ErrParRAM,d7			;set parity ram error code
		movem.l	RevMod3Pat+4,@FillRegs	;load up 2 copies of the test patterns
		bra		@FillDone				;do one more pass if parity ram installed	
@exit	RTS6							;and return
			
RevMod3Pat			
		dc.l	$6DB6DB6D				;case 2, offset = 0
		dc.l	$B6DB6DB6				;case 0, offset = 4
		dc.l	$DB6DB6DB				;case 1, offset = 8
		dc.l	$6DB6DB6D
		dc.l	$B6DB6DB6		
		dc.l	$DB6DB6DB		
		


;---------------------------------------------------------------------------
;  RomTest does a ROM checksum on the individual ROMs and returns an error
;  code in d6 indicating any failed ROMs.  The checksums are located in the
;  ROMs at dedicated addresses, forever defined to be as follows:
;
;		ROM 0	at ROMStart + $0030 - $0033
;		ROM 1	at ROMStart + $0034 - $0037
;		ROM 2	at ROMStart + $0038 - $003B
;		ROM 3	at ROMStart + $003C - $003F
;
;  On entry:	d6 =	0
;  On exit:		d6 =	$0000000X, where X = abcd, and 
;								a means ROM 3, 
;								b means ROM 2, 
;								c means ROM 1, 
;								d means ROM 0
;
;  This test assumes interrupts are masked out with #$2500.
;
;---------------------------------------------------------------------------
RomTest	
		WITH	ROMHeader				;										<12>
		
			BigLea	BaseOfROM,a0		;point to start of ROM code				<11>
			lea		CheckSum0(a0),a1	;point to end of first area				<12><11>
			move.l	ROMSize(a0),d0		;and size of ROM						<12><11>
			lea.l	(a0,d0.l),a2		;calculate the end of ROM				<11>
		
		ENDWITH

		clr.l	d0				;clear summing registers
		clr.l	d1
		clr.l	d2
		clr.l	d3
		clr.l	d4				;holds a byte from ROM to sum
	
		addq.l	#4,a0			;skip past first long word					<11>
		
@loop	move.b	(a0)+,d4		;											<11>
		add.l	d4,d0			;sum the HHSB								<11>
		move.b	(a0)+,d4		;											<11>
		add.l	d4,d1			;sum the MHSB								<11>
		move.b	(a0)+,d4		;											<11>
		add.l	d4,d2			;sum the MLSB								<11>
		move.b	(a0)+,d4		;											<11>
		add.l	d4,d3			;sum the LLSB								<11>
	
		cmpa.l	a0,a1			;at checksum area yet?
		bne.s	@checkTop		;no, see if at top
		adda.l	#16,a0			;yes, skip over checksums
		bra.s	@loop			;and continue summing
@checkTop	
		cmpa.l	a0,a2			;end of ROM yet?
		bgt.s	@loop			;no, keep summing

@compare

	  IF forRomulator THEN		;									<1.2>
		TestInRam   A0			; are we running in RAM? 			<1.2>
		bne.s	@exit			; if so, force chksum good			<1.2>
	  ENDIF						;									<1.2>
	     
@byte1	cmp.l	(a1)+,d0		;byte 0 expected checksum
		beq.s	@byte2	
		bset	#0,d6			;error, flag byte 0 checksum error
@byte2	cmp.l	(a1)+,d1		;byte 1 expected checksum
		beq.s	@byte3
		bset	#1,d6			;error, flag byte 1 checksum error
@byte3	cmp.l	(a1)+,d2		;byte 2 expected checksum
		beq.s	@byte4
		bset	#2,d6			;error, flag byte 2 checksum error
@byte4	cmp.l	(a1)+,d3		;byte 3 expected checksum
		beq.s	@exit
		bset	#3,d6			;error, flag byte 3 checksum error
      
@exit	RTS6					;exit test



;---------------------------------------------------------------------------
;  StartUpROMTest is run normally only at system startup.  It uses the longword
;  checksum residing in location 0.  The Test Manager also supports a checksum test
;  that uses the 2 or 4 sums residing in locations ROMStart+$0030 through $003F
;  as separate sums for each ROM chip.
;
;---------------------------------------------------------------------------
StartUpROMTest
		moveq.l	#0,d0			;clear checksum accumulator						<11>
		moveq.l	#0,d1			;clear scratch									<11>
		
		WITH	ROMHeader			;											<12>
			BigLea	BaseOfROM,a0	;point at ROM start, expected checksum		<11><v1.6><2.1>
			move.l	ROMSize(a0),d3	;get the size of the ROM (in bytes)			<12><11>
			subq.l	#4,d3			;subtract size of checksum					<11>
			move.l	(a0)+,d4		;load up expected checksum					<11>
		ENDWITH
		
@ROMLoop						;												<11>
		move.w	(a0)+,d0		;fetch a ROM word								<11>
		add.l	d0,d1			;add to checksum								<11>
		subq.l	#2,d3			;decrement by 2 bytes							<11>
		bne.s	@ROMLoop		;continue until done							<11>
			
		nop						;some nops for debug (leave these here for emulator use)	
		nop						;some nops for debug	
		
		eor.l	d4,d1			;result should be zero
		beq.s	@exit			;												<11>
	
	IF forRomulator THEN		;if we're built for the romulator, we'd never pass<T5>
		bra.s	@exit			; therefore, force a good checksum				<2.4><T5>
	ENDIF					;												<2.4>
		
		move.w	#$FFFF,d6		;set a failed code in result register 			[A310>

@exit	RTS6					;and exit
	



;---------------------------------------------------------------------------
;  ExtRAMTest is a March pattern for testing RAM.  The algorithm is:
;
;	a)	write zeros to all RAM incrementing addresses
;	b)	read/verify/invert incrementing
;	c)	read/verify/invert decrementing
;	d)	read/verify/invert incrementing
;	e)	read/verify decrementing
;
;  On entry:
;
;	a0 =	points to start of test area
;	a1 =	points to end of test area
;
;  Register usage:
;
;	a0 = 	points to start of test area
;	a1 = 	points to end of test area
;	a2 = 	working address pointer
;	
;	d0 =	data pattern
;	d1 =	inverted data pattern
;	d2 =	loop counter
;	d3 =	saved loop counter
;
;  This test assumes interrupts are masked out, except for power off in NuMac.
;
;---------------------------------------------------------------------------
ExtRAMTest
		moveq	#0,d0			;starting data = 0
		moveq	#-1,d1			;inverted data = $FFFFFFFF
		
		move.l	a0,a2			;copy start area
		
		move.l	a1,d2			;first get the top boundary
		sub.l	a0,d2			; = number of bytes to test
		lsr.l	#2,d2			;divide by 4		
		move.l	d2,d3			;and keep a copy

@10		move.l	d0,(a2)+		;write a pattern
		subq.l	#1,d2			;count it		
		bne.s	@10				;until done	

;  RAM is at all 0's now
;  Now read/verify/invert incrementing

		move.l	d3,d2			;get count
		move.l	a0,a2			;and pointer
@20		tst.l	(a2)			;read/verify
		bne.s	@1000			;error
		eor.l	d1,(a2)+		;read/invert to 1's
		subq.l	#1,d2			;count it		
		bne.s	@20				;until done	
	
;  RAM is at all 1's now
;  Read/verify/invert decrementing, a2 points to 1 long past the top area

		move.l	d3,d2			;get count
@30		eor.l	d1,-(a2)		;read/invert to 0's
		bne.s	@1000			;error
		subq.l	#1,d2			;count it		
		bne.s	@30				;until done	
	
;  RAM is at all 0's now
;  Read/verify/invert incrementing, a2 points to start of test area

		move.l	d3,d2			;get count
@40		tst.l	(a2)			;read/verify
		bne.s	@1000			;error
		eor.l	d1,(a2)+		;read/invert to 1's
		subq.l	#1,d2			;count it		
		bne.s	@40				;until done	
		
;  RAM is at all 1's now
;  Read/verify/invert decrementing, a2 points to 1 long past the top area

		move.l	d3,d2			;get count
@50		eor.l	d1,-(a2)		;read/invert to 0's
		bne.s	@1000			;error
		subq.l	#1,d2			;count it		
		bne.s	@50				;until done	
	
;  RAM is at all 0's now
;  Read/verify incrementing, a2 points to start of test area	

		move.l	d3,d2			;get count	[C354>
@60		tst.l	(a2)			;read/verify									<4>
		bne.s	@1000			;Error if ≠ 0									<4>
		addq.l	#4,a2			;Else, Increment a2 to point to next location	<5><4>
		subq.l	#1,d2			;count it		
		bne.s	@60				;until done	
		RTS6					;return no error
	
@1000	or.l	(a2),d6			;or in bad bits
	
		RTS6


;---------------------------------------------------------------------------
;  AddrLineTest
;
;  This test writes a pattern in each memory address according to its address bit,
;  then reads each back and verifies the pattern in reverse.
;
;  On entry:	a6   =	return address
;
;  On exit:	d6   =	failed bits of an address location, or error result from SizeMem	<8>
;			d7.b =	if ≠ 0:	bank number which failed (1 = bank A)						<8>
;					if = 0:	Size memory failed; d6 contains the error from size mem		<8>
;			a6   =	return address
;			(sp) =	pointer to memory location table
;
;	Destroys	a0-a3, d0, d5
;
;---------------------------------------------------------------------------
AddrLineTest

		move.b	#0,d7			;Initialize the bank counter					<8>
		movea.l	a6,a4			;Save Return address							<7><SM5>
		BSR6	SizeMemory		;Size all of memory								<7>
		movea.l	a4,a6			;Restore the return address						<7><SM5>
		bne.s	@VerError		;If size mem failed, error out					<8>
		
		move.l	(sp),a0			;move memory table pointer into a0				<7>
		
@NextBankFill
		add.b	#1,d7			;Increment the bank counter						<7>
		move.l	(a0)+,a1		;Get the start addr of this bank				<7>
		cmpa.l	#-1,a1			;is this all the banks?							<7>
		beq.s	@MemFilled		;go to check if so								<7>
		
		movea.l	(a0)+,a2		;Get length of bank								<7>
		move.l	a1,(a1)			;Initialize the first location of the bank		<7>
		moveq.l	#4,d5			;Start storing from offset 4					<7>
		
@Fill	move.l	d5,a3			;Get the starting offset						<7>
		adda.l	a1,a3			;Add the base addr of this bank					<7>
		move.l	a3,(a3)			;write test data to test address				<7>

		lsl.l	#1,d5			;calculate next test data						<7>
		cmp.l	a2,d5			;see if done									<7>
		blt.s	@Fill			;Continue if not								<7>
		bra.s	@NextBankFill	;Else go to next bank							<7>
		
; All banks now have the fill pattern.  Verify this in the reverse direction	<7>
	
@MemFilled
		lea		-4(a0),a0		;point a0 to the 'end of chunk table' mark		<7>

@NextBankCheck
		sub.b	#1,d7			;Decrement the bank counter						<7>
		movea.l	-(a0),a2		;Get the bank size from the chunk table			<7>
		movea.l	-(a0),a1		;and the start address of this bank				<7>
		moveq.l	#4,d5			;Initialize the starting offset					<7>
		
@adjust	lsl.l	#1,d5			;Shift the test offset							<7>
		cmp.l	a2,d5			;Is it greater than the bank size?				<7>
		blt.s	@adjust			;continue shifting if not						<7>

@check	lsr.l	#1,d5			;Adjust the offset								<7>
		move.l	d5,d0			;Calculate the test address						<7>
		add.l	a1,d0			;												<7>
		movea.l	d0,a3			;												<7>
		move.l	(a3),d6			;Get the test data								<7>
		eor.l	d0,d6			;Verify it										<7>
		bne.s	@VerError		;Error out if not zero							<7>
		cmp.l	#4,d5			;was that the last location?					<7>
		bgt.s	@check			;Continue checking if not						<7>
		tst.l	d5				;Have we tried an offset of zero yet?			<7>
		beq.s	@CheckCont		;Continue if so									<7>
		moveq.l	#0,d5			;Else, let's try an offset of zero				<7>
		bra.s	@check			;												<7>

@CheckCont		
		cmpa.l	(sp),a0			;Are we done yet?								<7>
		bgt.s	@NextBankCheck	;go on to next bank if not						<7>

		move.b	#0,d7			;Success!  Zero out the bank counter			<7>
		
@VerError						;												<7>
		RTS6					;Return											<7>
	
;---------------------------------------------------------------------------
;  Data bus test walks 0 and 1 bits across the data buss to verify that
;  memory can be accessed.
;
;  On entry, a6 = return to caller.
;	     a0 = test address
;
;  On exit, d6 = failed bit mask.
;
;  Register usage:
;
;	d0 =	data bit register
;	d1 =	data bit register
;	d2 =	loop counter
;
;	a0 =	address pointer
;
;  This test assumes interrupts are masked out with #$2500.
;---------------------------------------------------------------------------
;
DataBusTest
		moveq	#1,d0			;first data pattern is 1 in 0's
		moveq	#-2,d1			;next data pattern, $FFFFFFFE, 0 in 1's			[C660>/[C798>
		move.w	#$00FF,d2		;loop counter = 256

@10		movem.l	d0-d1,(a0)		;write test patterns
		eor.l	d0,(a0)			;read and write low test location
		or.l	(a0),d6			;if any bad bits, or to fail reg
		eor.l	d1,4(a0)		;read and write high test loc
		or.l	4(a0),d6		;if any bad bits, or to fail reg
		
		rol.l	#1,d0			;rotate the bit		
		rol.l	#1,d1			;rotate the bit
		
		dbra	d2,@10			;continue until bit shifted to carry
		
		RTS6					;return to caller, no errors

;---------------------------------------------------------------------------
;---------------------------------------------------------------------------
;---------------------------------------------------------------------------
;---------------------------------------------------------------------------
;dynamic bus sizing tests

;table for dynamic bus-sizing test must be kept in this order

dbs_table	
		dc.l	$00112233		;pattern for 1st two lw's lw bound
		dc.l	$88888888
		
		dc.l	$88001122		;lw+1(offset)
		dc.l	$33888888		
		
		dc.l	$88880011		;lw+2(offset)
		dc.l	$22338888		
		
		dc.l	$88888800		;lw+3(offset)
		dc.l	$11223388

		dc.l	$88888888		;lw+4(offset)
		dc.l	$00112233


;expected patterns for word accesses

		dc.l	$00118888		;w+0(offset)
		dc.l	$88888888
		
		dc.l	$88001188		;w+1(offset)
		dc.l	$88888888		
		
		dc.l	$88880011		;w+2(offset)
		dc.l	$88888888
		
		dc.l	$88888800		;w+3(offset)
		dc.l	$11888888
		
		dc.l	$88888888		;w+4(offset)
		dc.l	$00118888
		
;expected patterns for byte accesses

		dc.l	$00888888		;b+0(offset)
		dc.l	$88888888
		
		dc.l	$88008888		;b+1(offset)
		dc.l	$88888888
		
		dc.l	$88880088		;b+2(offset)
		dc.l	$88888888
		
		dc.l	$88888800		;b+3(offset)
		dc.l	$88888888
		
		dc.l	$88888888		;b+4(offset)
		dc.l	$00888888




;=======================================================
;
; dynamic_bussize_test:	this test will verify that the dynamic bus sizing of the 
;			68020/68030 and dram memory subsystem are working properly.
;			this is accomplished by writing longword, word, and byte data
;			to locations + offset within a constant field of two longwords 
;			and then verifying that the correct bytes were written that 
;			constant field of two longwords 
;			
;
; entry:	a0.l = ptr to valid ram on longword boundary
;			a6.l = return address for bsr6
;
; exit:		if pass
;				d6.l = 0
;
;			else
;				d6.l = bitmask of failures in the following format
;
;				bit 0 set means lw + 0 (offset) test failed
;				bit 1 set means lw + 1 (offset) test failed
;				.
;				.
;				.
;				bit 14 set means byte + 4 (offset) test failed
;
;				see dbs_table for expected patterns
;
;				
; altered:	d0.l - d6.l, a1.l - a2.l
;
;=======================================================
		
;do longwords 1st

dynamic_bussize_test
		move.l	#%0111111111111111,d6	;init failure mask
		
		lea.l	dbs_table,a1	;ptr to table of expected results
		lea.l	dbs_table+4,a2	;ptr to background pattern
		move.l	#$00112233,d0	;initialize write pattern
		clr.l	d1				;init bit position holder and offset values
dbs_lwb1	
		move.l	(a2),(a0)		;write background pattern 2 longwords
		move.l	(a2),4(a0)
		

		move.l	d0,(a0,d1.w)	;write pattern to ram lw + offset
		movem.l	(a0),d2-d3		;read back lw's on lw bounds
		movem.l	(a1)+,d4-d5		;get expected pattern from table
		cmp.l	d4,d2			;does 1st lw match expected
		bne.s	dbs_lwb2		;no, skip mask update
		cmp.l	d5,d3			;how about 2nd lw
		bne.s	dbs_lwb2		;no, skip mask update
		swap	d1				;get bit position info to update fail bitmask
		bclr.l	d1,d6			;clear appropriate bit to indicate pass this test
		swap	d1				;restore offset to lower word
dbs_lwb2	
		addq.l	#1,d1			;bump address offset
		swap	d1				;get bit position info to update fail bitmask
		addq.w	#1,d1			;bump bit position to for next offset test
		swap	d1				;restore offset to lower word
		
		cmpi.b	#4,d1			;all offsets tried
		bls.s	dbs_lwb1		;no, do another


;;;;;;;;;;;;;;

;now do words

dbs_word	
		move.w	#$0011,d0		;initialize write pattern
		clr.w	d1				;init bit position holder and offset values
@dbs_lwb1	
		move.l	(a2),(a0)		;write background pattern 2 longwords
		move.l	(a2),4(a0)
		

		move.w	d0,(a0,d1.w)	;write pattern to ram lw + offset
		movem.l	(a0),d2-d3		;read back lw's on lw bounds
		movem.l	(a1)+,d4-d5		;get expected pattern from table
		cmp.l	d4,d2			;does 1st lw match expected
		bne.s	@dbs_lwb2		;no, skip mask update
		cmp.l	d5,d3			;how about 2nd lw
		bne.s	@dbs_lwb2		;no, skip mask update
		swap	d1				;get bit position info to update fail bitmask
		bclr.l	d1,d6			;clear appropriate bit to indicate pass this test
		swap	d1				;restore offset to lower word
@dbs_lwb2	
		addq.l	#1,d1			;bump address offset
		swap	d1				;get bit position info to update fail bitmask
		addq.w	#1,d1			;bump bit position to for next offset test
		swap	d1				;restore offset to lower word
		
		cmpi.b	#4,d1			;all offsets tried
		bls.s	@dbs_lwb1		;no, do another

;;;;;;;;;;;;;;;;;;;;;;;;

;and finally bytes

dbs_byte	
		clr.l	d0				;initialize write pattern
		clr.w	d1				;init bit position holder and offset values
@dbs_lwb1	
		move.l	(a2),(a0)		;write background pattern 2 longwords
		move.l	(a2),4(a0)
		

		move.b	d0,(a0,d1.w)	;write pattern to ram lw + offset
		movem.l	(a0),d2-d3		;read back lw's on lw bounds
		movem.l	(a1)+,d4-d5		;get expected pattern from table
		cmp.l	d4,d2			;does 1st lw match expected
		bne.s	@dbs_lwb2		;no, skip mask update
		cmp.l	d5,d3			;how about 2nd lw
		bne.s	@dbs_lwb2		;no, skip mask update
		swap	d1				;get bit position info to update fail bitmask
		bclr.l	d1,d6			;clear appropriate bit to indicate pass this test
		swap	d1				;restore offset to lower word
@dbs_lwb2	
		addq.l	#1,d1			;bump address offset
		swap	d1				;get bit position info to update fail bitmask
		addq.w	#1,d1			;bump bit position to for next offset test
		swap	d1				;restore offset to lower word
		
		cmpi.b	#4,d1			;all offsets tried
		bls.s	@dbs_lwb1		;no, do another
		RTS6					;return to caller


; From here to next <3> flag below was added for Ericson
;---------------------------------
; Moving Inversions Test (BIT).
;---------------------------------
;
;
;	Inputs:	a0 = bottom memory area to test
;			a1 = top of memory area to test + 1
;			a6 = return to caller
;
;	Output: d6 is the error accumulator.
;
MovInvTest	
		move.l	a0,a5			; save starting address
		move.l	a1,d3
		sub.l	a0,d3			; size of block to test		



@1      clr.l   (a0)+           ;set the memory to zero.
        sub.l   #4,d3
        bne     @1
;
; TOP OF FORWARD LOOP
        clr.l   d1
        move.w  #4,d1           ;Address increment, start at 4
@2      move.l  #0,a2           ;Address offset value
;
; TOP OF ADDRESS INCREMENT LOOP
@3      move.l  a5,a0           ;Starting address
        adda.l  a2,a0           ;...plus offset
;
; TOP OF BIT SET LOOP
        clr.l   d2              ;Bit to set
        clr.l   d4              ;Expect pattern
@4      move.l  a0,a3           ;Working start address
;
; TOP OF WORKING ADDRESS LOOP
@5      move.l  (a3),d3         ;Read
        cmp.l   d3,d4           ;...same as expected?
        bne     @100            ;...no, flag as error
        bset    d2,d3           ;Set the test bit
        move.l  d3,(a3)         ;...write, with test bit set
        move.l  (a3),d5         ;...read again
        cmp.l   d5,d3           ;...same as written?
        bne     @101            ;...no, flag as error
        adda.l  d1,a3
        cmp.l   a1,a3           ;At end of memory?
        bmi     @5
; BOTTOM OF WORKING ADDRESS LOOP
;
        move.l  d5,d4           ;New expect data
        add.w  #1,d2            ;Next bit
        cmp.w  #32,d2           ;...at end?
        bne    @4
; BOTTOM OF BIT SET LOOP
;
;
; TOP OF BIT CLR LOOP
        clr.l   d2              ;Bit to clear
        move.l  #$FFFFFFFF,d4   ;Expect pattern
@6      move.l  a0,a3           ;Working start address
;
; TOP OF WORKING ADDRESS LOOP
@7      move.l  (a3),d3         ;Read
        cmp.l   d3,d4           ;...same as expected?
        bne     @100            ;...no, flag as error
        bclr    d2,d3           ;Set the test bit
        move.l  d3,(a3)         ;...write, with test bit set
        move.l  (a3),d5         ;...read again
        cmp.l  d5,d3           ;...same as written?
        bne     @101            ;...no, flag as error
        adda.l  d1,a3
        cmp.l   a1,a3           ;At end of memory?
        bmi     @7
; BOTTOM OF WORKING ADDRESS LOOP
;
        move.l  d5,d4           ;New expect
        add.w  	#1,d2            ;Next bit
        cmp.w  	#32,d2           ;...at end?
        bne     @6
; BOTTOM OF BIT CLR LOOP
;
        adda.l 	#4,a2            ;Next address base offset
        cmp.l 	 d1,a2            ;...done all offsets?
        bne    	@3               ;...no, continue
; BOTTOM OF ADDRESS INCREMENT LOOP
;
;
        asl.l  #1,d1            ;New Address increment value
        cmp.l  #$80000,d1       ;...at end?
        bne    @2               ;...no, continue
; BOTTOM OF FORWARD LOOP

@99		move.l	a5,a0			; restore starting address
		rts6
;
@100    eor.l   d3,d4           ;...same as expected
        move.l  d4,d6
        bra     @99
;
@101    eor.l   d5,d3
        move.l  d3,d6
        bra     @99

; From here to next <3> flag above was added for Ericson
;---------------------------------------------------------------------------
;  No Test implemented
;
;---------------------------------------------------------------------------
NoTest	
		moveq	#0,d6
		RTS6
	
	
		ENDPROC

