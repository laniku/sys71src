;
;	File:		EGRET Manager.a
;
;	Contains:	Contains low level code to support sending and receiving
;				packets (ADB, Pseudo Commands, Ticks, etc) to/from the Egret
;				6805uC.
;
;	Written by:	Gary Rensberger
;
;	Copyright:	© 1990-1993 by Apple Computer, Inc.  All rights reserved.
;
;	Change History (most recent first):
;
;	  <SM19>	 11/9/93	KW		added some eieioSTP macros.  Only expands for CygnusX1 ROM.
;	  <SM18>	 9/29/93	SAM		From mc900ftjesus.
;	   <MC3>	 9/25/93	SAM		Whoot! What a mess.  Removed usless/redundant entry points and
;									imports/exports by the thousands.  Cleaned up tons of stuff.
;									Changed the labels of a few routines to reflect the fact that
;									they apply to both egret and cuda. Export ChkFirmware for
;									vectorization.  Backedout change <SM17>.
;	  <SM17>	 9/23/93	PN		Add condition for Egret
;	  <SM16>	 7/12/93	kc		Re-roll in ShiftRegIRQPatch to fix Quadra 900-950 ReadTime bug.
;	  <SM15>	 12/1/92	RB		Turned off the debug feature in Egret.
;	  <SM14>	11/20/92	GS		Removed the CudaPDMPatch from the initialization of the DFAC and
;									PDMs for Caboose or Cuda.  This initialization for Cyclone is
;									now done in the Gibbly.
;	  <SM13>	 11/3/92	SWC		Changed ShutdownEqu.a->Shutdown.a.
;     <SM12>    10/02/92    AEK     Conditionalize call to InitReliabitity to keep it from being
;                                   called twice if not on an overpatched ROM
;
;	  <SM11>	 9/18/92	GS		Debug Enter - removed PDMSuspend command.  DebugExit - add
;									MacsbugContinue command,   add Window update.  EgretDFACandPDM
;									routine - removed the Keybd NMI enable for the Cuda FW.  In the
;									Cuda FW, the command to enable/disable Keybd NMI no longer is a
;									valid command.  Keybd NMI is always enabled with the Cuda FW.
;	  <SM10>	 6/26/92	GS		(RBM)  Removed the Enable KeyboardNMI call made in the
;									EgretDFACandPDM
;									routine.  With the new version of Cuda FW (Cuda 0.22), the NMI
;									is always ON.
;									No longer has entry in the pseudo cmd table for SetDFACmode.
;									Instead, a new
;									command exists, called RdWrIIC to perform bidirectional IIC
;									transactions.
;									This requires special setup of the Cuda globals by the routine
;									'SetTransferParams' (see CudaMgr.a).
;									
;	   <SM9>	 5/24/92	RB		Removed the routine QuadraEgretChanges since EgretDFACandPDM is
;									a better version from the Pandora ROM. This routine gets called
;									from StartInit.a
;	   <SM8>	 5/24/92	RB		Removing "patches" as they get rolled into the other
;									sources...PowerSwitchIntPatch is out.
;	   <SM7>	 5/23/92	RB		Making Cyclone changes...Revised some patches rolled in from
;									Terror. Pandora comments follow: with some duplications... Note
;									that a lot of this code should be reworked with the ADBMgr, the
;									first step is to get it all in... **** From EgretPatches.a: <P2>
;									4/24/92 GS Added a Egret Dispatch call to suspend/continue PDM
;									when entering exiting Macsbug. This is to prevent problems of
;									determining whether or not to ignore PDM messages. **** From
;									EgretMgr.a: <P4> 2/10/92 GS Exported the PseudoTable for use by
;									the CudaMgr.a code. Cleaned up some comments. <P3> 02/07/92 jmp
;									Added some padding so that Pandora matches Horror. <P2> 1/16/92
;									GS Added code to determine the Egret Firmware Type (Egret8,
;									Caboose, Cuda), then set up the appropiate vectors for IRQ,
;									Ticks, Dispatcher...
; ———————————————————————————————————————————————————————————————————————————————————————
;	 								 Pre-Pandora ROM comments begin here.
; ———————————————————————————————————————————————————————————————————————————————————————
;		 				<5>	 2/20/91	BG		Fixed error in CheckPacket. The check for allowable
;									pseudo-packets was a hard-coded name check instead of an
;									end-of-table check.
;		 				<4>	12/11/90	JJ		Mac LC: Changes references to VISAChipBit to V8ChipBit.
;		 				<3>	 12/7/90	CCH		Adjusted the patch code in CheckPacket so that it fits in the
;									same number of bytes as the original code.
;		 				<2>	 12/6/90	BG		(with GA) Rolled in Eclipse-related Egret/Caboose changes.
;						<P9>	 4/24/92	GS		Removed DSorDebuggerPatch that was called from StartErr.a  New
;									code and PDM Selectors used by PDM removed the need.  Updated
;									the DebugUtil code in EgretPatches.a to handle these cases.
;						**** From EgretPatchesToo.a:
;						<P8>	 4/24/92	KW		(SWC,H5) Moved ADB and DebugUtil routines to ADBPrimitives.a.
;						<P10>	  4/10/92	gjs		Make Timer Mgr Task fire off a Cuda Tickle pkt every 3 sec 
;									instead of 7 secs.  Still having problem with 2nd User Alert
;									with mulitple hits to Keybd Reset key.  Also bump up the Timer
;									Timeout passed back to Cuda.
;						<P9>	  4/08/92	gjs		Upon installing a TimeMgr task to tickle Cuda during the User
;									alert, send a tickle to cover the first 7-10 seconds of the
;									display of the alert.
;						<P8>	  3/30/92	GS		The KeyBdSwHandler has been changed to set up a User Alert 
;									if the KeybdPower switch has been depressed, or if the 
;									chassis swithc or Secure Key switch has been used for a power down
;									a deferred Task will be executed, with out a User Alert.
;						<P7>	  3/17/92	GS		The PowerSwitch Int Handler has been changed to user the new
;									ShutDown mgr code in the system.  This makes all _ShutDown trap
;									calls with the selector set to 1 a soft power off.
;						<P6>	  3/3/92	GS		Update some Cuda Code to save some regs in Tickle timer code,
;									and begin to setup for the new power down msg to indicate kybd
;									or chassis sw power down.
;						<P5>	02/11/92	jmp		The EgretDFACandPDAM routine (which used to be the
;									EclipseEgretPatches routine) got bigger, so I moved it into the
;									pad space, with a branch from the original location.
;						<P4>	 2/11/92	GS		Update the Cuda Patches used to support SoftPower On/Off. Added
;									comments and revision tags. Updated a patch label from
;									EclipseEgretPatches to EgretDFACandPDM to better describe the
;									function of the patch. Also added functionality to the patch to
;									handle Caboose and Cuda firmware initializations.
;						<P3>	02/07/92	jmp		(jmp,H3/BG,Z19) Fixed ReGenSoundInt to wait in between disabling
;									and re-enabling sound interrupts.  Also changed ReGenSoundInt to
;									work like Kip originally intended (i.e. regenerate interrupts
;									only on the channel(s) that need it).
;						<P2>	 1/16/92	GS		Rolled in the newPatches that are associated with the Cuda
;									firmware for SoftPower On/Off.
; ———————————————————————————————————————————————————————————————————————————————————————
;	  								Pre-Pandora ROM comments begin here. (EgretPatchesToo)
; ———————————————————————————————————————————————————————————————————————————————————————
;						<H2>	12/21/91	jmp		(BG,Z18) Added code to re-generate sound interrupts when
;									checking the keyswitch values since reading port B causes
;									interrupts to get cleared (stupid design of original VIAs).
;
;	   <SM6>	 5/17/92	kc		Roll in Horror sources. (prepend via equates with v)
;	   <SM5>	 5/13/92	SES		Fixed bug in ShiftRegIrq patch roll in. Additional sr restore
;									instructions were added only where necessary instead of trying
;									to restore "globally" right before exiting.
;	   <SM4>	  5/5/92	SES		Rolled in patches from PatchIIciROM.a, including ShiftRegIrq
;									patch for saving/restoring sr, and addition of SCC polling in
;									EgretDispatch. Also fixed minor bug in tickHandler where
;									with/endwith directives were left out.
;	   <SM3>	  5/4/92	FM		fix typo
;	   <SM2>	  5/4/92	FM		Roll in changes from PatchIICiRom.a file that were "lost" in the
;									review process… Changing the TickHandler to update the Time
;									lo-mem global so that the RdDateTime can simply return whats in
;									the global.
;		<21>	 1/20/92	KC		Move RequestDonePatch into ADBMgr.a. Changed
;									CheckForCabooseKeyswitch into TestFor KeyswCabooseBit macro
;									call.
;		<20>	 1/13/92	kc		Added Terror changes, origional comments below.
;		 {?}						Added "Enable PDMMessage" and "SendDefault DFAC" to PseudoCntTable.
;		 {5}	 2/20/91	BG		Fixed error in CheckPacket. The check for allowable
;									pseudo-packets was a hard-coded name check instead of an
;									end-of-table check.
;		<19>	12/29/91	RB		Added Terror changes and rolled in patches to support Quadras.
;		<18>	 8/30/91	JSM		Cleanup header, don’t include SysErr.a since it’s in
;									StandardEqu.d.
;		<17>	 6/12/91	LN		removed #include 'HardwareEqu.a'
;		<16>	 4/24/91	dba		fix warning
;		<15>	10/22/90	JJ		Rex V8: Change VISAChipBit to V8ChipBit.
;		<14>	 5/15/90	GA		Removing calls to SCCPollDelay. Routine not needed.
;		<13>	  5/8/90	GA		Disabled all interrupts during interrupt handler to prevent
;									AppleTalk from interrupting Egret Manager and the issuing a
;									ReadXPram call which calls Egret Manager Synchronously. Changed
;									the Delay100 routine to SCCPollDelay. It polls and buffers any
;									serial data from the SCC and calls the Serial Driver PollProc
;									routine if one is present. Modified SendEgretCmd to have a retry
;									count to communicate with Egret. If the Retry count expires,
;									EgretMgr calls Error1Handler. Modified SendPtype to read the
;									interrupt flags register in the via 32767 times (≈41.9 millsecs
;									max) and then try send the packet type again based on the retry
;									count.
;		<12>	 4/25/90	GA		Fixed a bug with SendDFAC to allow 1 to 4 bytes to be sent to
;									Egret. Fixed a bug with the error reporting mechanism to return
;									all 4 bytes of the error packet returned by Egret.
;		<11>	 4/10/90	GA		Fixed a bug in the error checking code. Made a change to make
;									KeyLite program work (returns parameter block byte count
;									unchanged).
;		<10>	  4/2/90	GA		Removing the Routine Read LastByte from the SendEgretCmd code.
;									Also, fixing lines of source which have had their C/R changed to
;									a Null ($00) character. We suspect that Romlister may trash
;									source files which are open during the build.
;		 <9>	 3/30/90	GA		Added Error reporting for bad parameter blocks from the system
;									to Egret.
;		 <8>	 3/22/90	GA		Changed the Via_Full Ack process on the last byte of
;									transactions to clarify the Logic Analyzer displays.
;		 <7>	 3/15/90	GA		Ray and I added conditionalized code to send Stop Autopoll and
;									send mode 0 one second interrupt command s in place of the
;									SendNOPCmd to support the B3 release of Egret. This code will be
;									inactivated when the final Egret parts come in.
;		 <6>	 3/13/90	GA		Added a routine called SENDNOPCMD. This routine is register
;									driven and issues a command to Egret to Stop AutoPoll and one
;									second interrupts in Egret
;		 <5>	  3/9/90	GMR		Optimized code in a few places. Moved assertion of SysSes bit to
;									after test of XcvrSes, to fix bug on 2 byte tick packets.
;		 <4>	 2/28/90	GMR		Rewrote file.
;		 <3>	 2/14/90	GA		Added support code for Restart & shutdown in Egret. Issues stop
;									autopoll & stop 1 sec interrupts prior to restarting the system.
;		 <2>	  2/9/90	GA		1. Added two calls to DelayLoop to give Egret time to see
;									transitions of SysSession signal.
;
;									2. SendWithCheck & SynChkSend now wait for the shift register
;									   interrupt bit to be asserted before exiting when a transaction
;									   is aborted.
;
;									3. Moved code which sends bitmap and starts autopoll to Egret into
;									   EgretMgr.a.  ADBMgr now issues a JSR StartEgretAutopoll to do
;									   the same function.  This makes the Erickson overpatch easier.
;
;		 <1>	  2/3/90	GA		first checked in
;
************************************************************************
				machine		mc68020

				BLANKS		ON
				STRING		ASIS

				PRINT		OFF
				LOAD		'StandardEqu.d'
				INCLUDE		'EgretEqu.a'
				INCLUDE		'HardwarePrivateEqu.a'
				INCLUDE		'UniversalEqu.a'
				INCLUDE		'IOPEqu.a'
				INCLUDE		'AppleDeskBusPriv.a'
				INCLUDE		'ShutDown.a'
				INCLUDE		'FSEqu.a'
				INCLUDE		'PowerPrivEqu.a'
				PRINT		ON

				include		'EgretEqu.a'
				eject

EgretDebug		EQU		0

EgretMgr		PROC		EXPORT

				EXPORT		InitEgretOrCuda, EgretDispatch, CheckPacket
				EXPORT		PseudoCntTable, ADBCntTable, SetResponseParams, ChkFirmware

				IMPORT		GetHardwareInfo, Error1Handler
				IMPORT		CudaDispatch,CudaShiftRegIRQ,CudaTickHandler
				IMPORT		CudaInit, SendCudaCmd

rayFix			EQU		1				; needed to fix Egret bug on old parts
ErrEgretInit	equ		$0030			; TEMPORARY definition of error equate defined in STEQU.a


			WITH 	EgretGlobals,EgretPB,RespHeader			; <60> rb
;===============================================================================================
;	Routine:	InitEgret
;
;	Function:	Allocates globals, sets vACR to shift in mode, sets up globals for an auto-response
;				packet (ADB/Ticks).
;
;	Inputs:		none
;
;	Outputs:	none
;
;	Destroys:	a0-a2, d0-d2
;________________________________________________________________________________________________
InitEgretOrCuda
			moveq.l #EgretGlobSize,D0			; get size of globals
			_NewPtr ,SYS,CLEAR					; allocate space on heap and clear

			move.l	a0,EgretBase				; save ptr to it
			movea.l	a0,a2						;

			move.w	sr,-(sp)					; save irq enable status
			ori.w	#HiIntMask,sr				; mask out interrupts

			lea		workPb(a2),a0				; pointer to work parameter block 	<SM7> rb
			move.l	a0,adbPb(a2)				; store in adb parameter block		<SM7> rb
			
			bsr		SetResponseParams			; setup globals to handle auto response packets again

			bsr.l	ChkFirmware					; Set up dispatch,IRQ, and ticks (Sets up _EgretDispatch trap)
			move.l  a0,Lvl1DT+8	        		; the level 1 dispatch table
			move.l	a1,tickComp(a2)				; set up default tick packet handler
			
			movea.l	VIA,a1						; point to the VIA
		eieioSTP
			bclr.b	#SRdir,vACR(a1)				; shift reg direction = input
		eieioSTP
			move.b	#(1<<ifIRQ)|\
						(1<<ifSR),vIER(a1)		; enable shift register interrupts
		eieioSTP
			move.w	(sp)+,sr					; restore interrupts
			rts


;________________________________________________________________________________________________
;	Routine:	EgretDispatch
;
;	Function:	This is the Egret manager trap routine.  It waits for Egret to be idle, sends
;				the first byte of the command packet.  If Egret didn't abort, then it sets up
;				globals for the IRQ handler, and if a completion routine was specified, it returns
;				back to the caller.  If no completion routine, then it waits synchronously for
;				the command/response to finish, using the busy bit.  When the IRQ handler has finished
;				the response packet, it preps the globals to expect an auto-response packet
;				(ticks or ADB), clears 'busy' and calls the completion routine (if any).
;
;	Inputs:		a0	-	pointer to parameter block
;
;	Outputs:	d0	-	result (0 for now)
;
;	Destroys:	a0-a2, d0-d1
;________________________________________________________________________________________________
EgretDispatch
			bsr		CheckPacket					; Validate the Packet type & command byte
			bne		@done						; Exit if Error packet
			movea.l	EgretBase,a2				; a2 gets ptr to globals
			movea.l	VIA,a1						; a1 points to VIA base



@checkSpecial
			cmpi.b	#specialPkt,pbCmdType(a0)	; is this a special command?						<SM7> rb
			bne.s	@ckPDMInit					; check for Eclipse PowerDown Message Initialization <SM7> rb
			
			move.l	a0,ADBpb(a2)				; yes, is to set the ADB param block (for autopoll data). <SM7> rb
			bra		@done						;														<SM7> rb

@ckPDMInit										;														<SM7> rb
;
;		Check for Eclipse PowerDown Message Vector
;		Initialization.
;
			cmpi.b	#PDMVectPkt,pbCmdType(a0)	; check for PowerDown message vector Init <60> rb	<SM7> rb
			bne.s	@EgretRestart				; Must be Egret Command		<60> rb	<SM7> rb
			
			move.l	pbParam(a0),PDMComp(a2)		; handler for Eclipse PowerDown Message Packet <60> rb <SM7> rb
			bra		@done						; and exit

@EgretRestart

	
			move.w	sr,-(sp)					; save SR
 			ori.w	#hiIntMask,sr				; mask interrupts
		eieioSTP
			btst.b	#xcvrSes,vBufB(a1)			; does Egret want to abort?
		eieioSTP
			beq.s	@abort						; yes, wait for it to go away
			bset.b	#busy,flags(a2)				; not an abort, mark that we're busy.
		eieioSTP
			beq.s	@sendPackType				; we were not busy before, so try to send the first byte

@abort		move.w	(sp)+,sr					; we were busy, enable interrupts
			bsr		pollByte					; poll shift reg, calling handler if interrupts masked

			bra.s	@EgretRestart				; and keep waiting for busy to go away...

@sendPackType									; interrupts masked here
		eieioSTP
			bset.b	#sysSes,vBufB(a1)			; assert System Session (we're starting command packet)
		eieioSTP
			bset.b	#SRdir,vACR(a1)				; switch to output
		eieioSTP
			move.b	pbCmdType(a0),vSR(a1)		; send command packet to shift reg
		eieioSTP
			bset.b	#viaFull,vBufB(a1)			; tell Egret we sent it
		eieioSTP

;<SM4><SES> Rolled in from PatchIIciROM.a
;----------------------------------------------------------------------------------------------------
;	This patch fixes possible loss of data to the SCC by calling
;	the Poll Proc when SCC data is available.
;
;	NOTE: This is a slightly modified version of the one from PatchIIciROM.a
;----------------------------------------------------------------------------------------------------
;_________________________
;		If PollProc exists, Poll the SCC and save any available data
;		When the shift register irq comes in call the PollProc
;		then process the shift register irq data
;
			movem.l	d0/d1/a0-a4/a6,-(sp)		; save some registers

			move.l	sp,PollStack				; Pointer to buffer for polled bytes

		eieioSTP
			btst.b	#0,SccIopFlag				; Check if we are in IOP mode (On Eclipse...)
		eieioSTP
			beq.s	@NoPollWait					; If IOP then we don't need to poll

			tst.l	PollProc					; Check for a Poll Proc available
			beq.s	@NoPollWait					; If no Poll Proc then we don't need to poll

			movea.l	SccRd,a3					; SCC may have data to get
			movea.l	a3,a6
			addq.l	#Actl,a3					; Point to data available register (RR0)
			addq.l	#AData,a6					; Point to the SCC data register

@wait
		eieioSTP
			btst.b	#RxCa,(a3)					; Test for SCC data available
		eieioSTP
			beq.s	@2
			move.b	(a6),-(sp)					; Push the data on the stack
@2			
		eieioSTP
			btst.b	#vShift,vIFR(a1)			; now wait for shift reg IRQ

		eieioSTP
			beq.s	@wait

			cmpa.l	PollStack,SP				; Is there any poll data
			beq.s	@NoSCCData
;
;		We have SCC data and a Poll Proc to call.  Go call it
;
			pea		@NoSCCData					; Return addr for PollProc
			move.l	PollProc,-(SP)				; Point to the PollProc
			rts									; Call the PollProc


@NoPollWait
		eieioSTP
			btst.b	#vShift,vIFR(a1)			; now wait for shift reg IRQ
		eieioSTP

			beq.s	@NoPollWait

@NoSCCData	movem.l	(sp)+,d0/d1/a0-a4/a6		; restore work registers

@VsrIrq
		eieioSTP
			btst.b	#xcvrSes,vBufB(a1)			; did Egret abort?
		eieioSTP
			bne.s	@accepted					; no, then it will accept our packet
			bclr.b	#SRdir,vACR(a1)				; yes, switch back to input
		eieioSTP
			bclr.b	#sysSes,vBufB(a1)			; ack the abort
		eieioSTP
			bsr		CallShiftRegIRQ				; handle it
		eieioSTP
			bra.s	@abort						; and wait

;<SM4><SES> end of EgretDispatch SCC poll fix

@accepted										; we sent the packetType, now set up for the IRQ handler
			jsr		SetTransferParams			; setup globals for this packet
			bsr		CallShiftRegIRQ				; transfer second byte (command) to start things
			move.w	(sp)+,sr					; now enable interrupts
		eieioSTP

			tst.l	pbCompletion(a0)			; do we have a completion routine
		eieioSTP
			bne.s	@done						; yes, then return asynchronously

@waitComplete
			btst.b	#busy,flags(a2)				; otherwise, are we still busy?
		eieioSTP
			beq.s	@done						; no, then we're done...
			
			bsr.s	pollByte					; yes, poll out a byte if necessary	
	
;  	bclr.b	#busy,flags(a2)				; otherwise, are we still busy?

			bra.s	@waitComplete				; and wait here (synchronously)

@done		moveq	#0,d0						; no errors for now
			rts

;________________________________________________________________________________________________
;
;		Validate the Packet type and Command if Pseudo Pkt.
;
;		If an error is encountered with the packet a error packet will be
;		built in the pbParam area of the parameter block as if Egret had
;		returned the packet.  Also, the pbResult field will contain a System
;		error code for bad parameter block format.
;
;		Entry: A0 = Parameter block pointer
;
;		Exit:	sr.Z = 0 if valid  packet/pseudocmd nonzero otherwise
;
_________________________________________________________________________________________________

CheckPacket
			cmp.b	#SpecialPkt,pbCmdType(a0)	; could be an ADB initialization packet
			beq.s	@OkExit
			
			cmp.b	#PDMVectPkt,pbCmdType(a0)	; could be PowerDown message Vector Init Packet <60> rb
			beq.s	@OKExit						; if equal, CONTINUE <60> rb

			cmp.b	#ErrorPkt,pbCmdType(a0)		; ADB ($00) and Pseudo ($01) only
			bhi.s	@BadPkt						; Invalid packet

			cmp.b	#PseudoPkt,pbCmdType(a0)	; Check for pseudo commands
			bne.s	@OkExit						; On Pseudo Packets check the command

			cmp.b	#MaxPseudoCmd,pbCmd(a0)		; Validate the Pseudo command number   {5}
			bls.s	@OkExit

@BadPseudo	move.w	#InvPseudo,pbParam(a0)		; report a pseudo command error
			move.w	pbCmdType(a0),pbParam+2(a0)	; we are faking an error packet
			bra.s	@ErrorExit

@BadPkt		move.w	#InvPkt,pbParam(a0)			; report invalid packet error
			move.w	pbCmdType(a0),pbParam+2(a0)	; we are faking an error packet

@ErrorExit	move.w	#paramErr,pbResult(a0)		; parameter error in result field
			bra.s	@Exit

@OkExit		move.w	#0,pbResult(a0)				; So far packet OK
@Exit		rts

;________________________________________________________________________________________________
;	Routine:	PollByte
;
;	Function:	This routine checks to see if level 1 interrupts are masked, exits if not.
;				If masked, it polls the flag register for a shift reg interrupt, and
;				calls the handler if found.
;
;	Inputs:		a1	-	VIA base ptr
;				a2	-	globals pointer
;
;	Outputs:	none
;
;	Destroys:	d0,d1
;________________________________________________________________________________________________
PollByte

			move.w	sr,d0						; get 68xxx interrupt mask
			andi.w	#hiIntMask,d0				; are we at interrupt level?
			beq.s	@exit						; no, just exit
		eieioSTP
			btst.b	#vShift,vIFR(a1)			; yes, poll the shift reg
		eieioSTP
			beq.s	@exit						; no shift reg interrupt, return
			bsr.s	CallShiftRegIRQ				; yes, handle it
@exit		rts


;________________________________________________________________________________________________
;	Routine:	SendByte
;
;	Function:	This routine clears viaFull bit, delays 125us, sends a byte to the shift reg,
;				then asserts viaFull bit.
;
;	Inputs:		d0	-	byte to send
;				a1	-	VIA base ptr
;
;	Outputs:	none
;
;	Destroys:	d1
;________________________________________________________________________________________________
SendByte
		eieioSTP
			bclr.b	#viaFull,vBufB(a1)			; negate via full
		eieioSTP
			bsr.s	Delay100					; give Egret time to see it
		eieioSTP
			move.b	d0,vSR(a1)					; send the byte to the shift reg
		eieioSTP
			bset.b	#viaFull,vBufB(a1)			; let Egret know it's there
		eieioSTP
			rts

;________________________________________________________________________________________________
CallShiftRegIRQ
			movem.l	a0-a3/d0-d3,-(sp)			; save regs like interrupt handler does
			movea.l  Lvl1DT+8,a0	        	; get the shift reg IRQ handler
			jsr		(a0)						; call it
			movem.l	(sp)+,a0-a3/d0-d3			; restore regs
			rts

;________________________________________________________________________________________________
viaFullAck
		eieioSTP
			bset.b	#viaFull,vBufB(a1)			; acknowlege the byte
		eieioSTP
			bsr.s	Delay100					; give Egret time to see it
		eieioSTP
			rts									; gets cleared on exit from IRQ handler

;________________________________________________________________________________________________
Delay100
			move.l	d1,-(sp)					; save d1
			move.w	timeViaDB,d1				; 1 ms loop count
			lsr.w	#3,d1						; / 8 = 125 us
		;	cmpi.b	#boxQuadra900,boxFlag		; is this a Quadra900 ?		<60> rb
		;	bne.s	@loop						; no ? then skip			<60> rb
			add.w	#EclipseDelay,d1			; <60> rb, we need an extra 25 usecs on Eclipse <GAA Eclipse>
@loop
		eieioSTP
			tst.b	(a1)						; access the VIA
		eieioSTP
			dbra	d1,@loop
			move.l	(sp)+,d1					; restore d1
		eieioSTP
			rts

;________________________________________________________________________________________________
;	Routine:	ShiftRegIRQ
;
;	Function:	This routine is called in response to a VIA shift reg interrupt.  It will transfer
;				the next byte in the current packet.  When the packet is complete, the globals are
;				prepped for an auto-response packet (ADB/Ticks), then the completion routine
;				is called (if present).
;
;	Inputs:		a1	-	VIA base ptr
;
;	Outputs:	a2	-	globals pointer
;
;	Destroys:	a0-a2,d0,d1
;________________________________________________________________________________________________
			EXPORT	ShiftRegIRQ

ShiftRegIRQ
			move.w	sr,d3
			ori.w	#hiIntMask,sr				; mask interrupts <13>
			movea.l	EgretBase,a2				; get ptr to globals <13>
			bset.b	#busy,flags(a2)				; make sure we're marked as busy
		eieioSTP

			btst.b	#SRdir,vACR(a1)				; see if VIA direction is output
		eieioSTP
			beq.s	@input						; no, then we're receiving..

			tst.b	vSR(a1)						; clear the shift reg interrupt
		eieioSTP
			tst.w	sendHdrCnt(a2)				; any bytes left in header?
			ble.s	@ckSendData					; no, see if any send bytes left...

			movea.l	sendHdrPtr(a2),a0			; get ptr to header
			move.b	(a0)+,d0					; get next header byte
			move.l	a0,sendHdrPtr(a2)			; and update header ptr
			bsr		SendByte					; send the byte
			subq.w	#1,sendHdrCnt(a2)			; count it
			move.w	d3,sr						; restore interrupts							<SM5><SES>
			bra		@exit						; and exit
@ckSendData
			tst.w	sendDataCnt(a2)				; any bytes left in data to send
			ble.s	@CmdFinished				; no, then we're finished with command packet
			movea.l	sendDataPtr(a2),a0			; get current data ptr
			move.b	(a0)+,d0					; yes, get next data byte
			move.l	a0,sendDataPtr(a2)			; and update the ptr
			bsr		SendByte					; send it
			subq.w	#1,sendDataCnt(a2)			; count it
			move.w	d3,sr						; restore interrupts							<SM5><SES>
			bra		@exit						; and exit
@CmdFinished
		eieioSTP

			bclr.b	#SRdir,vACR(a1)				; now switch to input
@sendCmd
		eieioSTP
			andi.b	#~((1<<viaFull) | \			; negate VIA full bit
					   (1<<sysSes)),vBufB(a1)	; negate System Session
		eieioSTP
			bsr.s	Delay100					; give Egret time to see System Session
			move.w	d3,sr						; restore interrupts							<SM5><SES>
			bra		@exit						; and exit

@input		;-----------------------------------------------------------------------------
		eieioSTP
			move.b	vSR(a1),d0					; read the byte from shift reg into D0
		eieioSTP
			tst.w	rcvHdrCnt(a2)				; any bytes left in response packet header?
			ble.s	@ckRcvData					; if not then must be data byte

@getHdrByte	
		eieioSTP
			btst.b	#sysSes,vBufB(a1)			; is System Session asserted?
		eieioSTP
			bne.s	@notFirst					; yes, then this is not the first byte
			bsr.s	Delay100					; delay 100us
			bra.s	@stuff
@notFirst
			bsr.s	viaFullAck					; acknowlege the byte using via full
@stuff		move.w	rcvHdrIndex(a2),d1			; get index into header
			lea		rcvHeader(a2),a0			; point to header buffer
			move.b	d0,(a0,d1.w)				; store byte away
			addq.w	#1,rcvHdrIndex(a2)			; bump to next byte
			subq.w	#1,rcvHdrCnt(a2)			; count it
			ble.s	@CheckError					;  <12>
		eieioSTP
			btst.b	#xcvrSes,vBufB(a1)			; is Egret done?
		eieioSTP
			bne.s	@done						; yes, we're through...
			bset.b	#sysSes,vBufB(a1)			; make sure System Session is asserted			<5>
		eieioSTP
			bra		@exitRd						; not done with header yet... exit

@ckRcvData
			movea.l	rcvDataPtr(a2),a0			; get ptr to receive data buffer
			move.b	d0,(a0)+					; store the data byte
			move.l	a0,rcvDataPtr(a2)			; and update header ptr
			subq.w	#1,rcvDataCnt(a2)			; count it
			bgt.s	@ack						; not last, normal acknowlege
			btst.b	#openData,flags(a2)			; is this an open ended data packet?

		eieioSTP		
			beq.s	@ack						; no, normal acknowlege
			bsr.s	viaFullAck					; acknowlege the byte using via full <8>
		eieioSTP
			bclr.b	#sysSes,vBufB(a1)			; yes, let Egret know we don't want more <8>
@wait
		eieioSTP
			btst.b	#xcvrSes,vBufB(a1)			; wait for egret to acknowledge termination <8>
		eieioSTP
			beq.s	@wait						; branch until xcvr session goes high <8>
			bra.s	@done						; and we're done

;
;		If we have an error packet in progres then read 5 bytes instead of 4 for the header. <12>
;		A flag will be set on the fourth byte of an error packet and will be cleared <12>
;		after reading the fifth byte of the error packet. <12>

@CheckError	lea		rcvHeader(a2),a0			; point to header buffer <12>
			cmp.b	#ErrorPkt,1(a0)				; check packet type for error packet <12>
			bne.s	@CheckDone					; not an error packet go check for data <12>

			bclr.b	#BadPkt,flags(a2)			; check for error packet in progress flag <12>
			bne.s	@CheckDone					; we read the fifth byte of the error packet <12>
@readbyte5	addq.w	#1,rcvHdrCnt(a2)			; adjust the count before reading the fifth byte <12>
			bset.b	#BadPkt,flags(a2)			; set the flag then read the fifth byte <12>
			bra		@exitRd						; <12>

;
;		Acknowledge the data byte
;
@ack		bsr.s	viaFullAck					; normal byte, acknowlege it
@checkDone	
		eieioSTP
			btst.b	#xcvrSes,vBufB(a1)			; was that Egrets last byte?
		eieioSTP
			bne.s	@done						; yes, we're through...
			tst.w	rcvDataCnt(a2)				; any receive data bytes to get?
			bgt		@exitRd						; yes, then just exit

			;---------------------------------------------------------------------------
@done	
		eieioSTP
			bclr.b	#viaFull,vBufB(a1)			; make sure via full is low
		eieioSTP
			bclr.b	#sysSes,vBufB(a1)			; let Egret know we're done
		eieioSTP
			bsr		delay100					; Give Egret time to see transitions & Poll SCC <13>

			movea.l	curPb(a2),a0				; a0 points to current param block
			lea		rcvHeader(a2),a1			; a1 points to header buffer <11>
			cmp.b	#ErrorPkt,1(a1)				; check for Error response packet <11>
		eieioSTP
			bne.s	@NotError
;
;		The current transaction generated an Error <11>
;
			move.l	1(a1),pbParam(a0)			; Return the Error Response packet to the caller (dont include attn byte) <11>
			move.w	#paramErr,pbResult(a0)		; and return a parameter block error <11>

@NotError	cmpa.l	adbPb(a2),a0				; was this an implicit command?
			beq.s	@implicit					; yes, handle autopoll/tick packet

			tst.b	1(a1)						; is this an ADB response?
			bne.s	@ckComp						; no, then data already transfered, call completion

@adbResp
		IF rayFix THEN
			cmpa.l	adbPb(a2),a0				; is this autopoll data
			bne.s	@skip						; no, don't fix ray's flag
			bset.b	#EgAutoPoll,2(a1)			; yes, fix em
		eieioSTP
@skip
		ENDIF

			btst.b	#EgAutoPoll,2(a1)			; check status, is this AutoPoll data?
		eieioSTP
			bne		@ckAutoPollComp				; yes, handle if we have completion routine

			move.b	2(a1),pbFlags(a0)			; explicit ADB command, stuff flags byte
			move.w	rcvHdrIndex(a2),d0			; get header+data byte count
			subq.w	#4,d0						; - header bytes
			beq.s	@dontupdate					; if no data received don't update the byte count <11>
			move.w	d0,pbByteCnt(a0)			; stuff data byte count
@dontupdate	move.l	pbBufPtr(a0),a2				; get users buffer ptr
			addq.w	#4,a1						; point at the data
			bra.s	@cnt
@xfer		move.b	(a1)+,(a2)+					; copy the byte
		eieioSTP
@cnt		dbra	d0,@xfer					; repeat for all bytes

			move.l	EgretBase,a2				; get globals ptr again

@ckComp		move.l	pbCompletion(a0),d0			; any completion routine?
			beq		@exitNoComp					; no, just exit

			move.l	d0,a1						; yes, get it's address
			move.l	a0,-(sp)					; save param block ptr
			bsr		SetResponseParams			; setup globals to handle auto response packets again
			move.w	d3,sr						; restore interrupts
			move.l	(sp)+,a0					; restore param block ptr
			jmp		(a1)						; and call it


;--------------------------------------------------------------------------------------------
; AutoPoll or Tick data, push it on stack and call completion rtn

@implicit
			tst.b	RespPktType(a1)				; is this an ADB response?		<SM16>.start
			beq.s	@ckAutoPollComp				; yes, handle it

			cmpi.b	#tickPkt,RespPktType(a1)	; is this a short tick response?
			beq.s	@ckTickComp					; yes, handle it (has no param block)

			cmpi.b	#PDMPkt,RespPktType(a1)		; is this a PowerDown Message Packet?
			beq.s	@ckPowerDownComp			; yes, handle it

			cmpi.b	#pseudoPkt,RespPktType(a1)	; is this a pseudo command?
			bne.s	@InvalidPacket				; no, something is wrong
			
			cmpi.b	#RdTime,RespCmd(a1)			; is this a read time response?
			beq.s	@ckTickComp					; yes, handle it

@InvalidPacket			
		IF	EgretDebug	THEN					; We have an invalid packet

			pea		@InvPktStr					; call Macsbug
			_DebugStr
			bra.s	@exitNoComp					; exit without completion

@InvPktStr	dc.b	$14,'INVALID EGRET Packet'	; Egret error string
			align
		Else
			bra.s	@exitNoComp					; exit without completion
		Endif

@ckPowerDownComp
												; call service routine if it exists. 		<SM16>.end
			move.l	PDMComp(a2),d2				; get the completion routine address
			beq.s	@exitNoComp					; go away if vector is null
			move.l	d2,a3						; call the Service routine
			move.b	RespCmd(a1),d0				; get the powerDown Switch destination position
			bsr.l	SetResponseParams			; setup globals to handle auto response packets again
			move.w	d3,sr						; restore interrupts
			jsr		(a3)
			bra.s	@exit


@ckTickComp										; tick data, check for completion routine
			move.l	tickComp(a2),d2				; get completion routine in d2
			beq.s	@exitNoComp					; none specified, just exit
			bra.s	@push						; otherwise, push response packet on stack, call it.


@ckAutoPollComp									; ADB autopoll data, check for completion rtn
		IF rayFix THEN
			bset.b	#EgAutoPoll,2(a1)			; Set AutoPoll bit to fix bug in old Egret parts
		ENDIF
			tst.l	a0							; do we really have a current param block? (we should)
			beq.s	@exitNoComp					; no, exit

			move.l	pbCompletion(a0),d2			; any completion routine? (keep in d2)
			beq.s	@exitNoComp					; no, just exit

@push		suba.w	#12,sp						; allocate 12 byte buffer on stack
			movea.l	sp,a2						; point to the buffer
			move.l	(a1)+,(a2)+					; copy response header 	onto stack
			move.l	(a1)+,(a2)+					; copy response data 	onto stack
			move.l	(a1)+,(a2)+					; copy response data 	onto stack
			movea.l	EgretBase,a2				; restore ptr to globals
			move.w	rcvHdrIndex(a2),d0			; d0 = # bytes in response header
			subq.w	#4,d0						; byte count = # data bytes (strip off header bytes)
			bsr		SetResponseParams			; setup globals to handle auto response packets again
			move.w	d3,sr						; restore interrupts

			move.l	sp,a1						; a1 = ptr to response packet
			addq.l	#2,a1						; a1 = ptr to status flag
			move.l	d2,a3						; get completion routine
			jsr		(a3)						; call it (a0 points to param block for ADB)

			adda.w	#12,sp						; pop buffer
			bra.s	@exit						; and exit

@exitNoComp										; no completion routine specified,
			bsr		SetResponseParams			; setup globals to handle auto response packets again
			move.w	d3,sr						; restore interrupts
			bra.s	@exit						; and exit

@exitRd	
		eieioSTP
			bclr.b	#viaFull,vBufB(a1)			; make sure via full is low
		eieioSTP
			move.w	d3,sr						; restore interrupts							<SM5><SES>
@exit		rts




;________________________________________________________________________________________________
;	Routine:	SetTransferParams
;
;	Function:	This routine sets up transmit/receive ptrs (globals) for the packet pointed to by A0,
;				for use by the Shift Reg interrupt handler.
;
;	Inputs:		a0	-	Param block pointer
;				a2	-	Ptr to globals
;
;	Outputs:	none
;	Destroys:	d0,d1
;________________________________________________________________________________________________
SetTransferParams
			move.l	a1,-(sp)						; save a1
			lea		pbCmd(a0),a1
			move.l	a1,sendHdrPtr(a2)				; point to 1st byte of header to send
	eieioSTP
			moveq	#0,d0
			move.b	pbCmd(a0),d0					; get command

			tst.b	pbCmdType(a0)					; is this an ADB command?
			bne.s	@pseudo							; no, must be a pseudo command

			andi.b	#%00001111,d0					; keep low 4 bits
			lea		ADBCntTable,a1					; get ptr to our ADB command table
			bra.s	@check							; and look up our send/rcv byte counts

;
;	Pseudo Command. Now Check for SEND DFAC and treat as special case if it is. <12>
;	On DFAC, use the byte count in the parameter block as the count to send <12>
;	to Egret instead the count contained in the PseudoCntTable. <12>
;
@pseudo
			cmp.b	#WrDFAC,pbCmd(a0)				; check for DFAC <12>
			bne.s	@notDFAC						; use the table if not DFAC <12>

			move.w	pbByteCnt(a0),d1				; was Write DFAC use the byte count in the pBlock <12>
			addq.w	#1,d1							; include the packet byte already sent <12>
			move.w	d1,sendHdrCnt(a2)				; set up header byte count <12>
	eieioSTP
			move.w	#0,sendDataCnt(a2)				; do not send the bytes as data also <12>
	eieioSTP
			clr.w	sendDataCnt(a2)					; no extended data bytes <12>
	eieioSTP
			clr.l	sendDataPtr(a2)					; no extended data ptr <12>
	eieioSTP
			bra.s	@rcvParams

@notDFAC	lea		PseudoCntTable,a1				; get ptr to our pseudo command table
@check		lsl.w	#1,d0							; x 2 for word table
			move.w	(a1,d0.w),d1					; get send/rcv byte counts for this command

			ror.w	#8,d1							; get send byte count in low byte
			tst.b	d1								; is this an open-ended send command?
			bmi.s	@sendExt						; yes, branch...
			move.b	d1,d0							; get byte count from table
			ext.w	d0								; extend to word
			addq.b	#1,d0							; data bytes + 1 = header byte count
			move.w	d0,sendHdrCnt(a2)				; set up header byte count
	eieioSTP
			clr.w	sendDataCnt(a2)					; no extended data bytes
	eieioSTP
			clr.l	sendDataPtr(a2)					; no extended data ptr
	eieioSTP
			bra.s	@rcvParams						; now setup receive ptrs

@sendExt	moveq	#$7F,d0							; prepare to mask sign
			and.w	d1,d0							; get rid of sign
			addq.w	#1,d0							; + 1 for command (packet type already sent)
			move.w	d0,sendHdrCnt(a2)				; set up header byte count
	eieioSTP
			move.w	pbByteCnt(a0),sendDataCnt(a2)	; set up data byte count
	eieioSTP
			move.l	pbBufPtr(a0),sendDataPtr(a2)	; set up send data ptr
	eieioSTP

@rcvParams	clr.w	rcvHdrIndex(a2)					; reset index into header buffer
	eieioSTP
			move.w	#4,rcvHdrCnt(a2)				; 4 byte header default
	eieioSTP
			asr.w	#8,d1							; get receive data byte count
			bmi.s	@rcvExt							; branch for open-ended reads

			tst.b	pbCmdType(a0)					; reading, is this a pseudo command?
			beq.s	@rcvADB							; no, must be adb data

			lea		pbParam(a0),a1					; pseudo data will be received in pbParam
	eieioSTP
			move.l	a1,rcvDataPtr(a2)
	eieioSTP
			move.w	d1,rcvDataCnt(a2)				; get receive count from table
	eieioSTP
			bra.s	@exit							; and exit

@rcvADB		add.w	d1,rcvHdrCnt(a2)				; total header bytes = 4 + ADB data
	eieioSTP
			clr.w	rcvDataCnt(a2)					; not used
	eieioSTP
			bclr.b	#openData,flags(a2)				; this is not an open ended data packet (readPram, read6805)
			bra.s	@exit

@rcvExt		move.w	pbByteCnt(a0),rcvDataCnt(a2)	; set up received data byte count
	eieioSTP
			move.l	pbBufPtr(a0),rcvDataPtr(a2)		; set up received data buffer ptr
	eieioSTP
			bset.b	#openData,flags(a2)				; this is an open ended data packet (readPram, read6805)

@exit		move.l	a0,curPb(a2)					; set up current param block
	eieioSTP
			movea.l	(sp)+,a1						; restore a1
			rts

;________________________________________________________________________________________________
;	Routine:	SetResponseParams
;
;	Function:	This routine sets up transmit/receive ptrs (globals) for an auto response packet
;				(e.g. ticks, ADB autopoll data), for use by the Shift Reg interrupt handler.
;
;	Inputs:		a2	-	Ptr to globals
;
;	Outputs:	none
;
;	Destroys:	none
;________________________________________________________________________________________________
SetResponseParams
			clr.l	sendHdrPtr(a2)					; no command packet params
			clr.w	sendHdrCnt(a2)					;
			clr.w	sendDataCnt(a2)					;
			clr.l	sendDataPtr(a2)					;

			move.w	#12,rcvHdrCnt(a2)				; receive up to 12 response header bytes
			clr.w	rcvHdrIndex(a2)					; reset response header index
			clr.w	rcvDataCnt(a2)					; no extended data bytes
			clr.l	rcvDataPtr(a2)					; no receive data buffer
			move.l	adbPb(a2),curPb(a2)				; point to adb's autopoll param block

			andi.b	#~((1<<busy)|\					; we're not busy now
					   (1<<openData)),flags(a2)		; we're not expecting an open ended data packet

			rts


; <SM4><SES> put back function banner
;________________________________________________________________________________________________
;	Routine:	tickHandler
;
;	Function:	This is the completion routine for tick response packets.
;
;	Inputs:		a2		-	ptr to globals
;				(sp)	-	points to response packet
;
;	Outputs:	none
;
;	Destroys:	???
;________________________________________________________________________________________________
; <SM22> FM This patch was rolled in from the PatchIIciRom.a file.
; <SM22> FM Its purpose is to keep the tim lo-mem up to date at
; <SM22> FM interrupt time so that the RdDateTime trap can simply
; <SM22> FM read the Time lo-mem global.
;----------------------------------------------------------------------------------------------------
;	This patch fixes a bug in Egret Manager TickHandler routine.						<89><101>
;	The routine will store the 32 bit time passed by Egret to the
;	system if the packet is a ReadRealTime into TIME lowmen.
;	Decrements the lowmem Time by one to compensate for the interrupt
;	Handler incrementing it by one and then calls the LVL1DT interrupt
;	handler.
;	If the packet is a tick packet then it calls LVL1DT to increment the
;	time setting and check the alarm state.
;
;	Entry:
;		A1.l = Points at Response data buffer At Flags byte:
;
;			+---------+----------+---------+---------+---------//-------+
;			| Attn    | Pkt Type | Flags   | Pkt Cmd | 8 Bytes data Max |
;			+---------+----------+---------+---------+---------//-------+
;
;		A2.l = Points at Egret Manager Globals
;
;----------------------------------------------------------------------------------------------------
			EXPORT	TickHandler
TickHandler
			WITH	respPacket,EgretGlobals					; <SM4><SES>
			
			subq.l	#2,a1									; <SM22> FM point to the beginning of the Response data buffer
			cmpi.b	#TickPkt,respPacket.respType(a1)		; <SM22> FM Check the Packet type
			beq.s	@CallLVL1DT								; <SM22> FM If tick packet just call LVL1DT handler
;
;	The packet was a readTime packet from Egret.  Update the Time lowmem and
;	adjust it to compensate for the increment in the LVL1DT handler.
;
			move.l	respPacket.respData(a1),Time			; <SM22> FM write the new time in lowmem TIME
			subq.l	#1,Time									; <SM22> FM adjust to compensate for increment in LVL1DT
;
;	JUMP to routine pointed to by the Contents of LVL1DT
;
	
@CallLVL1DT
	
			move.l	VIA,a1						; point to the VIA
			move.l	LVL1DT,a0					; get vector
			jmp		(a0)

			ENDWITH								; <SM4><SES>


;________________________________________________________________________________________________
; These tables contain the transmit byte count and receive byte counts for each Egret command,
; one table for pseudo commands, and one table for ADB commands.
;
;	tx byte cnt
;	____________
;	bit 7		=	1 means pbByteCnt = number of data bytes to send after header
;	bit	6-0		=	# of pbParam bytes to send	(in header)
;
;	rx byte cnt
;	____________
;	bit 7		=	1 means open ended read call (e.g. read6805, readPram)
;	bit	6-0		=	Pseudo Cmds: 	# of pbParam bytes to read into (after 4 byte header)
;	bit	6-0		=	ADB Cmds: 		# of data bytes to read into pbBufPtr
;________________________________________________________________________________________________

PseudoCntTable
			dc.b	$00,	$00			; 00 NoOperation		send 0 bytes, 	receive 0 data bytes
			dc.b	$01,	$00			; 01 StartStopAutopoll	send 1 byte, 	receive 0 data bytes
			dc.b	$02,	$FF			; 02 Read6805			send 2 bytes, 	receive n data bytes
			dc.b	$00,	$04			; 03 ReadClock			send 0 bytes, 	receive n data bytes
			dc.b	$00,	$02			; 04 GetRomSize			send 0 bytes, 	receive 2 data bytes
			dc.b	$00,	$02			; 05 GetRomBase			send 0 bytes, 	receive 2 data bytes
			dc.b	$00,	$02			; 06 GetRomHeader		send 0 bytes, 	receive 2 data bytes
			dc.b	$02,	$FF			; 07 ReadPRAM			send 2 bytes, 	receive n data bytes
			dc.b	$82,	$00			; 08 Write6805			send 2+n bytes, receive 0 data bytes
			dc.b	$04,	$00			; 09 SetClock			send 4 bytes, 	receive 0 data bytes
			dc.b	$00,	$00			; 0A PowerDown			send 0 bytes, 	receive 0 data bytes
			dc.b	$04,	$00			; 0B SetPowerUp			send 4 bytes, 	receive 0 data bytes
			dc.b	$82,	$00			; 0C WritePRAM			send 2+n bytes, receive 0 data bytes
			dc.b	$01,	$00			; 0D SetResetFlag		send 1 bytes, 	receive 0 data bytes
			dc.b	$01,	$00			; 0E SendDFAC			send 1 bytes, 	receive 0 data bytes
			dc.b	$00,	$02			; 0F RunDiags			send 0 bytes, 	receive 2 data bytes
			dc.b	$00,	$01			; 10 CtrlEnabSense		send 0 bytes, 	receive 1 data bytes
										; 10 BatterySense		send 0 bytes, 	receive 1 data bytes
			dc.b	$00,	$00			; 11 Restart			send 0 bytes, 	receive 0 data bytes
			dc.b	$01,	$00			; 12 SetVpp				send 1 bytes, 	receive 0 data bytes
										; 12 SetIPL				send 1 bytes, 	receive 0 data bytes
			dc.b	$01,	$00			; 13 SetFileServer		send 1 bytes, 	receive 0 data bytes
			dc.b	$01,	$00			; 14 SetAutoPoll		send 1 bytes, 	receive 0 data bytes
			dc.b	$00,	$02			; 15 GetPramSize		send 0 bytes, 	receive 2 data bytes
			dc.b	$00,	$01			; 16 GetAutoPollRate	send 0 bytes, 	receive 1 data bytes
			dc.b	$01,	$00			; 17 SetBusDelay		send 1 bytes, 	receive 0 data bytes
			dc.b	$00,	$01			; 18 GetBusDelay		send 0 bytes, 	receive 1 data bytes
			dc.b	$02,	$00			; 19 SetDevList			send 2 bytes, 	receive 0 data bytes
			dc.b	$00,	$02			; 1A GetDevList			send 0 bytes, 	receive 2 data bytes
			dc.b	$01,	$00			; 1B SetOneSecMode		send 1 bytes, 	receive 0 data bytes
			dc.b	$01,	$00			; 1C SetKbdNMI			send 1 bytes, 	receive 0 data bytes
			dc.b	$01,	$00			; 1D SetPostParse		send 1 bytes, 	receive 0 data bytes
			dc.b	$01,	$00			; 1E SetHangTime		send 1 bytes, 	receive 0 data bytes
			dc.b	$00,	$01			; 1F GetHangTime		send 0 bytes, 	receive 1 data bytes
			dc.b	$80,	$00			; 20 SendDefault DFAC	send 0-4 bytes, receive 0 data bytes	{?} rb
			dc.b	$01,	$00			; 21 Enable PDMMessage	send 1 bytes, 	receive 0 data bytes	{?} rb
			dc.b	$00,	$00			; 22 RdWrIIC			send n bytes, 	receive n data bytes	<S2> [rbm]
			dc.b	$01,	$00			; 23 Set WakeUpMode		send 1 bytes, 	receive 0 data bytes	<T2><SM7> rb
			dc.b	$01,	$00			; 24 Tickle PDM Timer	send 1 bytes, 	receive 0 data bytes	<T2><SM7> rb


ADBCntTable
			dc.b	$00,	$00			; 0000	SendReset	send 0 bytes, 	receive 0 data bytes
			dc.b	$00,	$00			; 0001	Flush		send 0 bytes, 	receive 0 data bytes
			dc.b	$00,	$00			; 0010				send 0 bytes, 	receive 0 data bytes
			dc.b	$00,	$00			; 0011				send 0 bytes, 	receive 0 data bytes
			dc.b	$00,	$00			; 0100				send 0 bytes, 	receive 0 data bytes
			dc.b	$00,	$00			; 0101				send 0 bytes, 	receive 0 data bytes
			dc.b	$00,	$00			; 0110				send 0 bytes, 	receive 0 data bytes
			dc.b	$00,	$00			; 0111				send 0 bytes, 	receive 0 data bytes
			dc.b	$80,	$00			; 10xx	Listen		send n bytes, 	receive 0 data bytes
			dc.b	$80,	$00			; 10xx	Listen		send n bytes, 	receive 0 data bytes
			dc.b	$80,	$00			; 10xx	Listen		send n bytes, 	receive 0 data bytes
			dc.b	$80,	$00			; 10xx	Listen		send n bytes, 	receive 0 data bytes
			dc.b	$00,	$08			; 11xx	Talk		send 0 bytes, 	receive 8 data bytes max
			dc.b	$00,	$08			; 11xx	Talk		send 0 bytes, 	receive 8 data bytes max
			dc.b	$00,	$08			; 11xx	Talk		send 0 bytes, 	receive 8 data bytes max
			dc.b	$00,	$08			; 11xx	Talk		send 0 bytes, 	receive 8 data bytes max



			EndWith


			Eject
;=========================================================================
; Routines: 	EgretInit
;
; This routine sends a NOP/WarmStart command to Egret.  This routine is
; called early during rom Startup to stop autopoll and 1 sec irq.  Also,
; the routine will issue a Send DFAC command to Egret to initialize the
; the DFAC hardware to a known state.  The routine does not use ANY
; memory it is register driven only.
;
; NOTE:	This routine actually sends a STOP AUTO POLL, SET ONE SECOND
;		INTERRUPT MODE 0 call and a SEND DFAC command to Egret.
;		The Stop Autopoll and set one second interrupt modes calls will
;		be changed to a single NOP/WarmStart when Egret 3 becomes
;		available (S/B 4/6/90).
;
; Inputs:	NONE
;
; Outputs:	NONE
;
; Destroys:	D0, D1, D2, D3, A1, A5, A6, A4	(Egret 2 implementation)
; Destroys:	D0, D3, A1, A5, A6				(Egret 3 implementation)
;
;	NOTE: This routine is called via a BSR6 and returns via a RTS6
;-------------------------------------------------------------------------
			EXPORT	EgretInit

EgretInit	movea.l	DecoderInfo.VIA1Addr(a0),a1		; get VIA 1 base address
		eieioSTP
			bclr.b	#vSyssesbit,vBufB(a1)	; kill any pending transactions <8> <13>
		eieioSTP
			bclr.b	#vViafullbit,vBufB(a1)	; <8> <13>
		eieioSTP
			moveq	#$28,d0					; we want to delay 4 millisecs
@killtime	bsr5	delay100us				; in 100 usec increments
			dbra	d0,@killtime
			move.l	a6,a4					; save the return address

		if		rayFix	then
;
;	Send the Stop autopoll pseudo command
;
			move.l	#(APoll << 16) + PseudoPkt,d0	; first command to send is Stop Auto Poll
			moveq	#0,d1					; sending one byte of data $00 = stop autopoll
			moveq	#1,d2
			bsr6	SendEgretCmd			; send the command to Egret
			tst.w	d0						; check for an error
			bne.s	@exit					; failed to send the command (hang timeout expired)
;
;	Send the mode 0 1 second interrupt pseudo command
;
			move.l	#(Wr1SecMode << 16) + PseudoPkt,d0	 ; mode 0 1 sec interrupts (stop 1 second irq)
			moveq	#0,d1					; sending one byte of data
			moveq	#1,d2
			bsr6	SendEgretCmd			; send the command to Egret
			tst.w	d0						; negative if error
			bne.s	@exit					; failed to send the command (hang timeout expired)

		else
;
;	Send the NOP/WarmStart command
;
			move.w	#NopCmd,d0				; Nop/WarmStart stops autopoll and 1 sec irq
			swap	d0						; packet type Pseudo
			move.w	#pseudopkt,d0
			moveq	#0,d2					; no data to send
			bsr6	SendEgretCmd			; send the command to Egret
			tst.w	d0						; nonzero if error
			bne.s	@exit					; failed to send the command (hang timeout expired)

		endif

;
;	Send Elsie/Erickson initial DFAC setting
;
		with	ProductInfo

			moveq	#0,d2						; force full scan of hardware features <10>
			bsr6	GetHardwareInfo				; get the ProductInfo Record <9>
			btst.b	#v8chipbit,ExtValid+3(a1)	; See if system has a VISA chip (bit7)<9><10>
			beq.s	@Erickson					; 0 = No Visa (Erickson) 1 = Visa (Elsie) <9>

			move.l	#ElsieDFAC,d1				; Assume running on Erickson (Not Elsie) <9>
			bra.s	@sendit

@Erickson	move.l	#EricksonDFAC,d1				; Erickson DFAC setting <9>
@sendit		move.l	#(WrDFAC << 16) + PseudoPkt,d0	; Send DFAC command
			moveq	#1,d2							; One byte to send
			bsr6	SendEgretCmd					; send the command to Egret
			tst.w	d0								; negative if error
@exit		move.l	a4,a6							; restore return address
			rts6									; return to the caller

			endwith

				eject
************************************************************************************************************
* SendEgretCmd:	This register based routine will send up to four bytes of data to Egret.  The
*				packet type, command, byte count and data are passed in registers.  The routine
*				will return with d0.w = $0000 if it sent the command successfully.  A value of
*				$FFFF signifies that the command did not get through.  The system and Egret hung
*				and the system aborted the transaction.
*
*	WARNING:	This routine will not error check the transaction requested.  It is  the responsibility of
*	WARNING:	the caller to make sure that the packet type, command, data and data byte count are valid
*	WARNING:	for the transaction requested.  Failure to follow the rules will make this routine fail and
*	WARNING:	CRASH the system.
*
*		Input:
*				a0.l	Pointer to Base address table
*
*				d0.l =  High word PACKET Command
*						Low word PACKET Type
*
*				d1.l =	Up to four bytes of data to send
*						Long word data byte assigment = byte 4, byte 3, byte 2, byte 1
*						Byte 1 sent out first
*
*				d2.l = 	Byte count to send. (0-4 bytes)
*						Byte count > 4 will send four bytes only
*
*		Output:	d0.w	$0000 if call succeeded, Nonzero if failed
*
*				d1.l	high word = flags, low word packet type returned by Egret
*
*		Destroys:	D2.l, D3.l, D4.l, A5.l, A4.l, A1.l
*
************************************************************************************************************

			Export	SendEgretCmd
SendEgretCmd
			movea.l	DecoderInfo.VIA1Addr(a0),a1			; get VIA 1 base address				<P2> <SM7> rb, start
			move.l	#((MaxTout<<16) OR MaxRetries),d4	; number of retries before giving up with Egret <13>
			bsr5	Delay100us
		eieioSTP
			btst.b	#vsysSesBit,vBufB(a1)	; check for a transaction in progress
		eieioSTP
			beq.s	@AllOK

@Timeout
		eieioSTP
			bclr.b	#vsysSesBit,vBufB(a1)	; kill the rest of the transaction <8>
		eieioSTP
			bclr.b	#vViaFullBit,vBufB(a1)	; <8>
		eieioSTP
			bsr5	Delay100us				; in progretss <8>
  			bsr5	Delay100us				; <8>

@AllOK		swap.w	d4						; timeout in low word of d4 Retry count in high word <13>
		eieioSTP
			btst.b	#vxcvrSesBit,vBufB(a1)	; check for abort pending
		eieioSTP
			beq		IrqMissed				; MIssed Vsr Irq because of INITVIAS
			bset	#vsysSesBit,vBufB(a1)	; assert sysSesBit
		eieioSTP
			bsr5	@SendPtype				; send the packet type
			beq		RealAbort				; Discard Aborting transaction					<SM7> rb, end
;
;	If not abort transaction in progress then send the command byte
;
			swap	d0
			bsr5	sendByte1				; send the command byte
			bsr5	delay100us				; give Egret time to see viaEmpty
;
;	Now send number of bytes contained in d1 based on
;	byte count contained in d2.w
;
			move.l	d1,d0					; get the data to send
			subq	#1,d2					; adjust for DBRA
			cmp.w	#3,d2					; if count out of range quit
			bhi.s	@EndCmd					; if count valid then adjust for dbra
@sendloop	bsr5	sendByte1
			bsr5	delay100us
			lsr.l	#8,d0					; move data byte to low byte of register
@loopEntry	dbra	d2,@sendloop			; decrement byte count
;
;	Wait for the response packet header
;
@EndCmd		
		eieioSTP
			bclr.b	#SRdir,vACR(a1)			; shift in
		eieioSTP
			bclr.b	#vSyssesbit,vBufB(a1)	; negate vSyssesbit
		eieioSTP
			bsr5	Delay100us
;
;	Now receive the Standard Response packet Header
;
			bsr5	readAttn				; get the Attention byte
		eieioSTP
			bsr5	Delay100us
		eieioSTP
			bset.b	#vSyssesbit,vBufB(a1)	; assert vSyssesbit
		eieioSTP
			bsr5	readByte				; get the packet type
			and		#$00FF,d0				; keep low byte only
			swap	d0						; save the packet type
			bsr5	readByte				; get the flags byte
			and.w	#$00FF,d0				; keep low byte only
			swap	d0						; keep the flags byte as an error code
			exg		d0,d1					; save the packet type and flags returned
			bsr5	readByte				; get the command
		eieioSTP
			bclr.b	#vSyssesbit,vBufB(a1)	; negate vSyssesbit
		eieioSTP
			bsr5	Delay100us
;
;	Check for an error packet returned by Egret
;
			move.l	d1,d0					; save the packet type and flags
			cmp.b	#errorpkt,d0			; check for error packet
			beq.s	@Exit					; error pkt then just exit
			sub.w	d0,d0					; zero for success
@exit		rts6

;--------------------------------------------------------------------------
@SendPtype									;												<2>
		eieioSTP
			bset.b	#SRdir,vACR(a1)			; shift out
		eieioSTP
			btst.b	#vXcvrsesbit,vbufB(a1)	; check for abort
		eieioSTP
			beq.s	@AbortReq				; go away if abort requested
			move.b	d0,vSR(a1)				; load byte into shift reg
		eieioSTP
			bset.b	#vViafullbit,vBufB(a1)	; indicate shift reg is full
		eieioSTP
;
;	Check Vsr Irq until timeout.  If timeout then check the retry count
;	and Call Death Chimes if Retry count exausted.
;
@PollDelay		
		eieioSTP
			btst.b	#ifSR,vIFR(a1)			; wait for shift to complete
		eieioSTP
			bne.s	@VsrIrq					; Go service Shift register Irq <13>
			dbra.w	d4,@PollDelay			; try again if timed out <13><SM7> rb
			move.w	#MaxTout,d4				; Reset the Timeout <13><SM7> rb
			swap.w	d4						; get the Retry count <13><SM7> rb
			subq.w	#1,d4					; Try again if Retry count not Exausted <13><SM7> rb
			beq.s	@Timeout				; <13>

@DeadEgret	move.w	#ErrEgretInit,d7		; Egret failed <13>
			move.l	#0001,d6				; d6.l must be nonzero <13>
			bigjmp	Error1Handler,a3		; Play death chimes <13>

@VsrIrq	
		eieioSTP
			tst.b	vSR(a1)					; clear the interrupt
		eieioSTP
			bclr.b	#vViafullbit,vBufB(a1)	; now indicate shift reg empty
		eieioSTP
;
;		Delay 100 usec
;
			move.w	#DelayCnt,d3
@wait20		
		eieioSTP
			tst.b	(a1)					; sync to VIA clock
		eieioSTP
			dbra	d3,@wait20				; delay at least 100 us (very rough)
		eieioSTP
			btst.b	#vXcvrsesbit,vbufB(a1)	; check for abort
		eieioSTP
@AbortReq	rts5

;--------------------------------------------------------------------------
; DumpAbort	This routine will read all the data for an abort transaction and
;			discard it.  When done it will jump back to SendNopCmd entry point
;			to retry our command.  This command will eventually complete...

RealAbort
		eieioSTP
			bclr.b	#vSyssesbit,vBufB(a1)	; deassert system session
		eieioSTP
IrqMissed	bsr5	Delay100us				; Let Egret see SysSes. ≥ 125µsec
		eieioSTP
			bclr.b	#SRdir,vACR(a1)			; shift in
		eieioSTP
			tst.b	vSR(a1)					; discard the byte
		eieioSTP
			bset	#vSyssesbit,vBufB(a1)	; assert vSyssesbit
		eieioSTP

DumpAbort

		eieioSTP
		bclr	#vViafullbit,vBufB(a1)	; then negate VIA full bit
		eieioSTP

@loop
		eieioSTP
			btst.b	#ifSR,vIFR(a1)			; wait for shift to complete
		eieioSTP
			beq.s	@loop
			bset.b	#vViafullbit,vBufB(a1)	; acknowlege byte
		eieioSTP
			tst.b	vSR(a1)					; discard the byte
		eieioSTP
;
;		Delay 100 usec
;
			move.w	#DelayCnt,d3 
@wait
		eieioSTP
			tst.b	(a1)					; sync to VIA clock 
			dbra	d3,@wait				; delay at least 100 us (very rough)
 		eieioSTP
			btst.b	#vXcvrsesbit,vBufB(a1)	; check for last byte
		eieioSTP
			beq.s	DumpAbort				; Clock Tick Packets only 2 bytes
;
;		Last byte was read
;
			bclr	#vViafullbit,vBufB(a1)	; then negate VIA full bit
		eieioSTP
			bclr.b	#vSyssesbit,vBufB(a1)	; negate vSyssesbit
		eieioSTP
			bsr5	Delay100us				; delay 200 usec
			bra.s	SendEgretCmd			; go try sending our command again

;--------------------------------------------------------------------------
sendByte1									;												<2>
		eieioSTP
			bset.b	#SRdir,vACR(a1)			; shift out
		eieioSTP
			move.b	d0,vSR(a1)				; load byte into shift reg
		eieioSTP
			bset.b	#vViafullbit,vBufB(a1)	; indicate shift reg is full
		eieioSTP
@poll	
		eieioSTP
			btst.b	#ifSR,vIFR(a1)			; wait for shift to complete
		eieioSTP
			beq.s	@poll
			tst.b	vSR(a1)					; clear the interrupt
		eieioSTP
			bclr.b	#vViafullbit,vBufB(a1)	; now indicate shift reg empty
		eieioSTP
			rts5

;--------------------------------------------------------------------------
readByte	
		eieioSTP			
			btst.b	#ifSR,vIFR(a1)			; wait for shift to complete
		eieioSTP
			beq.s	readByte
			bset.b	#vViafullbit,vBufB(a1)	; Tell Egret we saw the byte
		eieioSTP
			move.b	vSR(a1),d0				; read the byte
;
;		Delay 100 usec
;
		eieioSTP
			move.w	#DelayCnt,d3
@wait
		eieioSTP
			tst.b	(a1)					; sync to VIA clock
		eieioSTP
			dbra	d3,@wait				; delay at least 100 us (very rough)
		eieioSTP
			bclr	#vViafullbit,vBufB(a1)	; then negate VIA full bit
		eieioSTP
			rts5

;--------------------------------------------------------------------------
readAttn
		eieioSTP

			btst.b	#ifSR,vIFR(a1)			; wait for shift to complete
		eieioSTP
			beq.s	readAttn
		eieioSTP
			tst.b	vSR(a1)					; clear the interrupt
		eieioSTP
			rts5

;--------------------------------------------------------------------------
delay100us	
		move.w	#DelayCnt,d3
;	add.w	d3,d3						; let's make it even rougher
@wait
		eieioSTP
			tst.b	(a1)					; sync to VIA clock
		eieioSTP
			dbra	d3,@wait				; delay at least 100 us (very rough)
		eieioSTP
			rts5

;_______________________________________________________________________
;
;  Routine:		EclipsePDMPatch
;
;  Desc:		Patch for ECLIPSE PowerDown Messsage Handler Install
;				and PowerDown Message Enable
;_______________________________________________________________________

			EXPORT	EclipsePDMPatch
EclipsePDMPatch	
			WITH	EgretPB
;
;		Initialize the Eclipse PowerDown Message handler.
;
			movem.l	a0-a1,-(sp)						; work registers
			suba.l	#EgretPbSize,sp					; make room for PB
			move.l	sp,a0							; point a0 to pbBuffer									<T3>
			move.w	#(PDMVectPkt << 8),pbCmdType(a0); InitPDM Vector Packet (Cmd ignored)
			clr.l	pbCompletion(a0)				; No Completion
			lea		KeySwitchHandler,a1				; address of keyswitch sense handling					<T5>
			move.l	a1,PbParam(a0)
			_EgretDispatch

; •••••••••••••••••••••••••••••••••••••••••••••••••
;	We don't want to enable messages where we set up the Power Down Message Handler.  This is because		<T10>
;	up until the time a system is located to boot from, when the user turns the keyswitch OFF, there		<T10>
;	are no files to flush, no volumes to unmount and Caboose can safely turn the machine off with us		<T10>
;	getting in the way.  Once we get a system loaded, we'll enable Power Down Messages with the other		<T10>
;	routine, EclipsePDEPatch() (see below).																	<T10>
; •••••••••••••••••••••••••••••••••••••••••••••••••

;	We need to allocate a TimeMgr TMTask record that we can use once we enable power down messages so		<T15>
;	we can power the machine down even if UnMounts fail or hang.  ExpandMemRec has JUST been initialized	<T15>
;	when this patch gets called, so this is safe to do.														<T15>

		WITH	ExpandMemRec

			movea.l	expandMem,a1					; get base of ExpandMemRec								<T15>
			moveq.l	#(tmQSize+dtQElSize),d0			; request a TimeMgr TMTask+Deferred Task-sized record in SysHeap		<T15>
			_NewPtr	,SYS,CLEAR						;														<T15>
			move.l	a0,emKeyTMTaskPtr(a1)			; save pointer to TMTask record in ExpandMemRec			<T15>
		ENDWITH
			adda.l	#EgretPbSize,sp					; discard the parameter block
			movem.l	(sp)+,a0-a1						; restore registers
@EgretDone
			
			rts										; Return to Caller

;_______________________________________________________________________
;
;	Eclipse Keyswitch Handler
;	-------------------------
;
;		This routines either
;			(1) turns off Eclipse, or
;			(2) catches and ignores keyswitch changes interrupts
;			from Caboose, since we look directly at the keyswitch
;			position values on VIA2[PB][v2Keyswitch] or [v2PowerOff].
;
;		As of DVT hardware, the values of these keyswitch positions
;		should be available on VIA2 and no longer need to be maintained
;		in SW.
;_______________________________________________________________________
;
;		PowerDown Message Handler
;
			export	KeySwitchHandler				;														<T5>
			import	EgretPowerOff					; from EgretPatches.a									<T14>
			
KeySwitchHandler									; Handler of Power Down / Keyswitch Sense messages		<T5>

;	Caboose sends a message whenever the keyswitch sense changes.											<T5> thru next <T5>
;
;	Input:  D0.B		Keyswitch position
;
;				0			OFF
;				1			Secure
;				2			Insecure or ON ("normal")
;	

			tst.b	d0								; check for PowerOff message							<T10>
			bne.s	@rts							; IF Message == PowerDOWN THEN							<T10>

			movem.l	a0-a1,-(sp)						; save A0, A1											<T15> thru next <T15>

;	First, install a time manager task that will forcefull shut us down in 5 seconds.  That way,
;	in case something goes wrong with the deferred task, we will shut off anyway.

		WITH	ExpandMemRec

			movea.l	expandMem,a1					; get base address of ExpandMemRec
			movea.l	emKeyTMTaskPtr(a1),a0			; retrieve "final" Time Mgr queue element
			movea.l	a0,a1							; use A1 to clear the record
			moveq.l	#((tmQSize+dtQElSize)/2)-1,d0	; clear the TimeMgr+DeferredTask queue elements
@clrRec		clr.w	(a1)+							; just in case someone has crapped them up
			dbra	d0,@clrRec
			lea		PullThePlug,a1					; get address of where to go when timer expires
			move.l	a1,tmAddr(a0)					; tell the TimeMgr about it
			_InsTime								; go install the Turn Off The Power Time Mgr task
			move.l	#(5*1000),d0					; set timeout to be 5 SECONDS
			_PrimeTime								; activate the task

;	Now install the Deferred Task that will attempt to unmount all mounted volumes.
;
;	The ExpandMemRec Ptr points at an area that is tmQSize+dtQSize bytes big.
;
;	Initialize the Deferred Task queue element to point at our Unmount Volumes Deferred Task.

			adda.w	#tmQSize,a0						; move A0 to point at the Deferred Task Queue Element
			move.w	#dtQType,dtType(a0)				; and initialize the record
			lea		EclipseAdios,a1
			move.l	a1,dtAddr(a0)
			jsr		([jDTInstall])					; go install our Unmount and Shutdown deferred task
			movem.l	(sp)+,a0-a1						; restore A0, A1
			tst.w	d0								; see whether or not deferred task install was done
			bne.s	PullThePlug						; if it failed, shut down RIGHT NOW
@rts		rts										; if it was successful, return to the int. handler

		ENDWITH

;_______________________________________________________________________
;
;	Routine:	EclipseAdios
;
;	Desc:		Deferred Task installed when the keyswitch is turned
;				to the OFF position.  This attempts to Unmount all
;				volumes.  Once that attempt has been made, the system
;				is powered down.
;
;	Inputs:		None.
;	Returns:	None.
;	Trashes:	The System.  Power to Eclipse is turned off.  G'night.
;
;_______________________________________________________________________

EclipseAdios

;	Try and unmount any mounted volumes before we power down.

			move.l	VCBQHdr+qHead,a1				;   Start at the head of the VCBQ
			bra.s	@checkVCB						;   Check if valid
@UMloop
			tst.w	vcbFSID(a1)						;   Make sure it’s FSID = 0
			bne.s	@nextQEntry						;   ... i.e. not a server

; Try to unmount the volume.

			sub.w	#ioQElSize,a7					;   get an I/O param block
			movea.l	a7,a0
	
			move.w	vcbVRefNum(a1),ioVRefNum(a0)	;   stuff VCB VRefNum into PB
			move.l	#0,ioFileName(a0)
			move.l	#0,ioCompletion(a0)				;   no completion routine
			move.l	a1,-(sp)						;   save A1 (queue link ptr)
			_HUnmountVol							;   attempt to forcefully unmount volume
			movea.l	(sp)+,a1						;   restore A1
			adda.w	#ioQElSize,a7					;   get rid of PB.  we'll reallocate the PB if needed

@nextQEntry	movea.l	qLink(a1),a1					;   get next queue entry
@checkVCB	move.l	a1,d0							;   at EOQ yet?
			bne.s	@UMloop							;   nope, try this one

PullThePlug											; ENDIF
			bsr.l	EgretPowerOff					; power junkies go into sudden withdrawl				<T16>
			bra.s	PullThePlug						; with no hope of recovery								<T16>

;_______________________________________________________________________
;
;  Routine:		EclipseDFACPatch
;
;  Desc:		Patch for ECLIPSE send default DFAC Messsage
;_______________________________________________________________________
			EXPORT	EclipseDFACPatch

EclipseDFACPatch
;
;		Build a Parameter block for the default DFAC message
;
			movem.l	a0-a1,-(sp)						; work register
			suba.l	#EgretPbSize,sp					; make room for PB
			move.l	sp,a0							; point a0 to pbBuffer									<T4>
			move.w	#(pseudoPkt << 8) \
					+ SetDefDFAC,pbCmdType(a0)		; InitPDM Vector Packet (Cmd ignored)
			clr.l	pbCompletion(a0)				; No Completion
;
;	Build the DFAC message issue the call and clean up
;
			move.w	#$0100,-(sp)					; byte count and one DFAC byte in buffer
			move.l	sp,pbBufPtr(a0)					; Buffer pointer
			move.w	#$0002,pbByteCnt(a0)			; byte count includes the byte count byte in the buffer
			_EgretDispatch
			adda.l	#EgretPbSize+2,sp				; discard the parameter block and data buffer
			movem.l	(sp)+,a0-a1
@EgretDone
			rts										; Return to Caller

;_______________________________________________________________________									<T16> thru next <T16>
;
;  Routine:		DebugUtilRunKbdPatch
;
;  Desc:		Checks to see if the machine we're running on has a
;				keyswitch, and if so, if it's in the OFF position.
;				If so, then we probably don't have any choice as to
;				whether volumes can be flushed and unmounted, so we
;				go directly to the PowerOff routine.  Do not pass Go,
;				do not collect $200.  (is that 200 hex dollars?)
;
;  NOTE:		This handles both the DebugEnter _and_ DebugPoll cases.
;_______________________________________________________________________

			EXPORT		DebugUtilRunKbdPatch		; provide address to InterruptHandlers.and anyone else
DebugUtilRunKbdPatch

			TestFor	KeyswCabooseBit					; do we have a caboose?			<21>
			beq.s	@justDoIt						;  nope							<21>

;	If you made it here, you're a Caboose-flavor keyswitch.
;
;	VIA2 has v2PowerOff and v2Keyswitch (SECURE mode) wired, with 0=TRUE.

			move.l	a1,-(sp)						;     save A1 temporarily
			movea.l	VIA2RBV,a1						;     retrieve address of VIA2
		eieioSTP
			btst.b	#v2PowerOff,VBufB(a1)			;     is the keyswitch OFF?
		eieioSTP
			move.l	(sp)+,a1						;     restore A1
			beq.s	@powerOff						;     IF Keyswitch != OFF THEN
@justDoIt
			bra		DebugPwrMgrADBPatch2			;         check for PowerMgr stuff
@powerOff											;     ELSE
			bra.s	PullThePlug						;         administer the death blow						<T16>

DebugPwrMgrADBPatch2
			TestFor	hwCbPwrMgr				; see if we have a power manager
			beq.s	@noPmgrADB				; if not, skip it

			movea.l	VIA,a1					; point to the VIA
			movea.l	Lvl1DT+(ifCB1*4),a0		; get the handler address
			jsr		(a0)					; call the interrupt handler
			addq.l	#4,SP					; clean up stack from bsr			
			movem.l	(sp)+,d3/a3				; restore registers
			rts
@noPmgrADB
			rts	

;_______________________________________________________________________
;
;  Routine:		EgretDFACandPDM			formerly:	EclipseEgretPatches				<P4><MC2>
;
;  Desc:		Calls egret patches for Eclipse with Caboose, keyswitch
;				Calls Egret patches for Anyone with Cuda, SoftPower Off
;_______________________________________________________________________

				EXPORT	EgretDFACandPDM
				IMPORT	CudaPDMPatch

EgretDFACandPDM	

			move.l	#EgretFWMask, d0				; get productInfo record mask for Egret FW
			and.l	UnivRomFlags,d0					; isolate the field
			sub.l	#Caboose,d0						; Do we have an Egret/Caboose?
			bne.s	@Done							; -> Nope. Don't do nothing!

	; Instead of calling EclipseDFACPatch, this should more generally initialize DFAC
	; for all machines that care about it (or even if we don't but it needs it anyway).
	;	-- bg/djw, 12/6/90

@EgretCaboose
			bsr		EclipseDFACPatch				; call the Eclipse DFAC control patch
			bsr		EclipsePDMPatch					; call the Eclipse keyswitch/PowerDown Msgs patch
@Done		rts										; Return to Caller


;--------------------------------------------------------------------------
;ChkFirmware																		<P2>
;
;	This routine will determine if the Egret Chip is using Egret 8 or Caboose
;	firmware or the new Cuda firmware.  Based on this result, the IRQ handler,
;	Dispatcher, and Tick handler vectors are set up...
;	Inputs:
;		A2	->	EgretGlobals
;	Outputs:
;		A0 	->	ShiftRegIRQ	
;		A1	->	TickHandler
;	Trashes:
;		A0,A1

			
ChkFirmware											;								<P2>
			movem.l	a2/d0-d2, -(sp)					; preserve used regs

			move.l	#EgretFWMask,d0					; mask for EgretFW				<MC2>
			and.l	UnivRomFlags,d0					; isolate the field
			sub.l	#Egret8,d0						; see if we have EgretFW
			beq.s	@haveEgret						; set Zero flag, exit

	; If we dont have Egret FW, we still might have an Caboose FW

			sub.l	#Egret8,d0						; see if we have CabooseFW
			beq.s	@haveCaboose					; if we do, chk for Cuda

@haveCuda											;								
			biglea	CudaDispatch, a0				; Cuda FW dispatcher			
			move.l	#$92,d0							; set $92 trap					
			_SetTrapAddress	,NEWOS
			
			biglea 	CudaShiftRegIRQ,a0				; stuff Cuda IRQ handler in	
			biglea	CudaTickHandler,a1				; stuff Cuda tick handler in
			bra.s	@chkDone						;								

@haveEgret
@haveCaboose
			lea		EgretDispatch, a0				; Egret FW dispatcher	
			move.l	#$92,d0							; set $92 trap			
			_SetTrapAddress	,NEWOS							;				
													;							
			lea 	ShiftRegIRQ,a0					; stuff Egret IRQ handler in
			lea		tickHandler,a1					; stuff Egret tick handler in
@chkDone
			movem.l	(sp)+, a2/d0-d2					; restore used regs
			rts
			


;--------------------------------------------------------------------------			<P2>
;SendEgretCmdPatch
;
;	This routine will determine if the Egret Chip is using Egret 8 or Caboose
;	firmware or the new Cuda firmware.  From the firmware type, determine what
;	routine to use, SendEgretCmd for Egret or Caboose, and SendCudaCmd for Cuda
;
;	NOTE:  This routine is REGISTER based, there isn't a stack						<P4>
;	SendEgretCmd is called via BSR6, so must Preserve A6, as the return address		<P4>
;	SendEgretCmdPatch is called via a BSR5 return is in A5							<P4>
;		Input:
;				a0.l	Pointer to Base address table
;
;				d0.l =  High word PACKET Command
;						Low word PACKET Type
;
;				d1.l =	Up to four bytes of data to send
;						Long word data byte assigment = byte 4, byte 3, byte 2, byte 1
;						Byte 1 sent out first
;
;				d2.l = 	Byte count to send. (0-4 bytes)
;						Byte count > 4 will send four bytes only
;
;--------------------------------------------------------------------------			<P2>

SendEgretCmdPatch
		move.l	a5, a3						; preserve patch return addr
		move.l	a6, a4						; preserve EgretInit rtn addr
		bigbsr6	GetHardwareInfo,a1			;							
		move.l	a4, a6						; restore EgretInitrtn addr	
		move.l	a3, a5						; restore patch rtn addr	
		moveq.l	#ProductInfo.ADBMask,d0		;mask for ADB kind					<23>
		and.l	d1,d0						;isolate the field					<23>
		subq.l	#ProductInfo.ADBEgret,d0	;see if we have Egret ADB			<23>
		
		and.l	#EgretFWMask,d4				; isolate the field			
		sub.l	#Egret8,d4					; see if we have Egret8 FW	
		beq.s	@patchdone					; if we do, zero flag set	
;
;	If we dont have Egret FW, we still might have an Caboose			
;
		sub.l	#Egret8,d1					; see if we have Caboose FW	
@haveEgret										; if we do, zero flag set
		beq.s	@patchdone					; its Egret or Caboose, just exit...
@haveCuda									;							
		bigjmp	SendCudaCmd,a3				; jump to Cuda Send routine	
@patchdone									;							
		movea.l	DecoderInfo.VIA1Addr(a0),a1			; get VIA 1 base address
		move.l	#((MaxTout<<16) OR MaxRetries),d4	; number of retries before giving up with Egret <13>
		rts5
		
;--------------------------------------------------------------------------
;EgretInitPatch															
;																		
;	This routine will determine if the Egret Chip is using Egret 8 or Caboose		<P4> 
;	firmware or the new Cuda firmware.  From the firmware type, determine what
;	routine to use, EgretInit for Egret or Caboose, and CudaInit for Cuda	
;																		
;	NOTE:  This routine is REGISTER based, there isn't a stack
;	EgretInit is called via BSR6, so must Preserve A6, as the return address
;	EgretInitPatch is called via a BSR5 return is in A5					
;	
EgretInitPatch								;							
		move.l	a5, a3						; preserve patch return addr
		move.l	a6, a4						; preserve EgretInit rtn addr
		bigbsr6	GetHardwareInfo,a1			;							
		move.l	a4, a6						; restore EgretInitrtn addr	
		move.l	a3, a5						; restore patch rtn addr	
		
		and.l	#EgretFWMask,d1				; isolate the field			
		sub.l	#Egret8,d1					; see if we have Egret8 FW	
		beq.s	@patchdone					; if we do, zero flag set	
;
;	If we dont have Egret FW, we still might have an Caboose			
;
		sub.l	#Egret8,d1					; see if we have Caboose FW				
@haveEgret										; if we do, zero flag set			
		beq.s	@patchdone					; its Egret or Caboose, just exit...	
@haveCuda									;										
		bigjmp	CudaInit,a3					; jump to CudaInit routine in CudaMgr.a 
@patchdone									;										
		movea.l	DecoderInfo.VIA1Addr(a0),a1	; get VIA 1 base address				
	eieioSTP
		bclr.b	#vsysSesBit,vBufB(a1)		; kill any pending transactions <8> <13> <P2>
	eieioSTP
		bclr.b	#vViaFullBit,vBufB(a1)		; 								<8> <13> <P4>
	eieioSTP
		rts5

TerrorEgret		

				IMPORT	ExplicitRequestDone, ImplicitRequestDone
;_______________________________________________________________________
;
;  Routine:		StartReqEgret
;  Inputs:		D2 - length of transmit buffer data
;				D3 - command byte / implicit flag (bit 31)
;				A2 - pointer to buffer containing transmit data
;				A3 - pointer to ADBBase
;
;  Outputs:		A3 - pointer to ADBBase
;				
;  Destroys:	A0-A2/D0-D2
;  Calls:		exits through _EgretDispatch
;
;  Function:	Sends an ADB request to the Egret, and asynchronously waits for a reply.
;
;_______________________________________________________________________

			with	ADBVars,EgretPB


jEgretDispatch	equ	OSTable+($92*4)		; OS trap table entry for _EgretDispatch

StartReqEgret
			tst.l	d3					; see if explicit/implicit
			bmi.s	@implicit			; if implicit, we generally don't need to do anything

;_______________________________________________________________________
;	Process Explicit Requests

@explicit	bset.b	#fDBExpRunning,fDBAuFlag(a3); explicit command starting, exclude new ones
			bne.s	@ignoreExplicit				; if already in progress, don't run it twice
			move.b	d3,ExplicitEPB.pbCmd(a3)	; setup the ADB command
			move.w	d2,ExplicitEPB.pbByteCnt(a3); setup byte count
			move.l	a2,ExplicitEPB.pbBufPtr(a3)	; setup buffer pointer

			bset.b	#fDBExpInited,fDBAuFlag(a3)	; see if explicit command initialization has occured
			bne.s	@expInited					; if already inited, no need to change anything

			lea		@ExplicitCompleted,a0			; explicit request completion routine address
			move.l	a0,ExplicitEPB.pbCompletion(a3)	; setup buffer pointer

			lea		ImplicitEPB(a3),a0	; point to the param block used to wait for autopoll data
			clr.l	pbCompletion(a0)	; remove the handler
			bsr.s	@SendToEgret		; remove the auto poll handler

			move.l	#(pseudoPkt<<24)\	; pcCmdType := pseudoPkt
					+(aPoll<<16)\		; pbCmd := aPoll
					+($00<<8),d0		; pbParam := $00 (only high byte is used)
			bsr.s	@syncReq			; send command to stop auto polling
@expInited

			lea		ExplicitEPB(a3),a0	; point to the param block
@SendToEgret
			moveq.l	#0,d1				; zero the trapword flag bits (in case they ever get used)
			movea.l	jEgretDispatch,a2	; get the OSTrap table entry
			jmp		(a2)				; _EgretDispatch, issue the request (asynchronously), return


;_______________________________________________________________________
;	Process Implicit Requests

@implicit	btst.b	#fDBInit,fDBFlag(a3); see if initialization is happening
			bne.s	@impDone			; if so, implicit commands are ignored
			bset.b	#fDBImpInited,fDBAuFlag(a3)	; see if implicit command initialization has occured
			beq.s	@InitImplicit		; if not inited, do initialization to allow autopolling
@ignoreExplicit
@impDone	rts							; auto-polling/srq data will arrive unsolicited from now on

@InitImplicit
			lea		ImplicitEPB(a3),a0	; point to the param block used to wait for autopoll data
			lea		@ImplicitCompleted,a1	; handler address
			move.l	a1,pbCompletion(a0)	; install the handler
			bsr.s	@SendToEgret		; install the auto poll handler

			move.l	#(pseudoPkt<<24)\	; pcCmdType := pseudoPkt
					+(wrDevList<<16),d0	; pbCmd := wrDevList
			move.w	DevMap(a3),d0		; pbParam := DevMap (in first 2 bytes)
			bsr.s	@syncReq			; send command to specify auto polling addresses

			move.l	#(pseudoPkt<<24)\	; pcCmdType := pseudoPkt
					+(aPoll<<16)\		; pbCmd := aPoll
					+($FF<<8),d0		; pbParam := $FF (only high byte is used)
										; send command to start auto polling

@syncReq	suba.w	#EgretPBSize,sp		; allocate a param block on the stack for a sync call
			movea.l	sp,a0				; point to the param block
			move.l	d0,pbCmdType(a0)	; init pcCmdType, pbCmd, and high word of pbParam
			clr.l	pbCompletion(a0)	; no completion routine, sync call
			bsr.s	@SendToEgret		; call send the request off to the ADB micro
			adda.w	#EgretPBSize,sp		; deallocate the param block
			rts							; auto-polling/srq data will arrive unsolicited from now on
			Title	'KbdADB - ADB Manager  -  ExplicitCompleted'

;_______________________________________________________________________
;
;  Routine:		@ExplicitCompleted
;  Inputs:		A0 - Pointer to the EgretPB of the Explicit Request
;
;  Outputs:		D2 - length of receive buffer data
;				D3 - command byte / SRQ flag (bit 31)
;				A2 - pointer to buffer containing receive data
;				A3 - pointer to ADBBase
;
;  Calls:		exits through ImplicitRequestDone / ExplicitRequestDone
;  Called by:	Egret Manager, Asynchronous request completion routine
;
;  Function:	Completion routine for servicing explicit ADB requests.
;
;_______________________________________________________________________

@ExplicitCompleted						; A0 := pointer to EgretPB
		if EgretDebug then
			btst.b	#EgAutoPoll,pbFlags(a0)	; see if this was from auto poll
			beq.s	@ExplicitOK			; if not, we're still OK
			_Debugger					; something is wrong with this picture
@ExplicitOK
		endif			
			moveq.l	#(1<<EgSRQ),d3		; mask to test for SRQ pending
			and.b	pbFlags(a0),d3		; isolate the SRQ flag
			neg.l	d3					; set bit 31 if SRQ pending
			move.b	pbCmd(a0),d3		; get the ADB command byte
			moveq	#0,d2				; zero extend the length
			move.w	pbByteCnt(a0),d2	; get the length
			movea.l	pbBufPtr(a0),a2		; get the buffer pointer
			bsr.s	@FillInVars			; setup A3, and ADB globals for ADB Parser
			bclr.b	#fDBExpRunning,fDBAuFlag(a3)	; explicit command completed, allow new ones

;
;	For Egret must check the ADB Device address against the Device Bitmap				<5>
;	to see if the device exists.  If it does not, force Egret to Poll the Mouse
;	as the MRU device and Keyboard as the LRU device. (Bug Fix for Egret)
;
;	Entry:	a3.l	= ADB Globals
;			d0.b	= ADB device address

			move.w	devmap(a3),d1			; get the ADB device Bitmap
			btst.l	d0,d1					; check bit position in low word
			bne.s	@exit					; Device Exits

;------------------------------------------------------------------------------
;	Force the MRU & LRU values to Mouse & Keyboard to work around bug where Egret
;	AutoPolls devices which are not in the DevMap.
;
;	Entry:		NONE
;
;	Exit:		NONE
;	
;	Destroys:	NONE
;
;------------------------------------------------------------------------------

			suba.l	#EgretPbSize,sp						; make room for Egret Manager PB
			movea.l	sp,a0
			move.l	#0,pbCompletion(a0)					; no Completion vector
			move.w	#((pseudoPkt << 8) + \
					Wr6805addr),pbCmdType(a0)			; packet type & command
			move.w	#((MouseAddr * $1000) + \			; Mouse & Keyboard into MRU & LRU
					(KbdAddr * $10)),-(sp)				; Mouse Addr in bits C-F, Kbd Addr bits 4-7
			move.l	sp,pbBufPtr(a0)						; buffer pointer in PB
			move.w	#MRUAddr,pbParam(a0)				; Egret address to write
			move.w	#2,pbByteCnt(a0)					; 2 bytes to write
			_EgretDispatch								; issue the call
			adda.l	#EgretPbSize+2,sp					; Discard Buffer & Parameter block	<5>

@exit
			bigjmp	ExplicitRequestDone,a0	; Return control to the ADB Manager

@FillInVars	movea.l	ADBBase,a3			; point to ADB globals in low memory

;	keep the ADB Parser program happy by updating the following variables
;	They are not used by this implementation, but we fill them in with approximate
;	values to make the tool happy.

			move.b	d3,fDBCmd(a3)		; last ADB command
			move.b	d3,pollCmd(a3)		; assume that it was a poll command
			move.b	d3,d0				; copy the command
			lsr.b	#4,d0				; get the address
			move.b	d0,pollAddr(a3)		; assume that it was a poll address
			rts							; all done
			Title	'KbdADB - ADB Manager  -  ImplicitCompleted'

;_______________________________________________________________________
;
;  Routine:		@ImplicitCompleted
;  Inputs:		A0 - Pointer to the EgretPB of the Implicit Request
;				D0 - Number of data bytes returned (word, 0..8)
;				A1 - Pointer to Flags, Command, Data Buffer
;
;  Outputs:		D2 - length of receive buffer data
;				D3 - command byte / SRQ flag (bit 31)
;				A2 - pointer to buffer containing receive data
;				A3 - pointer to ADBBase
;
;  Calls:		exits through ImplicitRequestDone / ExplicitRequestDone
;  Called by:	Egret Manager, Asynchronous request completion routine
;
;  Function:	Completion routine for servicing explicit ADB requests.
;
;_______________________________________________________________________

@ImplicitCompleted
		if EgretDebug then
			btst.b	#EgAutoPoll,(a1)	; see if this was from auto poll
			bne.s	@ImplicitOK			; if so, we're still OK
			_Debugger					; something is wrong with this picture
@ImplicitOK
		endif
			moveq.l	#(1<<EgSRQ),d3		; mask to test for SRQ pending
			and.b	(a1)+,d3			; isolate the SRQ flag
			neg.l	d3					; set bit 31 if SRQ pending
			move.b	(a1)+,d3			; get the ADB command byte
			moveq	#0,d2				; zero extend the length
			move.w	d0,d2				; get the length
			movea.l	a1,a2				; get the buffer pointer
			bsr.s	@FillInVars			; setup A3, and ADB globals for ADB Parser
			bigjmp	ImplicitRequestDone,a0	; Return control to the ADB Manager
			endwith



			Export		DebugEnterCont
	
DebugEnterCont
			with ProductInfo

			move.l	UnivRomFlags,d0		; get the Universal system flags
			andi.l	#ADBMask,d0			; we want ADB
			cmpi.l	#ADBEgret,d0		; and specifically EGRET version of ADB
			bne.s	@EgretDone

			endwith

;
;	Build a Egret Parameter block to stop 1 second interrupts
;
		WITH	EgretPb
			move.l	a0,-(sp)				; work registers
			suba.l	#EgretPB.EgretPbSize,sp	; room for parameter block
			move.l	sp,a0					; point to the parameter block
			move.w	#(EgretPB.EgretPBSize/2)-1,d0	; clear the PB area a word at a time

			move.l	a0,-(sp)				; save pointer to parameter block
@Loop		move.w	#0,(a0)+				; zeros forces mode 0 & no Completion vector
			dbra	d0,@Loop
			move.l	(sp)+,a0				; restore parameter block pointer

			move.w	#((pseudoPkt << 8) + Wr1SecMode),EgretPB.pbCmdType(a0)	; Packet type & command
			_EgretDispatch		
;
;	Suspend the PDM, with out reseting vars within Cuda
;
			move.w	#(PseudoPkt << 8) \
					+ EnDisPDM,pbCmdType(a0); Enable PowerDown Messages					<P3>
			clr.l	pbParam(a0)				; clr parameter blk							<P3>
			move.b	#PDMSuspend,pbParam(a0) ; PDM Continue								<P3>
			clr.l	pbCompletion(a0)		; No Completion								<P3>
;			_EgretDispatch																<SM11> gjs

			adda.l	#EgretPB.EgretPbSize,sp	; discard parameter block
			move.l	(sp)+,a0				; restore work registers
		ENDWITH
@EgretDone

			moveq.l	#noErr,d0				; return with success
			rts

;••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••

			Export		DebugExitCont
	
DebugExitCont
			with ProductInfo

			move.l	UnivRomFlags,d0		; get the Universal system flags
			andi.l	#ADBMask,d0			; we want ADB
			cmpi.l	#ADBEgret,d0		; and specifically EGRET version of ADB
			bne.s	@EgretDone

			endwith

;
;	Build a Egret Parameter block to start 1 second interrupts (Mode 3)
;
		WITH	EgretPB
			move.l	a0,-(sp)				; work registers
			suba.l	#EgretPB.EgretPbSize,sp	; room for parameter block
			move.l	sp,a0					; point to the parameter block
			move.w	#(EgretPB.EgretPBSize/2)-1,d0	; clear the PB area a word at a time

			move.l	a0,-(sp)				; save pointer to parameter block
@Loop		move.w	#0,(a0)+				; zeros forces mode 0 & no Completion vector
			dbra	d0,@Loop
			move.l	(sp)+,a0				; restore parameter block pointer
			move.w	#((pseudoPkt << 8) + Wr1SecMode),EgretPB.pbCmdType(a0)	; Packet type & command
			move.b	#Mode3Clock,EgretPB.pbParam(a0)	; Turn on Mode 3 clock data packets
			_EgretDispatch		
;
;	Macsbug Continue the PDM
;
			move.w	#(PseudoPkt << 8) \
					+ EnDisPDM,pbCmdType(a0); Enable PowerDown Messages					<P3>
			clr.l	pbParam(a0)				; clr parameter blk							<P3>
			move.b	#PDMDebugCont,pbParam(a0) 		; Macsbug Continue				<SM11> gjs <P3>
			clr.l	pbCompletion(a0)		; No Completion								<P3>
			_EgretDispatch

			adda.l	#EgretPB.EgretPbSize,sp	; discard parameter block
			move.l	(sp)+,a0				; restore work registers
@EgretDone
		ENDWITH
			moveq.l	#noErr,d0				; return with success
			CLR.B	DSWndUpdate 			; flag GNE to remove the alert . . . just in case <SM11> gjs
			rts

			ENDP
			END